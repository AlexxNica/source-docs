<!DOCTYPE html><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="Content-Language" content="en"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>codemirror.js</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><div class="content"><main><article class="srcfile"><h1>front_end/cm/codemirror.js</h1><div><table><tr><td><a id="l1"></a><a href="#l1">1</a><td>// CodeMirror, copyright (c) by Marijn Haverbeke and others<tr><td><a id="l2"></a><a href="#l2">2</a><td>// Distributed under an MIT license: http://codemirror.net/LICENSE<tr><td><a id="l3"></a><a href="#l3">3</a><td><tr><td><a id="l4"></a><a href="#l4">4</a><td>// This is CodeMirror (http://codemirror.net), a code editor<tr><td><a id="l5"></a><a href="#l5">5</a><td>// implemented in JavaScript on top of the browser&#39;s DOM.<tr><td><a id="l6"></a><a href="#l6">6</a><td>//<tr><td><a id="l7"></a><a href="#l7">7</a><td>// You can find some technical background for some of the code below<tr><td><a id="l8"></a><a href="#l8">8</a><td>// at http://marijnhaverbeke.nl/blog/#cm-internals .<tr><td><a id="l9"></a><a href="#l9">9</a><td><tr><td><a id="l10"></a><a href="#l10">10</a><td>(function(mod) {<tr><td><a id="l11"></a><a href="#l11">11</a><td>  if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS<tr><td><a id="l12"></a><a href="#l12">12</a><td>    module.exports = mod();<tr><td><a id="l13"></a><a href="#l13">13</a><td>  else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD<tr><td><a id="l14"></a><a href="#l14">14</a><td>    return define([], mod);<tr><td><a id="l15"></a><a href="#l15">15</a><td>  else // Plain browser env<tr><td><a id="l16"></a><a href="#l16">16</a><td>    (this || window).CodeMirror = mod();<tr><td><a id="l17"></a><a href="#l17">17</a><td>})(function() {<tr><td><a id="l18"></a><a href="#l18">18</a><td>  &quot;use strict&quot;;<tr><td><a id="l19"></a><a href="#l19">19</a><td><tr><td><a id="l20"></a><a href="#l20">20</a><td>  // BROWSER SNIFFING<tr><td><a id="l21"></a><a href="#l21">21</a><td><tr><td><a id="l22"></a><a href="#l22">22</a><td>  // Kludges for bugs and behavior differences that can&#39;t be feature<tr><td><a id="l23"></a><a href="#l23">23</a><td>  // detected are enabled based on userAgent etc sniffing.<tr><td><a id="l24"></a><a href="#l24">24</a><td>  var userAgent = navigator.userAgent;<tr><td><a id="l25"></a><a href="#l25">25</a><td>  var platform = navigator.platform;<tr><td><a id="l26"></a><a href="#l26">26</a><td><tr><td><a id="l27"></a><a href="#l27">27</a><td>  var gecko = /gecko\/\d/i.test(userAgent);<tr><td><a id="l28"></a><a href="#l28">28</a><td>  var ie_upto10 = /MSIE \d/.test(userAgent);<tr><td><a id="l29"></a><a href="#l29">29</a><td>  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);<tr><td><a id="l30"></a><a href="#l30">30</a><td>  var ie = ie_upto10 || ie_11up;<tr><td><a id="l31"></a><a href="#l31">31</a><td>  var ie_version = ie &amp;&amp; (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);<tr><td><a id="l32"></a><a href="#l32">32</a><td>  var webkit = /WebKit\//.test(userAgent);<tr><td><a id="l33"></a><a href="#l33">33</a><td>  var qtwebkit = webkit &amp;&amp; /Qt\/\d+\.\d+/.test(userAgent);<tr><td><a id="l34"></a><a href="#l34">34</a><td>  var chrome = /Chrome\//.test(userAgent);<tr><td><a id="l35"></a><a href="#l35">35</a><td>  var presto = /Opera\//.test(userAgent);<tr><td><a id="l36"></a><a href="#l36">36</a><td>  var safari = /Apple Computer/.test(navigator.vendor);<tr><td><a id="l37"></a><a href="#l37">37</a><td>  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);<tr><td><a id="l38"></a><a href="#l38">38</a><td>  var phantom = /PhantomJS/.test(userAgent);<tr><td><a id="l39"></a><a href="#l39">39</a><td><tr><td><a id="l40"></a><a href="#l40">40</a><td>  var ios = /AppleWebKit/.test(userAgent) &amp;&amp; /Mobile\/\w+/.test(userAgent);<tr><td><a id="l41"></a><a href="#l41">41</a><td>  // This is woefully incomplete. Suggestions for alternative methods welcome.<tr><td><a id="l42"></a><a href="#l42">42</a><td>  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);<tr><td><a id="l43"></a><a href="#l43">43</a><td>  var mac = ios || /Mac/.test(platform);<tr><td><a id="l44"></a><a href="#l44">44</a><td>  var chromeOS = /\bCrOS\b/.test(userAgent);<tr><td><a id="l45"></a><a href="#l45">45</a><td>  var windows = /win/i.test(platform);<tr><td><a id="l46"></a><a href="#l46">46</a><td><tr><td><a id="l47"></a><a href="#l47">47</a><td>  var presto_version = presto &amp;&amp; userAgent.match(/Version\/(\d*\.\d*)/);<tr><td><a id="l48"></a><a href="#l48">48</a><td>  if (presto_version) presto_version = Number(presto_version[1]);<tr><td><a id="l49"></a><a href="#l49">49</a><td>  if (presto_version &amp;&amp; presto_version &gt;= 15) { presto = false; webkit = true; }<tr><td><a id="l50"></a><a href="#l50">50</a><td>  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X<tr><td><a id="l51"></a><a href="#l51">51</a><td>  var flipCtrlCmd = mac &amp;&amp; (qtwebkit || presto &amp;&amp; (presto_version == null || presto_version &lt; 12.11));<tr><td><a id="l52"></a><a href="#l52">52</a><td>  var captureRightClick = gecko || (ie &amp;&amp; ie_version &gt;= 9);<tr><td><a id="l53"></a><a href="#l53">53</a><td><tr><td><a id="l54"></a><a href="#l54">54</a><td>  // Optimize some code when these features are not used.<tr><td><a id="l55"></a><a href="#l55">55</a><td>  var sawReadOnlySpans = false, sawCollapsedSpans = false;<tr><td><a id="l56"></a><a href="#l56">56</a><td><tr><td><a id="l57"></a><a href="#l57">57</a><td>  // EDITOR CONSTRUCTOR<tr><td><a id="l58"></a><a href="#l58">58</a><td><tr><td><a id="l59"></a><a href="#l59">59</a><td>  // A CodeMirror instance represents an editor. This is the object<tr><td><a id="l60"></a><a href="#l60">60</a><td>  // that user code is usually dealing with.<tr><td><a id="l61"></a><a href="#l61">61</a><td><tr><td><a id="l62"></a><a href="#l62">62</a><td>  function CodeMirror(place, options) {<tr><td><a id="l63"></a><a href="#l63">63</a><td>    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);<tr><td><a id="l64"></a><a href="#l64">64</a><td><tr><td><a id="l65"></a><a href="#l65">65</a><td>    this.options = options = options ? copyObj(options) : {};<tr><td><a id="l66"></a><a href="#l66">66</a><td>    // Determine effective options based on given values and defaults.<tr><td><a id="l67"></a><a href="#l67">67</a><td>    copyObj(defaults, options, false);<tr><td><a id="l68"></a><a href="#l68">68</a><td>    setGuttersForLineNumbers(options);<tr><td><a id="l69"></a><a href="#l69">69</a><td><tr><td><a id="l70"></a><a href="#l70">70</a><td>    var doc = options.value;<tr><td><a id="l71"></a><a href="#l71">71</a><td>    if (typeof doc == &quot;string&quot;) doc = new Doc(doc, options.mode, null, options.lineSeparator);<tr><td><a id="l72"></a><a href="#l72">72</a><td>    this.doc = doc;<tr><td><a id="l73"></a><a href="#l73">73</a><td><tr><td><a id="l74"></a><a href="#l74">74</a><td>    var input = new CodeMirror.inputStyles[options.inputStyle](this);<tr><td><a id="l75"></a><a href="#l75">75</a><td>    var display = this.display = new Display(place, doc, input);<tr><td><a id="l76"></a><a href="#l76">76</a><td>    display.wrapper.CodeMirror = this;<tr><td><a id="l77"></a><a href="#l77">77</a><td>    updateGutters(this);<tr><td><a id="l78"></a><a href="#l78">78</a><td>    themeChanged(this);<tr><td><a id="l79"></a><a href="#l79">79</a><td>    if (options.lineWrapping)<tr><td><a id="l80"></a><a href="#l80">80</a><td>      this.display.wrapper.className += &quot; CodeMirror-wrap&quot;;<tr><td><a id="l81"></a><a href="#l81">81</a><td>    if (options.autofocus &amp;&amp; !mobile) display.input.focus();<tr><td><a id="l82"></a><a href="#l82">82</a><td>    initScrollbars(this);<tr><td><a id="l83"></a><a href="#l83">83</a><td><tr><td><a id="l84"></a><a href="#l84">84</a><td>    this.state = {<tr><td><a id="l85"></a><a href="#l85">85</a><td>      keyMaps: [],  // stores maps added by addKeyMap<tr><td><a id="l86"></a><a href="#l86">86</a><td>      overlays: [], // highlighting overlays, as added by addOverlay<tr><td><a id="l87"></a><a href="#l87">87</a><td>      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info<tr><td><a id="l88"></a><a href="#l88">88</a><td>      overwrite: false,<tr><td><a id="l89"></a><a href="#l89">89</a><td>      delayingBlurEvent: false,<tr><td><a id="l90"></a><a href="#l90">90</a><td>      focused: false,<tr><td><a id="l91"></a><a href="#l91">91</a><td>      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode<tr><td><a id="l92"></a><a href="#l92">92</a><td>      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll<tr><td><a id="l93"></a><a href="#l93">93</a><td>      selectingText: false,<tr><td><a id="l94"></a><a href="#l94">94</a><td>      draggingText: false,<tr><td><a id="l95"></a><a href="#l95">95</a><td>      highlight: new Delayed(), // stores highlight worker timeout<tr><td><a id="l96"></a><a href="#l96">96</a><td>      keySeq: null,  // Unfinished key sequence<tr><td><a id="l97"></a><a href="#l97">97</a><td>      specialChars: null<tr><td><a id="l98"></a><a href="#l98">98</a><td>    };<tr><td><a id="l99"></a><a href="#l99">99</a><td><tr><td><a id="l100"></a><a href="#l100">100</a><td>    var cm = this;<tr><td><a id="l101"></a><a href="#l101">101</a><td><tr><td><a id="l102"></a><a href="#l102">102</a><td>    // Override magic textarea content restore that IE sometimes does<tr><td><a id="l103"></a><a href="#l103">103</a><td>    // on our hidden textarea on reload<tr><td><a id="l104"></a><a href="#l104">104</a><td>    if (ie &amp;&amp; ie_version &lt; 11) setTimeout(function() { cm.display.input.reset(true); }, 20);<tr><td><a id="l105"></a><a href="#l105">105</a><td><tr><td><a id="l106"></a><a href="#l106">106</a><td>    registerEventHandlers(this);<tr><td><a id="l107"></a><a href="#l107">107</a><td>    ensureGlobalHandlers();<tr><td><a id="l108"></a><a href="#l108">108</a><td><tr><td><a id="l109"></a><a href="#l109">109</a><td>    startOperation(this);<tr><td><a id="l110"></a><a href="#l110">110</a><td>    this.curOp.forceUpdate = true;<tr><td><a id="l111"></a><a href="#l111">111</a><td>    attachDoc(this, doc);<tr><td><a id="l112"></a><a href="#l112">112</a><td><tr><td><a id="l113"></a><a href="#l113">113</a><td>    if ((options.autofocus &amp;&amp; !mobile) || cm.hasFocus())<tr><td><a id="l114"></a><a href="#l114">114</a><td>      setTimeout(bind(onFocus, this), 20);<tr><td><a id="l115"></a><a href="#l115">115</a><td>    else<tr><td><a id="l116"></a><a href="#l116">116</a><td>      onBlur(this);<tr><td><a id="l117"></a><a href="#l117">117</a><td><tr><td><a id="l118"></a><a href="#l118">118</a><td>    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))<tr><td><a id="l119"></a><a href="#l119">119</a><td>      optionHandlers[opt](this, options[opt], Init);<tr><td><a id="l120"></a><a href="#l120">120</a><td>    maybeUpdateLineNumberWidth(this);<tr><td><a id="l121"></a><a href="#l121">121</a><td>    if (options.finishInit) options.finishInit(this);<tr><td><a id="l122"></a><a href="#l122">122</a><td>    for (var i = 0; i &lt; initHooks.length; ++i) initHooks[i](this);<tr><td><a id="l123"></a><a href="#l123">123</a><td>    endOperation(this);<tr><td><a id="l124"></a><a href="#l124">124</a><td>    // Suppress optimizelegibility in Webkit, since it breaks text<tr><td><a id="l125"></a><a href="#l125">125</a><td>    // measuring on line wrapping boundaries.<tr><td><a id="l126"></a><a href="#l126">126</a><td>    if (webkit &amp;&amp; options.lineWrapping &amp;&amp;<tr><td><a id="l127"></a><a href="#l127">127</a><td>        getComputedStyle(display.lineDiv).textRendering == &quot;optimizelegibility&quot;)<tr><td><a id="l128"></a><a href="#l128">128</a><td>      display.lineDiv.style.textRendering = &quot;auto&quot;;<tr><td><a id="l129"></a><a href="#l129">129</a><td>  }<tr><td><a id="l130"></a><a href="#l130">130</a><td><tr><td><a id="l131"></a><a href="#l131">131</a><td>  // DISPLAY CONSTRUCTOR<tr><td><a id="l132"></a><a href="#l132">132</a><td><tr><td><a id="l133"></a><a href="#l133">133</a><td>  // The display handles the DOM integration, both for input reading<tr><td><a id="l134"></a><a href="#l134">134</a><td>  // and content drawing. It holds references to DOM nodes and<tr><td><a id="l135"></a><a href="#l135">135</a><td>  // display-related state.<tr><td><a id="l136"></a><a href="#l136">136</a><td><tr><td><a id="l137"></a><a href="#l137">137</a><td>  function Display(place, doc, input) {<tr><td><a id="l138"></a><a href="#l138">138</a><td>    var d = this;<tr><td><a id="l139"></a><a href="#l139">139</a><td>    this.input = input;<tr><td><a id="l140"></a><a href="#l140">140</a><td><tr><td><a id="l141"></a><a href="#l141">141</a><td>    // Covers bottom-right square when both scrollbars are present.<tr><td><a id="l142"></a><a href="#l142">142</a><td>    d.scrollbarFiller = elt(&quot;div&quot;, null, &quot;CodeMirror-scrollbar-filler&quot;);<tr><td><a id="l143"></a><a href="#l143">143</a><td>    d.scrollbarFiller.setAttribute(&quot;cm-not-content&quot;, &quot;true&quot;);<tr><td><a id="l144"></a><a href="#l144">144</a><td>    // Covers bottom of gutter when coverGutterNextToScrollbar is on<tr><td><a id="l145"></a><a href="#l145">145</a><td>    // and h scrollbar is present.<tr><td><a id="l146"></a><a href="#l146">146</a><td>    d.gutterFiller = elt(&quot;div&quot;, null, &quot;CodeMirror-gutter-filler&quot;);<tr><td><a id="l147"></a><a href="#l147">147</a><td>    d.gutterFiller.setAttribute(&quot;cm-not-content&quot;, &quot;true&quot;);<tr><td><a id="l148"></a><a href="#l148">148</a><td>    // Will contain the actual code, positioned to cover the viewport.<tr><td><a id="l149"></a><a href="#l149">149</a><td>    d.lineDiv = elt(&quot;div&quot;, null, &quot;CodeMirror-code&quot;);<tr><td><a id="l150"></a><a href="#l150">150</a><td>    // Elements are added to these to represent selection and cursors.<tr><td><a id="l151"></a><a href="#l151">151</a><td>    d.selectionDiv = elt(&quot;div&quot;, null, null, &quot;position: relative; z-index: 1&quot;);<tr><td><a id="l152"></a><a href="#l152">152</a><td>    d.cursorDiv = elt(&quot;div&quot;, null, &quot;CodeMirror-cursors&quot;);<tr><td><a id="l153"></a><a href="#l153">153</a><td>    // A visibility: hidden element used to find the size of things.<tr><td><a id="l154"></a><a href="#l154">154</a><td>    d.measure = elt(&quot;div&quot;, null, &quot;CodeMirror-measure&quot;);<tr><td><a id="l155"></a><a href="#l155">155</a><td>    // When lines outside of the viewport are measured, they are drawn in this.<tr><td><a id="l156"></a><a href="#l156">156</a><td>    d.lineMeasure = elt(&quot;div&quot;, null, &quot;CodeMirror-measure&quot;);<tr><td><a id="l157"></a><a href="#l157">157</a><td>    // Wraps everything that needs to exist inside the vertically-padded coordinate system<tr><td><a id="l158"></a><a href="#l158">158</a><td>    d.lineSpace = elt(&quot;div&quot;, [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],<tr><td><a id="l159"></a><a href="#l159">159</a><td>                      null, &quot;position: relative; outline: none&quot;);<tr><td><a id="l160"></a><a href="#l160">160</a><td>    // Moved around its parent to cover visible view.<tr><td><a id="l161"></a><a href="#l161">161</a><td>    d.mover = elt(&quot;div&quot;, [elt(&quot;div&quot;, [d.lineSpace], &quot;CodeMirror-lines&quot;)], null, &quot;position: relative&quot;);<tr><td><a id="l162"></a><a href="#l162">162</a><td>    // Set to the height of the document, allowing scrolling.<tr><td><a id="l163"></a><a href="#l163">163</a><td>    d.sizer = elt(&quot;div&quot;, [d.mover], &quot;CodeMirror-sizer&quot;);<tr><td><a id="l164"></a><a href="#l164">164</a><td>    d.sizerWidth = null;<tr><td><a id="l165"></a><a href="#l165">165</a><td>    // Behavior of elts with overflow: auto and padding is<tr><td><a id="l166"></a><a href="#l166">166</a><td>    // inconsistent across browsers. This is used to ensure the<tr><td><a id="l167"></a><a href="#l167">167</a><td>    // scrollable area is big enough.<tr><td><a id="l168"></a><a href="#l168">168</a><td>    d.heightForcer = elt(&quot;div&quot;, null, null, &quot;position: absolute; height: &quot; + scrollerGap + &quot;px; width: 1px;&quot;);<tr><td><a id="l169"></a><a href="#l169">169</a><td>    // Will contain the gutters, if any.<tr><td><a id="l170"></a><a href="#l170">170</a><td>    d.gutters = elt(&quot;div&quot;, null, &quot;CodeMirror-gutters&quot;);<tr><td><a id="l171"></a><a href="#l171">171</a><td>    d.lineGutter = null;<tr><td><a id="l172"></a><a href="#l172">172</a><td>    // Actual scrollable element.<tr><td><a id="l173"></a><a href="#l173">173</a><td>    d.scroller = elt(&quot;div&quot;, [d.sizer, d.heightForcer, d.gutters], &quot;CodeMirror-scroll&quot;);<tr><td><a id="l174"></a><a href="#l174">174</a><td>    d.scroller.setAttribute(&quot;tabIndex&quot;, &quot;-1&quot;);<tr><td><a id="l175"></a><a href="#l175">175</a><td>    // The element in which the editor lives.<tr><td><a id="l176"></a><a href="#l176">176</a><td>    d.wrapper = elt(&quot;div&quot;, [d.scrollbarFiller, d.gutterFiller, d.scroller], &quot;CodeMirror&quot;);<tr><td><a id="l177"></a><a href="#l177">177</a><td><tr><td><a id="l178"></a><a href="#l178">178</a><td>    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)<tr><td><a id="l179"></a><a href="#l179">179</a><td>    if (ie &amp;&amp; ie_version &lt; 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }<tr><td><a id="l180"></a><a href="#l180">180</a><td>    if (!webkit &amp;&amp; !(gecko &amp;&amp; mobile)) d.scroller.draggable = true;<tr><td><a id="l181"></a><a href="#l181">181</a><td><tr><td><a id="l182"></a><a href="#l182">182</a><td>    if (place) {<tr><td><a id="l183"></a><a href="#l183">183</a><td>      if (place.appendChild) place.appendChild(d.wrapper);<tr><td><a id="l184"></a><a href="#l184">184</a><td>      else place(d.wrapper);<tr><td><a id="l185"></a><a href="#l185">185</a><td>    }<tr><td><a id="l186"></a><a href="#l186">186</a><td><tr><td><a id="l187"></a><a href="#l187">187</a><td>    // Current rendered range (may be bigger than the view window).<tr><td><a id="l188"></a><a href="#l188">188</a><td>    d.viewFrom = d.viewTo = doc.first;<tr><td><a id="l189"></a><a href="#l189">189</a><td>    d.reportedViewFrom = d.reportedViewTo = doc.first;<tr><td><a id="l190"></a><a href="#l190">190</a><td>    // Information about the rendered lines.<tr><td><a id="l191"></a><a href="#l191">191</a><td>    d.view = [];<tr><td><a id="l192"></a><a href="#l192">192</a><td>    d.renderedView = null;<tr><td><a id="l193"></a><a href="#l193">193</a><td>    // Holds info about a single rendered line when it was rendered<tr><td><a id="l194"></a><a href="#l194">194</a><td>    // for measurement, while not in view.<tr><td><a id="l195"></a><a href="#l195">195</a><td>    d.externalMeasured = null;<tr><td><a id="l196"></a><a href="#l196">196</a><td>    // Empty space (in pixels) above the view<tr><td><a id="l197"></a><a href="#l197">197</a><td>    d.viewOffset = 0;<tr><td><a id="l198"></a><a href="#l198">198</a><td>    d.lastWrapHeight = d.lastWrapWidth = 0;<tr><td><a id="l199"></a><a href="#l199">199</a><td>    d.updateLineNumbers = null;<tr><td><a id="l200"></a><a href="#l200">200</a><td><tr><td><a id="l201"></a><a href="#l201">201</a><td>    d.nativeBarWidth = d.barHeight = d.barWidth = 0;<tr><td><a id="l202"></a><a href="#l202">202</a><td>    d.scrollbarsClipped = false;<tr><td><a id="l203"></a><a href="#l203">203</a><td><tr><td><a id="l204"></a><a href="#l204">204</a><td>    // Used to only resize the line number gutter when necessary (when<tr><td><a id="l205"></a><a href="#l205">205</a><td>    // the amount of lines crosses a boundary that makes its width change)<tr><td><a id="l206"></a><a href="#l206">206</a><td>    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;<tr><td><a id="l207"></a><a href="#l207">207</a><td>    // Set to true when a non-horizontal-scrolling line widget is<tr><td><a id="l208"></a><a href="#l208">208</a><td>    // added. As an optimization, line widget aligning is skipped when<tr><td><a id="l209"></a><a href="#l209">209</a><td>    // this is false.<tr><td><a id="l210"></a><a href="#l210">210</a><td>    d.alignWidgets = false;<tr><td><a id="l211"></a><a href="#l211">211</a><td><tr><td><a id="l212"></a><a href="#l212">212</a><td>    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;<tr><td><a id="l213"></a><a href="#l213">213</a><td><tr><td><a id="l214"></a><a href="#l214">214</a><td>    // Tracks the maximum line length so that the horizontal scrollbar<tr><td><a id="l215"></a><a href="#l215">215</a><td>    // can be kept static when scrolling.<tr><td><a id="l216"></a><a href="#l216">216</a><td>    d.maxLine = null;<tr><td><a id="l217"></a><a href="#l217">217</a><td>    d.maxLineLength = 0;<tr><td><a id="l218"></a><a href="#l218">218</a><td>    d.maxLineChanged = false;<tr><td><a id="l219"></a><a href="#l219">219</a><td><tr><td><a id="l220"></a><a href="#l220">220</a><td>    // Used for measuring wheel scrolling granularity<tr><td><a id="l221"></a><a href="#l221">221</a><td>    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;<tr><td><a id="l222"></a><a href="#l222">222</a><td><tr><td><a id="l223"></a><a href="#l223">223</a><td>    // True when shift is held down.<tr><td><a id="l224"></a><a href="#l224">224</a><td>    d.shift = false;<tr><td><a id="l225"></a><a href="#l225">225</a><td><tr><td><a id="l226"></a><a href="#l226">226</a><td>    // Used to track whether anything happened since the context menu<tr><td><a id="l227"></a><a href="#l227">227</a><td>    // was opened.<tr><td><a id="l228"></a><a href="#l228">228</a><td>    d.selForContextMenu = null;<tr><td><a id="l229"></a><a href="#l229">229</a><td><tr><td><a id="l230"></a><a href="#l230">230</a><td>    d.activeTouch = null;<tr><td><a id="l231"></a><a href="#l231">231</a><td><tr><td><a id="l232"></a><a href="#l232">232</a><td>    input.init(d);<tr><td><a id="l233"></a><a href="#l233">233</a><td>  }<tr><td><a id="l234"></a><a href="#l234">234</a><td><tr><td><a id="l235"></a><a href="#l235">235</a><td>  // STATE UPDATES<tr><td><a id="l236"></a><a href="#l236">236</a><td><tr><td><a id="l237"></a><a href="#l237">237</a><td>  // Used to get the editor into a consistent state again when options change.<tr><td><a id="l238"></a><a href="#l238">238</a><td><tr><td><a id="l239"></a><a href="#l239">239</a><td>  function loadMode(cm) {<tr><td><a id="l240"></a><a href="#l240">240</a><td>    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);<tr><td><a id="l241"></a><a href="#l241">241</a><td>    resetModeState(cm);<tr><td><a id="l242"></a><a href="#l242">242</a><td>  }<tr><td><a id="l243"></a><a href="#l243">243</a><td><tr><td><a id="l244"></a><a href="#l244">244</a><td>  function resetModeState(cm) {<tr><td><a id="l245"></a><a href="#l245">245</a><td>    cm.doc.iter(function(line) {<tr><td><a id="l246"></a><a href="#l246">246</a><td>      if (line.stateAfter) line.stateAfter = null;<tr><td><a id="l247"></a><a href="#l247">247</a><td>      if (line.styles) line.styles = null;<tr><td><a id="l248"></a><a href="#l248">248</a><td>    });<tr><td><a id="l249"></a><a href="#l249">249</a><td>    cm.doc.frontier = cm.doc.first;<tr><td><a id="l250"></a><a href="#l250">250</a><td>    startWorker(cm, 100);<tr><td><a id="l251"></a><a href="#l251">251</a><td>    cm.state.modeGen++;<tr><td><a id="l252"></a><a href="#l252">252</a><td>    if (cm.curOp) regChange(cm);<tr><td><a id="l253"></a><a href="#l253">253</a><td>  }<tr><td><a id="l254"></a><a href="#l254">254</a><td><tr><td><a id="l255"></a><a href="#l255">255</a><td>  function wrappingChanged(cm) {<tr><td><a id="l256"></a><a href="#l256">256</a><td>    if (cm.options.lineWrapping) {<tr><td><a id="l257"></a><a href="#l257">257</a><td>      addClass(cm.display.wrapper, &quot;CodeMirror-wrap&quot;);<tr><td><a id="l258"></a><a href="#l258">258</a><td>      cm.display.sizer.style.minWidth = &quot;&quot;;<tr><td><a id="l259"></a><a href="#l259">259</a><td>      cm.display.sizerWidth = null;<tr><td><a id="l260"></a><a href="#l260">260</a><td>    } else {<tr><td><a id="l261"></a><a href="#l261">261</a><td>      rmClass(cm.display.wrapper, &quot;CodeMirror-wrap&quot;);<tr><td><a id="l262"></a><a href="#l262">262</a><td>      findMaxLine(cm);<tr><td><a id="l263"></a><a href="#l263">263</a><td>    }<tr><td><a id="l264"></a><a href="#l264">264</a><td>    estimateLineHeights(cm);<tr><td><a id="l265"></a><a href="#l265">265</a><td>    regChange(cm);<tr><td><a id="l266"></a><a href="#l266">266</a><td>    clearCaches(cm);<tr><td><a id="l267"></a><a href="#l267">267</a><td>    setTimeout(function(){updateScrollbars(cm);}, 100);<tr><td><a id="l268"></a><a href="#l268">268</a><td>  }<tr><td><a id="l269"></a><a href="#l269">269</a><td><tr><td><a id="l270"></a><a href="#l270">270</a><td>  // Returns a function that estimates the height of a line, to use as<tr><td><a id="l271"></a><a href="#l271">271</a><td>  // first approximation until the line becomes visible (and is thus<tr><td><a id="l272"></a><a href="#l272">272</a><td>  // properly measurable).<tr><td><a id="l273"></a><a href="#l273">273</a><td>  function estimateHeight(cm) {<tr><td><a id="l274"></a><a href="#l274">274</a><td>    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;<tr><td><a id="l275"></a><a href="#l275">275</a><td>    var perLine = wrapping &amp;&amp; Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);<tr><td><a id="l276"></a><a href="#l276">276</a><td>    return function(line) {<tr><td><a id="l277"></a><a href="#l277">277</a><td>      if (lineIsHidden(cm.doc, line)) return 0;<tr><td><a id="l278"></a><a href="#l278">278</a><td><tr><td><a id="l279"></a><a href="#l279">279</a><td>      var widgetsHeight = 0;<tr><td><a id="l280"></a><a href="#l280">280</a><td>      if (line.widgets) for (var i = 0; i &lt; line.widgets.length; i++) {<tr><td><a id="l281"></a><a href="#l281">281</a><td>        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;<tr><td><a id="l282"></a><a href="#l282">282</a><td>      }<tr><td><a id="l283"></a><a href="#l283">283</a><td><tr><td><a id="l284"></a><a href="#l284">284</a><td>      if (wrapping)<tr><td><a id="l285"></a><a href="#l285">285</a><td>        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;<tr><td><a id="l286"></a><a href="#l286">286</a><td>      else<tr><td><a id="l287"></a><a href="#l287">287</a><td>        return widgetsHeight + th;<tr><td><a id="l288"></a><a href="#l288">288</a><td>    };<tr><td><a id="l289"></a><a href="#l289">289</a><td>  }<tr><td><a id="l290"></a><a href="#l290">290</a><td><tr><td><a id="l291"></a><a href="#l291">291</a><td>  function estimateLineHeights(cm) {<tr><td><a id="l292"></a><a href="#l292">292</a><td>    var doc = cm.doc, est = estimateHeight(cm);<tr><td><a id="l293"></a><a href="#l293">293</a><td>    doc.iter(function(line) {<tr><td><a id="l294"></a><a href="#l294">294</a><td>      var estHeight = est(line);<tr><td><a id="l295"></a><a href="#l295">295</a><td>      if (estHeight != line.height) updateLineHeight(line, estHeight);<tr><td><a id="l296"></a><a href="#l296">296</a><td>    });<tr><td><a id="l297"></a><a href="#l297">297</a><td>  }<tr><td><a id="l298"></a><a href="#l298">298</a><td><tr><td><a id="l299"></a><a href="#l299">299</a><td>  function themeChanged(cm) {<tr><td><a id="l300"></a><a href="#l300">300</a><td>    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, &quot;&quot;) +<tr><td><a id="l301"></a><a href="#l301">301</a><td>      cm.options.theme.replace(/(^|\s)\s*/g, &quot; cm-s-&quot;);<tr><td><a id="l302"></a><a href="#l302">302</a><td>    clearCaches(cm);<tr><td><a id="l303"></a><a href="#l303">303</a><td>  }<tr><td><a id="l304"></a><a href="#l304">304</a><td><tr><td><a id="l305"></a><a href="#l305">305</a><td>  function guttersChanged(cm) {<tr><td><a id="l306"></a><a href="#l306">306</a><td>    updateGutters(cm);<tr><td><a id="l307"></a><a href="#l307">307</a><td>    regChange(cm);<tr><td><a id="l308"></a><a href="#l308">308</a><td>    setTimeout(function(){alignHorizontally(cm);}, 20);<tr><td><a id="l309"></a><a href="#l309">309</a><td>  }<tr><td><a id="l310"></a><a href="#l310">310</a><td><tr><td><a id="l311"></a><a href="#l311">311</a><td>  // Rebuild the gutter elements, ensure the margin to the left of the<tr><td><a id="l312"></a><a href="#l312">312</a><td>  // code matches their width.<tr><td><a id="l313"></a><a href="#l313">313</a><td>  function updateGutters(cm) {<tr><td><a id="l314"></a><a href="#l314">314</a><td>    var gutters = cm.display.gutters, specs = cm.options.gutters;<tr><td><a id="l315"></a><a href="#l315">315</a><td>    removeChildren(gutters);<tr><td><a id="l316"></a><a href="#l316">316</a><td>    for (var i = 0; i &lt; specs.length; ++i) {<tr><td><a id="l317"></a><a href="#l317">317</a><td>      var gutterClass = specs[i];<tr><td><a id="l318"></a><a href="#l318">318</a><td>      var gElt = gutters.appendChild(elt(&quot;div&quot;, null, &quot;CodeMirror-gutter &quot; + gutterClass));<tr><td><a id="l319"></a><a href="#l319">319</a><td>      if (gutterClass == &quot;CodeMirror-linenumbers&quot;) {<tr><td><a id="l320"></a><a href="#l320">320</a><td>        cm.display.lineGutter = gElt;<tr><td><a id="l321"></a><a href="#l321">321</a><td>        gElt.style.width = (cm.display.lineNumWidth || 1) + &quot;px&quot;;<tr><td><a id="l322"></a><a href="#l322">322</a><td>      }<tr><td><a id="l323"></a><a href="#l323">323</a><td>    }<tr><td><a id="l324"></a><a href="#l324">324</a><td>    gutters.style.display = i ? &quot;&quot; : &quot;none&quot;;<tr><td><a id="l325"></a><a href="#l325">325</a><td>    updateGutterSpace(cm);<tr><td><a id="l326"></a><a href="#l326">326</a><td>  }<tr><td><a id="l327"></a><a href="#l327">327</a><td><tr><td><a id="l328"></a><a href="#l328">328</a><td>  function updateGutterSpace(cm) {<tr><td><a id="l329"></a><a href="#l329">329</a><td>    var width = cm.display.gutters.offsetWidth;<tr><td><a id="l330"></a><a href="#l330">330</a><td>    cm.display.sizer.style.marginLeft = width + &quot;px&quot;;<tr><td><a id="l331"></a><a href="#l331">331</a><td>  }<tr><td><a id="l332"></a><a href="#l332">332</a><td><tr><td><a id="l333"></a><a href="#l333">333</a><td>  // Compute the character length of a line, taking into account<tr><td><a id="l334"></a><a href="#l334">334</a><td>  // collapsed ranges (see markText) that might hide parts, and join<tr><td><a id="l335"></a><a href="#l335">335</a><td>  // other lines onto it.<tr><td><a id="l336"></a><a href="#l336">336</a><td>  function lineLength(line) {<tr><td><a id="l337"></a><a href="#l337">337</a><td>    if (line.height == 0) return 0;<tr><td><a id="l338"></a><a href="#l338">338</a><td>    var len = line.text.length, merged, cur = line;<tr><td><a id="l339"></a><a href="#l339">339</a><td>    while (merged = collapsedSpanAtStart(cur)) {<tr><td><a id="l340"></a><a href="#l340">340</a><td>      var found = merged.find(0, true);<tr><td><a id="l341"></a><a href="#l341">341</a><td>      cur = found.from.line;<tr><td><a id="l342"></a><a href="#l342">342</a><td>      len += found.from.ch - found.to.ch;<tr><td><a id="l343"></a><a href="#l343">343</a><td>    }<tr><td><a id="l344"></a><a href="#l344">344</a><td>    cur = line;<tr><td><a id="l345"></a><a href="#l345">345</a><td>    while (merged = collapsedSpanAtEnd(cur)) {<tr><td><a id="l346"></a><a href="#l346">346</a><td>      var found = merged.find(0, true);<tr><td><a id="l347"></a><a href="#l347">347</a><td>      len -= cur.text.length - found.from.ch;<tr><td><a id="l348"></a><a href="#l348">348</a><td>      cur = found.to.line;<tr><td><a id="l349"></a><a href="#l349">349</a><td>      len += cur.text.length - found.to.ch;<tr><td><a id="l350"></a><a href="#l350">350</a><td>    }<tr><td><a id="l351"></a><a href="#l351">351</a><td>    return len;<tr><td><a id="l352"></a><a href="#l352">352</a><td>  }<tr><td><a id="l353"></a><a href="#l353">353</a><td><tr><td><a id="l354"></a><a href="#l354">354</a><td>  // Find the longest line in the document.<tr><td><a id="l355"></a><a href="#l355">355</a><td>  function findMaxLine(cm) {<tr><td><a id="l356"></a><a href="#l356">356</a><td>    var d = cm.display, doc = cm.doc;<tr><td><a id="l357"></a><a href="#l357">357</a><td>    d.maxLine = getLine(doc, doc.first);<tr><td><a id="l358"></a><a href="#l358">358</a><td>    d.maxLineLength = lineLength(d.maxLine);<tr><td><a id="l359"></a><a href="#l359">359</a><td>    d.maxLineChanged = true;<tr><td><a id="l360"></a><a href="#l360">360</a><td>    doc.iter(function(line) {<tr><td><a id="l361"></a><a href="#l361">361</a><td>      var len = lineLength(line);<tr><td><a id="l362"></a><a href="#l362">362</a><td>      if (len &gt; d.maxLineLength) {<tr><td><a id="l363"></a><a href="#l363">363</a><td>        d.maxLineLength = len;<tr><td><a id="l364"></a><a href="#l364">364</a><td>        d.maxLine = line;<tr><td><a id="l365"></a><a href="#l365">365</a><td>      }<tr><td><a id="l366"></a><a href="#l366">366</a><td>    });<tr><td><a id="l367"></a><a href="#l367">367</a><td>  }<tr><td><a id="l368"></a><a href="#l368">368</a><td><tr><td><a id="l369"></a><a href="#l369">369</a><td>  // Make sure the gutters options contains the element<tr><td><a id="l370"></a><a href="#l370">370</a><td>  // &quot;CodeMirror-linenumbers&quot; when the lineNumbers option is true.<tr><td><a id="l371"></a><a href="#l371">371</a><td>  function setGuttersForLineNumbers(options) {<tr><td><a id="l372"></a><a href="#l372">372</a><td>    var found = indexOf(options.gutters, &quot;CodeMirror-linenumbers&quot;);<tr><td><a id="l373"></a><a href="#l373">373</a><td>    if (found == -1 &amp;&amp; options.lineNumbers) {<tr><td><a id="l374"></a><a href="#l374">374</a><td>      options.gutters = options.gutters.concat([&quot;CodeMirror-linenumbers&quot;]);<tr><td><a id="l375"></a><a href="#l375">375</a><td>    } else if (found &gt; -1 &amp;&amp; !options.lineNumbers) {<tr><td><a id="l376"></a><a href="#l376">376</a><td>      options.gutters = options.gutters.slice(0);<tr><td><a id="l377"></a><a href="#l377">377</a><td>      options.gutters.splice(found, 1);<tr><td><a id="l378"></a><a href="#l378">378</a><td>    }<tr><td><a id="l379"></a><a href="#l379">379</a><td>  }<tr><td><a id="l380"></a><a href="#l380">380</a><td><tr><td><a id="l381"></a><a href="#l381">381</a><td>  // SCROLLBARS<tr><td><a id="l382"></a><a href="#l382">382</a><td><tr><td><a id="l383"></a><a href="#l383">383</a><td>  // Prepare DOM reads needed to update the scrollbars. Done in one<tr><td><a id="l384"></a><a href="#l384">384</a><td>  // shot to minimize update/measure roundtrips.<tr><td><a id="l385"></a><a href="#l385">385</a><td>  function measureForScrollbars(cm) {<tr><td><a id="l386"></a><a href="#l386">386</a><td>    var d = cm.display, gutterW = d.gutters.offsetWidth;<tr><td><a id="l387"></a><a href="#l387">387</a><td>    var docH = Math.round(cm.doc.height + paddingVert(cm.display));<tr><td><a id="l388"></a><a href="#l388">388</a><td>    return {<tr><td><a id="l389"></a><a href="#l389">389</a><td>      clientHeight: d.scroller.clientHeight,<tr><td><a id="l390"></a><a href="#l390">390</a><td>      viewHeight: d.wrapper.clientHeight,<tr><td><a id="l391"></a><a href="#l391">391</a><td>      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,<tr><td><a id="l392"></a><a href="#l392">392</a><td>      viewWidth: d.wrapper.clientWidth,<tr><td><a id="l393"></a><a href="#l393">393</a><td>      barLeft: cm.options.fixedGutter ? gutterW : 0,<tr><td><a id="l394"></a><a href="#l394">394</a><td>      docHeight: docH,<tr><td><a id="l395"></a><a href="#l395">395</a><td>      scrollHeight: docH + scrollGap(cm) + d.barHeight,<tr><td><a id="l396"></a><a href="#l396">396</a><td>      nativeBarWidth: d.nativeBarWidth,<tr><td><a id="l397"></a><a href="#l397">397</a><td>      gutterWidth: gutterW<tr><td><a id="l398"></a><a href="#l398">398</a><td>    };<tr><td><a id="l399"></a><a href="#l399">399</a><td>  }<tr><td><a id="l400"></a><a href="#l400">400</a><td><tr><td><a id="l401"></a><a href="#l401">401</a><td>  function NativeScrollbars(place, scroll, cm) {<tr><td><a id="l402"></a><a href="#l402">402</a><td>    this.cm = cm;<tr><td><a id="l403"></a><a href="#l403">403</a><td>    var vert = this.vert = elt(&quot;div&quot;, [elt(&quot;div&quot;, null, null, &quot;min-width: 1px&quot;)], &quot;CodeMirror-vscrollbar&quot;);<tr><td><a id="l404"></a><a href="#l404">404</a><td>    var horiz = this.horiz = elt(&quot;div&quot;, [elt(&quot;div&quot;, null, null, &quot;height: 100%; min-height: 1px&quot;)], &quot;CodeMirror-hscrollbar&quot;);<tr><td><a id="l405"></a><a href="#l405">405</a><td>    place(vert); place(horiz);<tr><td><a id="l406"></a><a href="#l406">406</a><td><tr><td><a id="l407"></a><a href="#l407">407</a><td>    on(vert, &quot;scroll&quot;, function() {<tr><td><a id="l408"></a><a href="#l408">408</a><td>      if (vert.clientHeight) scroll(vert.scrollTop, &quot;vertical&quot;);<tr><td><a id="l409"></a><a href="#l409">409</a><td>    });<tr><td><a id="l410"></a><a href="#l410">410</a><td>    on(horiz, &quot;scroll&quot;, function() {<tr><td><a id="l411"></a><a href="#l411">411</a><td>      if (horiz.clientWidth) scroll(horiz.scrollLeft, &quot;horizontal&quot;);<tr><td><a id="l412"></a><a href="#l412">412</a><td>    });<tr><td><a id="l413"></a><a href="#l413">413</a><td><tr><td><a id="l414"></a><a href="#l414">414</a><td>    this.checkedZeroWidth = false;<tr><td><a id="l415"></a><a href="#l415">415</a><td>    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).<tr><td><a id="l416"></a><a href="#l416">416</a><td>    if (ie &amp;&amp; ie_version &lt; 8) this.horiz.style.minHeight = this.vert.style.minWidth = &quot;18px&quot;;<tr><td><a id="l417"></a><a href="#l417">417</a><td>  }<tr><td><a id="l418"></a><a href="#l418">418</a><td><tr><td><a id="l419"></a><a href="#l419">419</a><td>  NativeScrollbars.prototype = copyObj({<tr><td><a id="l420"></a><a href="#l420">420</a><td>    update: function(measure) {<tr><td><a id="l421"></a><a href="#l421">421</a><td>      var needsH = measure.scrollWidth &gt; measure.clientWidth + 1;<tr><td><a id="l422"></a><a href="#l422">422</a><td>      var needsV = measure.scrollHeight &gt; measure.clientHeight + 1;<tr><td><a id="l423"></a><a href="#l423">423</a><td>      var sWidth = measure.nativeBarWidth;<tr><td><a id="l424"></a><a href="#l424">424</a><td><tr><td><a id="l425"></a><a href="#l425">425</a><td>      if (needsV) {<tr><td><a id="l426"></a><a href="#l426">426</a><td>        this.vert.style.display = &quot;block&quot;;<tr><td><a id="l427"></a><a href="#l427">427</a><td>        this.vert.style.bottom = needsH ? sWidth + &quot;px&quot; : &quot;0&quot;;<tr><td><a id="l428"></a><a href="#l428">428</a><td>        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);<tr><td><a id="l429"></a><a href="#l429">429</a><td>        // A bug in IE8 can cause this value to be negative, so guard it.<tr><td><a id="l430"></a><a href="#l430">430</a><td>        this.vert.firstChild.style.height =<tr><td><a id="l431"></a><a href="#l431">431</a><td>          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + &quot;px&quot;;<tr><td><a id="l432"></a><a href="#l432">432</a><td>      } else {<tr><td><a id="l433"></a><a href="#l433">433</a><td>        this.vert.style.display = &quot;&quot;;<tr><td><a id="l434"></a><a href="#l434">434</a><td>        this.vert.firstChild.style.height = &quot;0&quot;;<tr><td><a id="l435"></a><a href="#l435">435</a><td>      }<tr><td><a id="l436"></a><a href="#l436">436</a><td><tr><td><a id="l437"></a><a href="#l437">437</a><td>      if (needsH) {<tr><td><a id="l438"></a><a href="#l438">438</a><td>        this.horiz.style.display = &quot;block&quot;;<tr><td><a id="l439"></a><a href="#l439">439</a><td>        this.horiz.style.right = needsV ? sWidth + &quot;px&quot; : &quot;0&quot;;<tr><td><a id="l440"></a><a href="#l440">440</a><td>        this.horiz.style.left = measure.barLeft + &quot;px&quot;;<tr><td><a id="l441"></a><a href="#l441">441</a><td>        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);<tr><td><a id="l442"></a><a href="#l442">442</a><td>        this.horiz.firstChild.style.width =<tr><td><a id="l443"></a><a href="#l443">443</a><td>          (measure.scrollWidth - measure.clientWidth + totalWidth) + &quot;px&quot;;<tr><td><a id="l444"></a><a href="#l444">444</a><td>      } else {<tr><td><a id="l445"></a><a href="#l445">445</a><td>        this.horiz.style.display = &quot;&quot;;<tr><td><a id="l446"></a><a href="#l446">446</a><td>        this.horiz.firstChild.style.width = &quot;0&quot;;<tr><td><a id="l447"></a><a href="#l447">447</a><td>      }<tr><td><a id="l448"></a><a href="#l448">448</a><td><tr><td><a id="l449"></a><a href="#l449">449</a><td>      if (!this.checkedZeroWidth &amp;&amp; measure.clientHeight &gt; 0) {<tr><td><a id="l450"></a><a href="#l450">450</a><td>        if (sWidth == 0) this.zeroWidthHack();<tr><td><a id="l451"></a><a href="#l451">451</a><td>        this.checkedZeroWidth = true;<tr><td><a id="l452"></a><a href="#l452">452</a><td>      }<tr><td><a id="l453"></a><a href="#l453">453</a><td><tr><td><a id="l454"></a><a href="#l454">454</a><td>      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};<tr><td><a id="l455"></a><a href="#l455">455</a><td>    },<tr><td><a id="l456"></a><a href="#l456">456</a><td>    setScrollLeft: function(pos) {<tr><td><a id="l457"></a><a href="#l457">457</a><td>      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;<tr><td><a id="l458"></a><a href="#l458">458</a><td>      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);<tr><td><a id="l459"></a><a href="#l459">459</a><td>    },<tr><td><a id="l460"></a><a href="#l460">460</a><td>    setScrollTop: function(pos) {<tr><td><a id="l461"></a><a href="#l461">461</a><td>      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;<tr><td><a id="l462"></a><a href="#l462">462</a><td>      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);<tr><td><a id="l463"></a><a href="#l463">463</a><td>    },<tr><td><a id="l464"></a><a href="#l464">464</a><td>    zeroWidthHack: function() {<tr><td><a id="l465"></a><a href="#l465">465</a><td>      var w = mac &amp;&amp; !mac_geMountainLion ? &quot;12px&quot; : &quot;18px&quot;;<tr><td><a id="l466"></a><a href="#l466">466</a><td>      this.horiz.style.height = this.vert.style.width = w;<tr><td><a id="l467"></a><a href="#l467">467</a><td>      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = &quot;none&quot;;<tr><td><a id="l468"></a><a href="#l468">468</a><td>      this.disableHoriz = new Delayed;<tr><td><a id="l469"></a><a href="#l469">469</a><td>      this.disableVert = new Delayed;<tr><td><a id="l470"></a><a href="#l470">470</a><td>    },<tr><td><a id="l471"></a><a href="#l471">471</a><td>    enableZeroWidthBar: function(bar, delay) {<tr><td><a id="l472"></a><a href="#l472">472</a><td>      bar.style.pointerEvents = &quot;auto&quot;;<tr><td><a id="l473"></a><a href="#l473">473</a><td>      function maybeDisable() {<tr><td><a id="l474"></a><a href="#l474">474</a><td>        // To find out whether the scrollbar is still visible, we<tr><td><a id="l475"></a><a href="#l475">475</a><td>        // check whether the element under the pixel in the bottom<tr><td><a id="l476"></a><a href="#l476">476</a><td>        // left corner of the scrollbar box is the scrollbar box<tr><td><a id="l477"></a><a href="#l477">477</a><td>        // itself (when the bar is still visible) or its filler child<tr><td><a id="l478"></a><a href="#l478">478</a><td>        // (when the bar is hidden). If it is still visible, we keep<tr><td><a id="l479"></a><a href="#l479">479</a><td>        // it enabled, if it&#39;s hidden, we disable pointer events.<tr><td><a id="l480"></a><a href="#l480">480</a><td>        var box = bar.getBoundingClientRect();<tr><td><a id="l481"></a><a href="#l481">481</a><td>        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);<tr><td><a id="l482"></a><a href="#l482">482</a><td>        if (elt != bar) bar.style.pointerEvents = &quot;none&quot;;<tr><td><a id="l483"></a><a href="#l483">483</a><td>        else delay.set(1000, maybeDisable);<tr><td><a id="l484"></a><a href="#l484">484</a><td>      }<tr><td><a id="l485"></a><a href="#l485">485</a><td>      delay.set(1000, maybeDisable);<tr><td><a id="l486"></a><a href="#l486">486</a><td>    },<tr><td><a id="l487"></a><a href="#l487">487</a><td>    clear: function() {<tr><td><a id="l488"></a><a href="#l488">488</a><td>      var parent = this.horiz.parentNode;<tr><td><a id="l489"></a><a href="#l489">489</a><td>      parent.removeChild(this.horiz);<tr><td><a id="l490"></a><a href="#l490">490</a><td>      parent.removeChild(this.vert);<tr><td><a id="l491"></a><a href="#l491">491</a><td>    }<tr><td><a id="l492"></a><a href="#l492">492</a><td>  }, NativeScrollbars.prototype);<tr><td><a id="l493"></a><a href="#l493">493</a><td><tr><td><a id="l494"></a><a href="#l494">494</a><td>  function NullScrollbars() {}<tr><td><a id="l495"></a><a href="#l495">495</a><td><tr><td><a id="l496"></a><a href="#l496">496</a><td>  NullScrollbars.prototype = copyObj({<tr><td><a id="l497"></a><a href="#l497">497</a><td>    update: function() { return {bottom: 0, right: 0}; },<tr><td><a id="l498"></a><a href="#l498">498</a><td>    setScrollLeft: function() {},<tr><td><a id="l499"></a><a href="#l499">499</a><td>    setScrollTop: function() {},<tr><td><a id="l500"></a><a href="#l500">500</a><td>    clear: function() {}<tr><td><a id="l501"></a><a href="#l501">501</a><td>  }, NullScrollbars.prototype);<tr><td><a id="l502"></a><a href="#l502">502</a><td><tr><td><a id="l503"></a><a href="#l503">503</a><td>  CodeMirror.scrollbarModel = {&quot;native&quot;: NativeScrollbars, &quot;null&quot;: NullScrollbars};<tr><td><a id="l504"></a><a href="#l504">504</a><td><tr><td><a id="l505"></a><a href="#l505">505</a><td>  function initScrollbars(cm) {<tr><td><a id="l506"></a><a href="#l506">506</a><td>    if (cm.display.scrollbars) {<tr><td><a id="l507"></a><a href="#l507">507</a><td>      cm.display.scrollbars.clear();<tr><td><a id="l508"></a><a href="#l508">508</a><td>      if (cm.display.scrollbars.addClass)<tr><td><a id="l509"></a><a href="#l509">509</a><td>        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);<tr><td><a id="l510"></a><a href="#l510">510</a><td>    }<tr><td><a id="l511"></a><a href="#l511">511</a><td><tr><td><a id="l512"></a><a href="#l512">512</a><td>    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {<tr><td><a id="l513"></a><a href="#l513">513</a><td>      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);<tr><td><a id="l514"></a><a href="#l514">514</a><td>      // Prevent clicks in the scrollbars from killing focus<tr><td><a id="l515"></a><a href="#l515">515</a><td>      on(node, &quot;mousedown&quot;, function() {<tr><td><a id="l516"></a><a href="#l516">516</a><td>        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);<tr><td><a id="l517"></a><a href="#l517">517</a><td>      });<tr><td><a id="l518"></a><a href="#l518">518</a><td>      node.setAttribute(&quot;cm-not-content&quot;, &quot;true&quot;);<tr><td><a id="l519"></a><a href="#l519">519</a><td>    }, function(pos, axis) {<tr><td><a id="l520"></a><a href="#l520">520</a><td>      if (axis == &quot;horizontal&quot;) setScrollLeft(cm, pos);<tr><td><a id="l521"></a><a href="#l521">521</a><td>      else setScrollTop(cm, pos);<tr><td><a id="l522"></a><a href="#l522">522</a><td>    }, cm);<tr><td><a id="l523"></a><a href="#l523">523</a><td>    if (cm.display.scrollbars.addClass)<tr><td><a id="l524"></a><a href="#l524">524</a><td>      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);<tr><td><a id="l525"></a><a href="#l525">525</a><td>  }<tr><td><a id="l526"></a><a href="#l526">526</a><td><tr><td><a id="l527"></a><a href="#l527">527</a><td>  function updateScrollbars(cm, measure) {<tr><td><a id="l528"></a><a href="#l528">528</a><td>    if (!measure) measure = measureForScrollbars(cm);<tr><td><a id="l529"></a><a href="#l529">529</a><td>    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;<tr><td><a id="l530"></a><a href="#l530">530</a><td>    updateScrollbarsInner(cm, measure);<tr><td><a id="l531"></a><a href="#l531">531</a><td>    for (var i = 0; i &lt; 4 &amp;&amp; startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {<tr><td><a id="l532"></a><a href="#l532">532</a><td>      if (startWidth != cm.display.barWidth &amp;&amp; cm.options.lineWrapping)<tr><td><a id="l533"></a><a href="#l533">533</a><td>        updateHeightsInViewport(cm);<tr><td><a id="l534"></a><a href="#l534">534</a><td>      updateScrollbarsInner(cm, measureForScrollbars(cm));<tr><td><a id="l535"></a><a href="#l535">535</a><td>      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;<tr><td><a id="l536"></a><a href="#l536">536</a><td>    }<tr><td><a id="l537"></a><a href="#l537">537</a><td>  }<tr><td><a id="l538"></a><a href="#l538">538</a><td><tr><td><a id="l539"></a><a href="#l539">539</a><td>  // Re-synchronize the fake scrollbars with the actual size of the<tr><td><a id="l540"></a><a href="#l540">540</a><td>  // content.<tr><td><a id="l541"></a><a href="#l541">541</a><td>  function updateScrollbarsInner(cm, measure) {<tr><td><a id="l542"></a><a href="#l542">542</a><td>    var d = cm.display;<tr><td><a id="l543"></a><a href="#l543">543</a><td>    var sizes = d.scrollbars.update(measure);<tr><td><a id="l544"></a><a href="#l544">544</a><td><tr><td><a id="l545"></a><a href="#l545">545</a><td>    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + &quot;px&quot;;<tr><td><a id="l546"></a><a href="#l546">546</a><td>    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + &quot;px&quot;;<tr><td><a id="l547"></a><a href="#l547">547</a><td>    d.heightForcer.style.borderBottom = sizes.bottom + &quot;px solid transparent&quot;<tr><td><a id="l548"></a><a href="#l548">548</a><td><tr><td><a id="l549"></a><a href="#l549">549</a><td>    if (sizes.right &amp;&amp; sizes.bottom) {<tr><td><a id="l550"></a><a href="#l550">550</a><td>      d.scrollbarFiller.style.display = &quot;block&quot;;<tr><td><a id="l551"></a><a href="#l551">551</a><td>      d.scrollbarFiller.style.height = sizes.bottom + &quot;px&quot;;<tr><td><a id="l552"></a><a href="#l552">552</a><td>      d.scrollbarFiller.style.width = sizes.right + &quot;px&quot;;<tr><td><a id="l553"></a><a href="#l553">553</a><td>    } else d.scrollbarFiller.style.display = &quot;&quot;;<tr><td><a id="l554"></a><a href="#l554">554</a><td>    if (sizes.bottom &amp;&amp; cm.options.coverGutterNextToScrollbar &amp;&amp; cm.options.fixedGutter) {<tr><td><a id="l555"></a><a href="#l555">555</a><td>      d.gutterFiller.style.display = &quot;block&quot;;<tr><td><a id="l556"></a><a href="#l556">556</a><td>      d.gutterFiller.style.height = sizes.bottom + &quot;px&quot;;<tr><td><a id="l557"></a><a href="#l557">557</a><td>      d.gutterFiller.style.width = measure.gutterWidth + &quot;px&quot;;<tr><td><a id="l558"></a><a href="#l558">558</a><td>    } else d.gutterFiller.style.display = &quot;&quot;;<tr><td><a id="l559"></a><a href="#l559">559</a><td>  }<tr><td><a id="l560"></a><a href="#l560">560</a><td><tr><td><a id="l561"></a><a href="#l561">561</a><td>  // Compute the lines that are visible in a given viewport (defaults<tr><td><a id="l562"></a><a href="#l562">562</a><td>  // the the current scroll position). viewport may contain top,<tr><td><a id="l563"></a><a href="#l563">563</a><td>  // height, and ensure (see op.scrollToPos) properties.<tr><td><a id="l564"></a><a href="#l564">564</a><td>  function visibleLines(display, doc, viewport) {<tr><td><a id="l565"></a><a href="#l565">565</a><td>    var top = viewport &amp;&amp; viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;<tr><td><a id="l566"></a><a href="#l566">566</a><td>    top = Math.floor(top - paddingTop(display));<tr><td><a id="l567"></a><a href="#l567">567</a><td>    var bottom = viewport &amp;&amp; viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;<tr><td><a id="l568"></a><a href="#l568">568</a><td><tr><td><a id="l569"></a><a href="#l569">569</a><td>    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);<tr><td><a id="l570"></a><a href="#l570">570</a><td>    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and<tr><td><a id="l571"></a><a href="#l571">571</a><td>    // forces those lines into the viewport (if possible).<tr><td><a id="l572"></a><a href="#l572">572</a><td>    if (viewport &amp;&amp; viewport.ensure) {<tr><td><a id="l573"></a><a href="#l573">573</a><td>      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;<tr><td><a id="l574"></a><a href="#l574">574</a><td>      if (ensureFrom &lt; from) {<tr><td><a id="l575"></a><a href="#l575">575</a><td>        from = ensureFrom;<tr><td><a id="l576"></a><a href="#l576">576</a><td>        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);<tr><td><a id="l577"></a><a href="#l577">577</a><td>      } else if (Math.min(ensureTo, doc.lastLine()) &gt;= to) {<tr><td><a id="l578"></a><a href="#l578">578</a><td>        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);<tr><td><a id="l579"></a><a href="#l579">579</a><td>        to = ensureTo;<tr><td><a id="l580"></a><a href="#l580">580</a><td>      }<tr><td><a id="l581"></a><a href="#l581">581</a><td>    }<tr><td><a id="l582"></a><a href="#l582">582</a><td>    return {from: from, to: Math.max(to, from + 1)};<tr><td><a id="l583"></a><a href="#l583">583</a><td>  }<tr><td><a id="l584"></a><a href="#l584">584</a><td><tr><td><a id="l585"></a><a href="#l585">585</a><td>  // LINE NUMBERS<tr><td><a id="l586"></a><a href="#l586">586</a><td><tr><td><a id="l587"></a><a href="#l587">587</a><td>  // Re-align line numbers and gutter marks to compensate for<tr><td><a id="l588"></a><a href="#l588">588</a><td>  // horizontal scrolling.<tr><td><a id="l589"></a><a href="#l589">589</a><td>  function alignHorizontally(cm) {<tr><td><a id="l590"></a><a href="#l590">590</a><td>    var display = cm.display, view = display.view;<tr><td><a id="l591"></a><a href="#l591">591</a><td>    if (!display.alignWidgets &amp;&amp; (!display.gutters.firstChild || !cm.options.fixedGutter)) return;<tr><td><a id="l592"></a><a href="#l592">592</a><td>    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;<tr><td><a id="l593"></a><a href="#l593">593</a><td>    var gutterW = display.gutters.offsetWidth, left = comp + &quot;px&quot;;<tr><td><a id="l594"></a><a href="#l594">594</a><td>    for (var i = 0; i &lt; view.length; i++) if (!view[i].hidden) {<tr><td><a id="l595"></a><a href="#l595">595</a><td>      if (cm.options.fixedGutter) {<tr><td><a id="l596"></a><a href="#l596">596</a><td>        if (view[i].gutter)<tr><td><a id="l597"></a><a href="#l597">597</a><td>          view[i].gutter.style.left = left;<tr><td><a id="l598"></a><a href="#l598">598</a><td>        if (view[i].gutterBackground)<tr><td><a id="l599"></a><a href="#l599">599</a><td>          view[i].gutterBackground.style.left = left;<tr><td><a id="l600"></a><a href="#l600">600</a><td>      }<tr><td><a id="l601"></a><a href="#l601">601</a><td>      var align = view[i].alignable;<tr><td><a id="l602"></a><a href="#l602">602</a><td>      if (align) for (var j = 0; j &lt; align.length; j++)<tr><td><a id="l603"></a><a href="#l603">603</a><td>        align[j].style.left = left;<tr><td><a id="l604"></a><a href="#l604">604</a><td>    }<tr><td><a id="l605"></a><a href="#l605">605</a><td>    if (cm.options.fixedGutter)<tr><td><a id="l606"></a><a href="#l606">606</a><td>      display.gutters.style.left = (comp + gutterW) + &quot;px&quot;;<tr><td><a id="l607"></a><a href="#l607">607</a><td>  }<tr><td><a id="l608"></a><a href="#l608">608</a><td><tr><td><a id="l609"></a><a href="#l609">609</a><td>  // Used to ensure that the line number gutter is still the right<tr><td><a id="l610"></a><a href="#l610">610</a><td>  // size for the current document size. Returns true when an update<tr><td><a id="l611"></a><a href="#l611">611</a><td>  // is needed.<tr><td><a id="l612"></a><a href="#l612">612</a><td>  function maybeUpdateLineNumberWidth(cm) {<tr><td><a id="l613"></a><a href="#l613">613</a><td>    if (!cm.options.lineNumbers) return false;<tr><td><a id="l614"></a><a href="#l614">614</a><td>    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;<tr><td><a id="l615"></a><a href="#l615">615</a><td>    if (last.length != display.lineNumChars) {<tr><td><a id="l616"></a><a href="#l616">616</a><td>      var test = display.measure.appendChild(elt(&quot;div&quot;, [elt(&quot;div&quot;, last)],<tr><td><a id="l617"></a><a href="#l617">617</a><td>                                                 &quot;CodeMirror-linenumber CodeMirror-gutter-elt&quot;));<tr><td><a id="l618"></a><a href="#l618">618</a><td>      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;<tr><td><a id="l619"></a><a href="#l619">619</a><td>      display.lineGutter.style.width = &quot;&quot;;<tr><td><a id="l620"></a><a href="#l620">620</a><td>      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;<tr><td><a id="l621"></a><a href="#l621">621</a><td>      display.lineNumWidth = display.lineNumInnerWidth + padding;<tr><td><a id="l622"></a><a href="#l622">622</a><td>      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;<tr><td><a id="l623"></a><a href="#l623">623</a><td>      display.lineGutter.style.width = display.lineNumWidth + &quot;px&quot;;<tr><td><a id="l624"></a><a href="#l624">624</a><td>      updateGutterSpace(cm);<tr><td><a id="l625"></a><a href="#l625">625</a><td>      return true;<tr><td><a id="l626"></a><a href="#l626">626</a><td>    }<tr><td><a id="l627"></a><a href="#l627">627</a><td>    return false;<tr><td><a id="l628"></a><a href="#l628">628</a><td>  }<tr><td><a id="l629"></a><a href="#l629">629</a><td><tr><td><a id="l630"></a><a href="#l630">630</a><td>  function lineNumberFor(options, i) {<tr><td><a id="l631"></a><a href="#l631">631</a><td>    return String(options.lineNumberFormatter(i + options.firstLineNumber));<tr><td><a id="l632"></a><a href="#l632">632</a><td>  }<tr><td><a id="l633"></a><a href="#l633">633</a><td><tr><td><a id="l634"></a><a href="#l634">634</a><td>  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,<tr><td><a id="l635"></a><a href="#l635">635</a><td>  // but using getBoundingClientRect to get a sub-pixel-accurate<tr><td><a id="l636"></a><a href="#l636">636</a><td>  // result.<tr><td><a id="l637"></a><a href="#l637">637</a><td>  function compensateForHScroll(display) {<tr><td><a id="l638"></a><a href="#l638">638</a><td>    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;<tr><td><a id="l639"></a><a href="#l639">639</a><td>  }<tr><td><a id="l640"></a><a href="#l640">640</a><td><tr><td><a id="l641"></a><a href="#l641">641</a><td>  // DISPLAY DRAWING<tr><td><a id="l642"></a><a href="#l642">642</a><td><tr><td><a id="l643"></a><a href="#l643">643</a><td>  function DisplayUpdate(cm, viewport, force) {<tr><td><a id="l644"></a><a href="#l644">644</a><td>    var display = cm.display;<tr><td><a id="l645"></a><a href="#l645">645</a><td><tr><td><a id="l646"></a><a href="#l646">646</a><td>    this.viewport = viewport;<tr><td><a id="l647"></a><a href="#l647">647</a><td>    // Store some values that we&#39;ll need later (but don&#39;t want to force a relayout for)<tr><td><a id="l648"></a><a href="#l648">648</a><td>    this.visible = visibleLines(display, cm.doc, viewport);<tr><td><a id="l649"></a><a href="#l649">649</a><td>    this.editorIsHidden = !display.wrapper.offsetWidth;<tr><td><a id="l650"></a><a href="#l650">650</a><td>    this.wrapperHeight = display.wrapper.clientHeight;<tr><td><a id="l651"></a><a href="#l651">651</a><td>    this.wrapperWidth = display.wrapper.clientWidth;<tr><td><a id="l652"></a><a href="#l652">652</a><td>    this.oldDisplayWidth = displayWidth(cm);<tr><td><a id="l653"></a><a href="#l653">653</a><td>    this.force = force;<tr><td><a id="l654"></a><a href="#l654">654</a><td>    this.dims = getDimensions(cm);<tr><td><a id="l655"></a><a href="#l655">655</a><td>    this.events = [];<tr><td><a id="l656"></a><a href="#l656">656</a><td>  }<tr><td><a id="l657"></a><a href="#l657">657</a><td><tr><td><a id="l658"></a><a href="#l658">658</a><td>  DisplayUpdate.prototype.signal = function(emitter, type) {<tr><td><a id="l659"></a><a href="#l659">659</a><td>    if (hasHandler(emitter, type))<tr><td><a id="l660"></a><a href="#l660">660</a><td>      this.events.push(arguments);<tr><td><a id="l661"></a><a href="#l661">661</a><td>  };<tr><td><a id="l662"></a><a href="#l662">662</a><td>  DisplayUpdate.prototype.finish = function() {<tr><td><a id="l663"></a><a href="#l663">663</a><td>    for (var i = 0; i &lt; this.events.length; i++)<tr><td><a id="l664"></a><a href="#l664">664</a><td>      signal.apply(null, this.events[i]);<tr><td><a id="l665"></a><a href="#l665">665</a><td>  };<tr><td><a id="l666"></a><a href="#l666">666</a><td><tr><td><a id="l667"></a><a href="#l667">667</a><td>  function maybeClipScrollbars(cm) {<tr><td><a id="l668"></a><a href="#l668">668</a><td>    var display = cm.display;<tr><td><a id="l669"></a><a href="#l669">669</a><td>    if (!display.scrollbarsClipped &amp;&amp; display.scroller.offsetWidth) {<tr><td><a id="l670"></a><a href="#l670">670</a><td>      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;<tr><td><a id="l671"></a><a href="#l671">671</a><td>      display.heightForcer.style.height = scrollGap(cm) + &quot;px&quot;;<tr><td><a id="l672"></a><a href="#l672">672</a><td>      display.sizer.style.marginBottom = -display.nativeBarWidth + &quot;px&quot;;<tr><td><a id="l673"></a><a href="#l673">673</a><td>      display.sizer.style.borderRightWidth = scrollGap(cm) + &quot;px&quot;;<tr><td><a id="l674"></a><a href="#l674">674</a><td>      display.scrollbarsClipped = true;<tr><td><a id="l675"></a><a href="#l675">675</a><td>    }<tr><td><a id="l676"></a><a href="#l676">676</a><td>  }<tr><td><a id="l677"></a><a href="#l677">677</a><td><tr><td><a id="l678"></a><a href="#l678">678</a><td>  // Does the actual updating of the line display. Bails out<tr><td><a id="l679"></a><a href="#l679">679</a><td>  // (returning false) when there is nothing to be done and forced is<tr><td><a id="l680"></a><a href="#l680">680</a><td>  // false.<tr><td><a id="l681"></a><a href="#l681">681</a><td>  function updateDisplayIfNeeded(cm, update) {<tr><td><a id="l682"></a><a href="#l682">682</a><td>    var display = cm.display, doc = cm.doc;<tr><td><a id="l683"></a><a href="#l683">683</a><td><tr><td><a id="l684"></a><a href="#l684">684</a><td>    if (update.editorIsHidden) {<tr><td><a id="l685"></a><a href="#l685">685</a><td>      resetView(cm);<tr><td><a id="l686"></a><a href="#l686">686</a><td>      return false;<tr><td><a id="l687"></a><a href="#l687">687</a><td>    }<tr><td><a id="l688"></a><a href="#l688">688</a><td><tr><td><a id="l689"></a><a href="#l689">689</a><td>    // Bail out if the visible area is already rendered and nothing changed.<tr><td><a id="l690"></a><a href="#l690">690</a><td>    if (!update.force &amp;&amp;<tr><td><a id="l691"></a><a href="#l691">691</a><td>        update.visible.from &gt;= display.viewFrom &amp;&amp; update.visible.to &lt;= display.viewTo &amp;&amp;<tr><td><a id="l692"></a><a href="#l692">692</a><td>        (display.updateLineNumbers == null || display.updateLineNumbers &gt;= display.viewTo) &amp;&amp;<tr><td><a id="l693"></a><a href="#l693">693</a><td>        display.renderedView == display.view &amp;&amp; countDirtyView(cm) == 0)<tr><td><a id="l694"></a><a href="#l694">694</a><td>      return false;<tr><td><a id="l695"></a><a href="#l695">695</a><td><tr><td><a id="l696"></a><a href="#l696">696</a><td>    if (maybeUpdateLineNumberWidth(cm)) {<tr><td><a id="l697"></a><a href="#l697">697</a><td>      resetView(cm);<tr><td><a id="l698"></a><a href="#l698">698</a><td>      update.dims = getDimensions(cm);<tr><td><a id="l699"></a><a href="#l699">699</a><td>    }<tr><td><a id="l700"></a><a href="#l700">700</a><td><tr><td><a id="l701"></a><a href="#l701">701</a><td>    // Compute a suitable new viewport (from &amp; to)<tr><td><a id="l702"></a><a href="#l702">702</a><td>    var end = doc.first + doc.size;<tr><td><a id="l703"></a><a href="#l703">703</a><td>    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);<tr><td><a id="l704"></a><a href="#l704">704</a><td>    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);<tr><td><a id="l705"></a><a href="#l705">705</a><td>    if (display.viewFrom &lt; from &amp;&amp; from - display.viewFrom &lt; 20) from = Math.max(doc.first, display.viewFrom);<tr><td><a id="l706"></a><a href="#l706">706</a><td>    if (display.viewTo &gt; to &amp;&amp; display.viewTo - to &lt; 20) to = Math.min(end, display.viewTo);<tr><td><a id="l707"></a><a href="#l707">707</a><td>    if (sawCollapsedSpans) {<tr><td><a id="l708"></a><a href="#l708">708</a><td>      from = visualLineNo(cm.doc, from);<tr><td><a id="l709"></a><a href="#l709">709</a><td>      to = visualLineEndNo(cm.doc, to);<tr><td><a id="l710"></a><a href="#l710">710</a><td>    }<tr><td><a id="l711"></a><a href="#l711">711</a><td><tr><td><a id="l712"></a><a href="#l712">712</a><td>    var different = from != display.viewFrom || to != display.viewTo ||<tr><td><a id="l713"></a><a href="#l713">713</a><td>      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;<tr><td><a id="l714"></a><a href="#l714">714</a><td>    adjustView(cm, from, to);<tr><td><a id="l715"></a><a href="#l715">715</a><td><tr><td><a id="l716"></a><a href="#l716">716</a><td>    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));<tr><td><a id="l717"></a><a href="#l717">717</a><td>    // Position the mover div to align with the current scroll position<tr><td><a id="l718"></a><a href="#l718">718</a><td>    cm.display.mover.style.top = display.viewOffset + &quot;px&quot;;<tr><td><a id="l719"></a><a href="#l719">719</a><td><tr><td><a id="l720"></a><a href="#l720">720</a><td>    var toUpdate = countDirtyView(cm);<tr><td><a id="l721"></a><a href="#l721">721</a><td>    if (!different &amp;&amp; toUpdate == 0 &amp;&amp; !update.force &amp;&amp; display.renderedView == display.view &amp;&amp;<tr><td><a id="l722"></a><a href="#l722">722</a><td>        (display.updateLineNumbers == null || display.updateLineNumbers &gt;= display.viewTo))<tr><td><a id="l723"></a><a href="#l723">723</a><td>      return false;<tr><td><a id="l724"></a><a href="#l724">724</a><td><tr><td><a id="l725"></a><a href="#l725">725</a><td>    // For big changes, we hide the enclosing element during the<tr><td><a id="l726"></a><a href="#l726">726</a><td>    // update, since that speeds up the operations on most browsers.<tr><td><a id="l727"></a><a href="#l727">727</a><td>    var focused = activeElt();<tr><td><a id="l728"></a><a href="#l728">728</a><td>    if (toUpdate &gt; 4) display.lineDiv.style.display = &quot;none&quot;;<tr><td><a id="l729"></a><a href="#l729">729</a><td>    patchDisplay(cm, display.updateLineNumbers, update.dims);<tr><td><a id="l730"></a><a href="#l730">730</a><td>    if (toUpdate &gt; 4) display.lineDiv.style.display = &quot;&quot;;<tr><td><a id="l731"></a><a href="#l731">731</a><td>    display.renderedView = display.view;<tr><td><a id="l732"></a><a href="#l732">732</a><td>    // There might have been a widget with a focused element that got<tr><td><a id="l733"></a><a href="#l733">733</a><td>    // hidden or updated, if so re-focus it.<tr><td><a id="l734"></a><a href="#l734">734</a><td>    if (focused &amp;&amp; activeElt() != focused &amp;&amp; focused.offsetHeight) focused.focus();<tr><td><a id="l735"></a><a href="#l735">735</a><td><tr><td><a id="l736"></a><a href="#l736">736</a><td>    // Prevent selection and cursors from interfering with the scroll<tr><td><a id="l737"></a><a href="#l737">737</a><td>    // width and height.<tr><td><a id="l738"></a><a href="#l738">738</a><td>    removeChildren(display.cursorDiv);<tr><td><a id="l739"></a><a href="#l739">739</a><td>    removeChildren(display.selectionDiv);<tr><td><a id="l740"></a><a href="#l740">740</a><td>    display.gutters.style.height = display.sizer.style.minHeight = 0;<tr><td><a id="l741"></a><a href="#l741">741</a><td><tr><td><a id="l742"></a><a href="#l742">742</a><td>    if (different) {<tr><td><a id="l743"></a><a href="#l743">743</a><td>      display.lastWrapHeight = update.wrapperHeight;<tr><td><a id="l744"></a><a href="#l744">744</a><td>      display.lastWrapWidth = update.wrapperWidth;<tr><td><a id="l745"></a><a href="#l745">745</a><td>      startWorker(cm, 400);<tr><td><a id="l746"></a><a href="#l746">746</a><td>    }<tr><td><a id="l747"></a><a href="#l747">747</a><td><tr><td><a id="l748"></a><a href="#l748">748</a><td>    display.updateLineNumbers = null;<tr><td><a id="l749"></a><a href="#l749">749</a><td><tr><td><a id="l750"></a><a href="#l750">750</a><td>    return true;<tr><td><a id="l751"></a><a href="#l751">751</a><td>  }<tr><td><a id="l752"></a><a href="#l752">752</a><td><tr><td><a id="l753"></a><a href="#l753">753</a><td>  function postUpdateDisplay(cm, update) {<tr><td><a id="l754"></a><a href="#l754">754</a><td>    var viewport = update.viewport;<tr><td><a id="l755"></a><a href="#l755">755</a><td><tr><td><a id="l756"></a><a href="#l756">756</a><td>    for (var first = true;; first = false) {<tr><td><a id="l757"></a><a href="#l757">757</a><td>      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {<tr><td><a id="l758"></a><a href="#l758">758</a><td>        // Clip forced viewport to actual scrollable area.<tr><td><a id="l759"></a><a href="#l759">759</a><td>        if (viewport &amp;&amp; viewport.top != null)<tr><td><a id="l760"></a><a href="#l760">760</a><td>          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};<tr><td><a id="l761"></a><a href="#l761">761</a><td>        // Updated line heights might result in the drawn area not<tr><td><a id="l762"></a><a href="#l762">762</a><td>        // actually covering the viewport. Keep looping until it does.<tr><td><a id="l763"></a><a href="#l763">763</a><td>        update.visible = visibleLines(cm.display, cm.doc, viewport);<tr><td><a id="l764"></a><a href="#l764">764</a><td>        if (update.visible.from &gt;= cm.display.viewFrom &amp;&amp; update.visible.to &lt;= cm.display.viewTo)<tr><td><a id="l765"></a><a href="#l765">765</a><td>          break;<tr><td><a id="l766"></a><a href="#l766">766</a><td>      }<tr><td><a id="l767"></a><a href="#l767">767</a><td>      if (!updateDisplayIfNeeded(cm, update)) break;<tr><td><a id="l768"></a><a href="#l768">768</a><td>      updateHeightsInViewport(cm);<tr><td><a id="l769"></a><a href="#l769">769</a><td>      var barMeasure = measureForScrollbars(cm);<tr><td><a id="l770"></a><a href="#l770">770</a><td>      updateSelection(cm);<tr><td><a id="l771"></a><a href="#l771">771</a><td>      updateScrollbars(cm, barMeasure);<tr><td><a id="l772"></a><a href="#l772">772</a><td>      setDocumentHeight(cm, barMeasure);<tr><td><a id="l773"></a><a href="#l773">773</a><td>    }<tr><td><a id="l774"></a><a href="#l774">774</a><td><tr><td><a id="l775"></a><a href="#l775">775</a><td>    update.signal(cm, &quot;update&quot;, cm);<tr><td><a id="l776"></a><a href="#l776">776</a><td>    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {<tr><td><a id="l777"></a><a href="#l777">777</a><td>      update.signal(cm, &quot;viewportChange&quot;, cm, cm.display.viewFrom, cm.display.viewTo);<tr><td><a id="l778"></a><a href="#l778">778</a><td>      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;<tr><td><a id="l779"></a><a href="#l779">779</a><td>    }<tr><td><a id="l780"></a><a href="#l780">780</a><td>  }<tr><td><a id="l781"></a><a href="#l781">781</a><td><tr><td><a id="l782"></a><a href="#l782">782</a><td>  function updateDisplaySimple(cm, viewport) {<tr><td><a id="l783"></a><a href="#l783">783</a><td>    var update = new DisplayUpdate(cm, viewport);<tr><td><a id="l784"></a><a href="#l784">784</a><td>    if (updateDisplayIfNeeded(cm, update)) {<tr><td><a id="l785"></a><a href="#l785">785</a><td>      updateHeightsInViewport(cm);<tr><td><a id="l786"></a><a href="#l786">786</a><td>      postUpdateDisplay(cm, update);<tr><td><a id="l787"></a><a href="#l787">787</a><td>      var barMeasure = measureForScrollbars(cm);<tr><td><a id="l788"></a><a href="#l788">788</a><td>      updateSelection(cm);<tr><td><a id="l789"></a><a href="#l789">789</a><td>      updateScrollbars(cm, barMeasure);<tr><td><a id="l790"></a><a href="#l790">790</a><td>      setDocumentHeight(cm, barMeasure);<tr><td><a id="l791"></a><a href="#l791">791</a><td>      update.finish();<tr><td><a id="l792"></a><a href="#l792">792</a><td>    }<tr><td><a id="l793"></a><a href="#l793">793</a><td>  }<tr><td><a id="l794"></a><a href="#l794">794</a><td><tr><td><a id="l795"></a><a href="#l795">795</a><td>  function setDocumentHeight(cm, measure) {<tr><td><a id="l796"></a><a href="#l796">796</a><td>    cm.display.sizer.style.minHeight = measure.docHeight + &quot;px&quot;;<tr><td><a id="l797"></a><a href="#l797">797</a><td>    cm.display.heightForcer.style.top = measure.docHeight + &quot;px&quot;;<tr><td><a id="l798"></a><a href="#l798">798</a><td>    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + &quot;px&quot;;<tr><td><a id="l799"></a><a href="#l799">799</a><td>  }<tr><td><a id="l800"></a><a href="#l800">800</a><td><tr><td><a id="l801"></a><a href="#l801">801</a><td>  // Read the actual heights of the rendered lines, and update their<tr><td><a id="l802"></a><a href="#l802">802</a><td>  // stored heights to match.<tr><td><a id="l803"></a><a href="#l803">803</a><td>  function updateHeightsInViewport(cm) {<tr><td><a id="l804"></a><a href="#l804">804</a><td>    var display = cm.display;<tr><td><a id="l805"></a><a href="#l805">805</a><td>    var prevBottom = display.lineDiv.offsetTop;<tr><td><a id="l806"></a><a href="#l806">806</a><td>    for (var i = 0; i &lt; display.view.length; i++) {<tr><td><a id="l807"></a><a href="#l807">807</a><td>      var cur = display.view[i], height;<tr><td><a id="l808"></a><a href="#l808">808</a><td>      if (cur.hidden) continue;<tr><td><a id="l809"></a><a href="#l809">809</a><td>      if (ie &amp;&amp; ie_version &lt; 8) {<tr><td><a id="l810"></a><a href="#l810">810</a><td>        var bot = cur.node.offsetTop + cur.node.offsetHeight;<tr><td><a id="l811"></a><a href="#l811">811</a><td>        height = bot - prevBottom;<tr><td><a id="l812"></a><a href="#l812">812</a><td>        prevBottom = bot;<tr><td><a id="l813"></a><a href="#l813">813</a><td>      } else {<tr><td><a id="l814"></a><a href="#l814">814</a><td>        var box = cur.node.getBoundingClientRect();<tr><td><a id="l815"></a><a href="#l815">815</a><td>        height = box.bottom - box.top;<tr><td><a id="l816"></a><a href="#l816">816</a><td>      }<tr><td><a id="l817"></a><a href="#l817">817</a><td>      var diff = cur.line.height - height;<tr><td><a id="l818"></a><a href="#l818">818</a><td>      if (height &lt; 2) height = textHeight(display);<tr><td><a id="l819"></a><a href="#l819">819</a><td>      if (diff &gt; .001 || diff &lt; -.001) {<tr><td><a id="l820"></a><a href="#l820">820</a><td>        updateLineHeight(cur.line, height);<tr><td><a id="l821"></a><a href="#l821">821</a><td>        updateWidgetHeight(cur.line);<tr><td><a id="l822"></a><a href="#l822">822</a><td>        if (cur.rest) for (var j = 0; j &lt; cur.rest.length; j++)<tr><td><a id="l823"></a><a href="#l823">823</a><td>          updateWidgetHeight(cur.rest[j]);<tr><td><a id="l824"></a><a href="#l824">824</a><td>      }<tr><td><a id="l825"></a><a href="#l825">825</a><td>    }<tr><td><a id="l826"></a><a href="#l826">826</a><td>  }<tr><td><a id="l827"></a><a href="#l827">827</a><td><tr><td><a id="l828"></a><a href="#l828">828</a><td>  // Read and store the height of line widgets associated with the<tr><td><a id="l829"></a><a href="#l829">829</a><td>  // given line.<tr><td><a id="l830"></a><a href="#l830">830</a><td>  function updateWidgetHeight(line) {<tr><td><a id="l831"></a><a href="#l831">831</a><td>    if (line.widgets) for (var i = 0; i &lt; line.widgets.length; ++i)<tr><td><a id="l832"></a><a href="#l832">832</a><td>      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;<tr><td><a id="l833"></a><a href="#l833">833</a><td>  }<tr><td><a id="l834"></a><a href="#l834">834</a><td><tr><td><a id="l835"></a><a href="#l835">835</a><td>  // Do a bulk-read of the DOM positions and sizes needed to draw the<tr><td><a id="l836"></a><a href="#l836">836</a><td>  // view, so that we don&#39;t interleave reading and writing to the DOM.<tr><td><a id="l837"></a><a href="#l837">837</a><td>  function getDimensions(cm) {<tr><td><a id="l838"></a><a href="#l838">838</a><td>    var d = cm.display, left = {}, width = {};<tr><td><a id="l839"></a><a href="#l839">839</a><td>    var gutterLeft = d.gutters.clientLeft;<tr><td><a id="l840"></a><a href="#l840">840</a><td>    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {<tr><td><a id="l841"></a><a href="#l841">841</a><td>      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;<tr><td><a id="l842"></a><a href="#l842">842</a><td>      width[cm.options.gutters[i]] = n.clientWidth;<tr><td><a id="l843"></a><a href="#l843">843</a><td>    }<tr><td><a id="l844"></a><a href="#l844">844</a><td>    return {fixedPos: compensateForHScroll(d),<tr><td><a id="l845"></a><a href="#l845">845</a><td>            gutterTotalWidth: d.gutters.offsetWidth,<tr><td><a id="l846"></a><a href="#l846">846</a><td>            gutterLeft: left,<tr><td><a id="l847"></a><a href="#l847">847</a><td>            gutterWidth: width,<tr><td><a id="l848"></a><a href="#l848">848</a><td>            wrapperWidth: d.wrapper.clientWidth};<tr><td><a id="l849"></a><a href="#l849">849</a><td>  }<tr><td><a id="l850"></a><a href="#l850">850</a><td><tr><td><a id="l851"></a><a href="#l851">851</a><td>  // Sync the actual display DOM structure with display.view, removing<tr><td><a id="l852"></a><a href="#l852">852</a><td>  // nodes for lines that are no longer in view, and creating the ones<tr><td><a id="l853"></a><a href="#l853">853</a><td>  // that are not there yet, and updating the ones that are out of<tr><td><a id="l854"></a><a href="#l854">854</a><td>  // date.<tr><td><a id="l855"></a><a href="#l855">855</a><td>  function patchDisplay(cm, updateNumbersFrom, dims) {<tr><td><a id="l856"></a><a href="#l856">856</a><td>    var display = cm.display, lineNumbers = cm.options.lineNumbers;<tr><td><a id="l857"></a><a href="#l857">857</a><td>    var container = display.lineDiv, cur = container.firstChild;<tr><td><a id="l858"></a><a href="#l858">858</a><td><tr><td><a id="l859"></a><a href="#l859">859</a><td>    function rm(node) {<tr><td><a id="l860"></a><a href="#l860">860</a><td>      var next = node.nextSibling;<tr><td><a id="l861"></a><a href="#l861">861</a><td>      // Works around a throw-scroll bug in OS X Webkit<tr><td><a id="l862"></a><a href="#l862">862</a><td>      if (webkit &amp;&amp; mac &amp;&amp; cm.display.currentWheelTarget == node)<tr><td><a id="l863"></a><a href="#l863">863</a><td>        node.style.display = &quot;none&quot;;<tr><td><a id="l864"></a><a href="#l864">864</a><td>      else<tr><td><a id="l865"></a><a href="#l865">865</a><td>        node.parentNode.removeChild(node);<tr><td><a id="l866"></a><a href="#l866">866</a><td>      return next;<tr><td><a id="l867"></a><a href="#l867">867</a><td>    }<tr><td><a id="l868"></a><a href="#l868">868</a><td><tr><td><a id="l869"></a><a href="#l869">869</a><td>    var view = display.view, lineN = display.viewFrom;<tr><td><a id="l870"></a><a href="#l870">870</a><td>    // Loop over the elements in the view, syncing cur (the DOM nodes<tr><td><a id="l871"></a><a href="#l871">871</a><td>    // in display.lineDiv) with the view as we go.<tr><td><a id="l872"></a><a href="#l872">872</a><td>    for (var i = 0; i &lt; view.length; i++) {<tr><td><a id="l873"></a><a href="#l873">873</a><td>      var lineView = view[i];<tr><td><a id="l874"></a><a href="#l874">874</a><td>      if (lineView.hidden) {<tr><td><a id="l875"></a><a href="#l875">875</a><td>      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet<tr><td><a id="l876"></a><a href="#l876">876</a><td>        var node = buildLineElement(cm, lineView, lineN, dims);<tr><td><a id="l877"></a><a href="#l877">877</a><td>        container.insertBefore(node, cur);<tr><td><a id="l878"></a><a href="#l878">878</a><td>      } else { // Already drawn<tr><td><a id="l879"></a><a href="#l879">879</a><td>        while (cur != lineView.node) cur = rm(cur);<tr><td><a id="l880"></a><a href="#l880">880</a><td>        var updateNumber = lineNumbers &amp;&amp; updateNumbersFrom != null &amp;&amp;<tr><td><a id="l881"></a><a href="#l881">881</a><td>          updateNumbersFrom &lt;= lineN &amp;&amp; lineView.lineNumber;<tr><td><a id="l882"></a><a href="#l882">882</a><td>        if (lineView.changes) {<tr><td><a id="l883"></a><a href="#l883">883</a><td>          if (indexOf(lineView.changes, &quot;gutter&quot;) &gt; -1) updateNumber = false;<tr><td><a id="l884"></a><a href="#l884">884</a><td>          updateLineForChanges(cm, lineView, lineN, dims);<tr><td><a id="l885"></a><a href="#l885">885</a><td>        }<tr><td><a id="l886"></a><a href="#l886">886</a><td>        if (updateNumber) {<tr><td><a id="l887"></a><a href="#l887">887</a><td>          removeChildren(lineView.lineNumber);<tr><td><a id="l888"></a><a href="#l888">888</a><td>          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));<tr><td><a id="l889"></a><a href="#l889">889</a><td>        }<tr><td><a id="l890"></a><a href="#l890">890</a><td>        cur = lineView.node.nextSibling;<tr><td><a id="l891"></a><a href="#l891">891</a><td>      }<tr><td><a id="l892"></a><a href="#l892">892</a><td>      lineN += lineView.size;<tr><td><a id="l893"></a><a href="#l893">893</a><td>    }<tr><td><a id="l894"></a><a href="#l894">894</a><td>    while (cur) cur = rm(cur);<tr><td><a id="l895"></a><a href="#l895">895</a><td>  }<tr><td><a id="l896"></a><a href="#l896">896</a><td><tr><td><a id="l897"></a><a href="#l897">897</a><td>  // When an aspect of a line changes, a string is added to<tr><td><a id="l898"></a><a href="#l898">898</a><td>  // lineView.changes. This updates the relevant part of the line&#39;s<tr><td><a id="l899"></a><a href="#l899">899</a><td>  // DOM structure.<tr><td><a id="l900"></a><a href="#l900">900</a><td>  function updateLineForChanges(cm, lineView, lineN, dims) {<tr><td><a id="l901"></a><a href="#l901">901</a><td>    for (var j = 0; j &lt; lineView.changes.length; j++) {<tr><td><a id="l902"></a><a href="#l902">902</a><td>      var type = lineView.changes[j];<tr><td><a id="l903"></a><a href="#l903">903</a><td>      if (type == &quot;text&quot;) updateLineText(cm, lineView);<tr><td><a id="l904"></a><a href="#l904">904</a><td>      else if (type == &quot;gutter&quot;) updateLineGutter(cm, lineView, lineN, dims);<tr><td><a id="l905"></a><a href="#l905">905</a><td>      else if (type == &quot;class&quot;) updateLineClasses(lineView);<tr><td><a id="l906"></a><a href="#l906">906</a><td>      else if (type == &quot;widget&quot;) updateLineWidgets(cm, lineView, dims);<tr><td><a id="l907"></a><a href="#l907">907</a><td>    }<tr><td><a id="l908"></a><a href="#l908">908</a><td>    lineView.changes = null;<tr><td><a id="l909"></a><a href="#l909">909</a><td>  }<tr><td><a id="l910"></a><a href="#l910">910</a><td><tr><td><a id="l911"></a><a href="#l911">911</a><td>  // Lines with gutter elements, widgets or a background class need to<tr><td><a id="l912"></a><a href="#l912">912</a><td>  // be wrapped, and have the extra elements added to the wrapper div<tr><td><a id="l913"></a><a href="#l913">913</a><td>  function ensureLineWrapped(lineView) {<tr><td><a id="l914"></a><a href="#l914">914</a><td>    if (lineView.node == lineView.text) {<tr><td><a id="l915"></a><a href="#l915">915</a><td>      lineView.node = elt(&quot;div&quot;, null, null, &quot;position: relative&quot;);<tr><td><a id="l916"></a><a href="#l916">916</a><td>      if (lineView.text.parentNode)<tr><td><a id="l917"></a><a href="#l917">917</a><td>        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);<tr><td><a id="l918"></a><a href="#l918">918</a><td>      lineView.node.appendChild(lineView.text);<tr><td><a id="l919"></a><a href="#l919">919</a><td>      if (ie &amp;&amp; ie_version &lt; 8) lineView.node.style.zIndex = 2;<tr><td><a id="l920"></a><a href="#l920">920</a><td>    }<tr><td><a id="l921"></a><a href="#l921">921</a><td>    return lineView.node;<tr><td><a id="l922"></a><a href="#l922">922</a><td>  }<tr><td><a id="l923"></a><a href="#l923">923</a><td><tr><td><a id="l924"></a><a href="#l924">924</a><td>  function updateLineBackground(lineView) {<tr><td><a id="l925"></a><a href="#l925">925</a><td>    var cls = lineView.bgClass ? lineView.bgClass + &quot; &quot; + (lineView.line.bgClass || &quot;&quot;) : lineView.line.bgClass;<tr><td><a id="l926"></a><a href="#l926">926</a><td>    if (cls) cls += &quot; CodeMirror-linebackground&quot;;<tr><td><a id="l927"></a><a href="#l927">927</a><td>    if (lineView.background) {<tr><td><a id="l928"></a><a href="#l928">928</a><td>      if (cls) lineView.background.className = cls;<tr><td><a id="l929"></a><a href="#l929">929</a><td>      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }<tr><td><a id="l930"></a><a href="#l930">930</a><td>    } else if (cls) {<tr><td><a id="l931"></a><a href="#l931">931</a><td>      var wrap = ensureLineWrapped(lineView);<tr><td><a id="l932"></a><a href="#l932">932</a><td>      lineView.background = wrap.insertBefore(elt(&quot;div&quot;, null, cls), wrap.firstChild);<tr><td><a id="l933"></a><a href="#l933">933</a><td>    }<tr><td><a id="l934"></a><a href="#l934">934</a><td>  }<tr><td><a id="l935"></a><a href="#l935">935</a><td><tr><td><a id="l936"></a><a href="#l936">936</a><td>  // Wrapper around buildLineContent which will reuse the structure<tr><td><a id="l937"></a><a href="#l937">937</a><td>  // in display.externalMeasured when possible.<tr><td><a id="l938"></a><a href="#l938">938</a><td>  function getLineContent(cm, lineView) {<tr><td><a id="l939"></a><a href="#l939">939</a><td>    var ext = cm.display.externalMeasured;<tr><td><a id="l940"></a><a href="#l940">940</a><td>    if (ext &amp;&amp; ext.line == lineView.line) {<tr><td><a id="l941"></a><a href="#l941">941</a><td>      cm.display.externalMeasured = null;<tr><td><a id="l942"></a><a href="#l942">942</a><td>      lineView.measure = ext.measure;<tr><td><a id="l943"></a><a href="#l943">943</a><td>      return ext.built;<tr><td><a id="l944"></a><a href="#l944">944</a><td>    }<tr><td><a id="l945"></a><a href="#l945">945</a><td>    return buildLineContent(cm, lineView);<tr><td><a id="l946"></a><a href="#l946">946</a><td>  }<tr><td><a id="l947"></a><a href="#l947">947</a><td><tr><td><a id="l948"></a><a href="#l948">948</a><td>  // Redraw the line&#39;s text. Interacts with the background and text<tr><td><a id="l949"></a><a href="#l949">949</a><td>  // classes because the mode may output tokens that influence these<tr><td><a id="l950"></a><a href="#l950">950</a><td>  // classes.<tr><td><a id="l951"></a><a href="#l951">951</a><td>  function updateLineText(cm, lineView) {<tr><td><a id="l952"></a><a href="#l952">952</a><td>    var cls = lineView.text.className;<tr><td><a id="l953"></a><a href="#l953">953</a><td>    var built = getLineContent(cm, lineView);<tr><td><a id="l954"></a><a href="#l954">954</a><td>    if (lineView.text == lineView.node) lineView.node = built.pre;<tr><td><a id="l955"></a><a href="#l955">955</a><td>    lineView.text.parentNode.replaceChild(built.pre, lineView.text);<tr><td><a id="l956"></a><a href="#l956">956</a><td>    lineView.text = built.pre;<tr><td><a id="l957"></a><a href="#l957">957</a><td>    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {<tr><td><a id="l958"></a><a href="#l958">958</a><td>      lineView.bgClass = built.bgClass;<tr><td><a id="l959"></a><a href="#l959">959</a><td>      lineView.textClass = built.textClass;<tr><td><a id="l960"></a><a href="#l960">960</a><td>      updateLineClasses(lineView);<tr><td><a id="l961"></a><a href="#l961">961</a><td>    } else if (cls) {<tr><td><a id="l962"></a><a href="#l962">962</a><td>      lineView.text.className = cls;<tr><td><a id="l963"></a><a href="#l963">963</a><td>    }<tr><td><a id="l964"></a><a href="#l964">964</a><td>  }<tr><td><a id="l965"></a><a href="#l965">965</a><td><tr><td><a id="l966"></a><a href="#l966">966</a><td>  function updateLineClasses(lineView) {<tr><td><a id="l967"></a><a href="#l967">967</a><td>    updateLineBackground(lineView);<tr><td><a id="l968"></a><a href="#l968">968</a><td>    if (lineView.line.wrapClass)<tr><td><a id="l969"></a><a href="#l969">969</a><td>      ensureLineWrapped(lineView).className = lineView.line.wrapClass;<tr><td><a id="l970"></a><a href="#l970">970</a><td>    else if (lineView.node != lineView.text)<tr><td><a id="l971"></a><a href="#l971">971</a><td>      lineView.node.className = &quot;&quot;;<tr><td><a id="l972"></a><a href="#l972">972</a><td>    var textClass = lineView.textClass ? lineView.textClass + &quot; &quot; + (lineView.line.textClass || &quot;&quot;) : lineView.line.textClass;<tr><td><a id="l973"></a><a href="#l973">973</a><td>    lineView.text.className = textClass || &quot;&quot;;<tr><td><a id="l974"></a><a href="#l974">974</a><td>  }<tr><td><a id="l975"></a><a href="#l975">975</a><td><tr><td><a id="l976"></a><a href="#l976">976</a><td>  function updateLineGutter(cm, lineView, lineN, dims) {<tr><td><a id="l977"></a><a href="#l977">977</a><td>    if (lineView.gutter) {<tr><td><a id="l978"></a><a href="#l978">978</a><td>      lineView.node.removeChild(lineView.gutter);<tr><td><a id="l979"></a><a href="#l979">979</a><td>      lineView.gutter = null;<tr><td><a id="l980"></a><a href="#l980">980</a><td>    }<tr><td><a id="l981"></a><a href="#l981">981</a><td>    if (lineView.gutterBackground) {<tr><td><a id="l982"></a><a href="#l982">982</a><td>      lineView.node.removeChild(lineView.gutterBackground);<tr><td><a id="l983"></a><a href="#l983">983</a><td>      lineView.gutterBackground = null;<tr><td><a id="l984"></a><a href="#l984">984</a><td>    }<tr><td><a id="l985"></a><a href="#l985">985</a><td>    if (lineView.line.gutterClass) {<tr><td><a id="l986"></a><a href="#l986">986</a><td>      var wrap = ensureLineWrapped(lineView);<tr><td><a id="l987"></a><a href="#l987">987</a><td>      lineView.gutterBackground = elt(&quot;div&quot;, null, &quot;CodeMirror-gutter-background &quot; + lineView.line.gutterClass,<tr><td><a id="l988"></a><a href="#l988">988</a><td>                                      &quot;left: &quot; + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +<tr><td><a id="l989"></a><a href="#l989">989</a><td>                                      &quot;px; width: &quot; + dims.gutterTotalWidth + &quot;px&quot;);<tr><td><a id="l990"></a><a href="#l990">990</a><td>      wrap.insertBefore(lineView.gutterBackground, lineView.text);<tr><td><a id="l991"></a><a href="#l991">991</a><td>    }<tr><td><a id="l992"></a><a href="#l992">992</a><td>    var markers = lineView.line.gutterMarkers;<tr><td><a id="l993"></a><a href="#l993">993</a><td>    if (cm.options.lineNumbers || markers) {<tr><td><a id="l994"></a><a href="#l994">994</a><td>      var wrap = ensureLineWrapped(lineView);<tr><td><a id="l995"></a><a href="#l995">995</a><td>      var gutterWrap = lineView.gutter = elt(&quot;div&quot;, null, &quot;CodeMirror-gutter-wrapper&quot;, &quot;left: &quot; +<tr><td><a id="l996"></a><a href="#l996">996</a><td>                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + &quot;px&quot;);<tr><td><a id="l997"></a><a href="#l997">997</a><td>      cm.display.input.setUneditable(gutterWrap);<tr><td><a id="l998"></a><a href="#l998">998</a><td>      wrap.insertBefore(gutterWrap, lineView.text);<tr><td><a id="l999"></a><a href="#l999">999</a><td>      if (lineView.line.gutterClass)<tr><td><a id="l1000"></a><a href="#l1000">1000</a><td>        gutterWrap.className += &quot; &quot; + lineView.line.gutterClass;<tr><td><a id="l1001"></a><a href="#l1001">1001</a><td>      if (cm.options.lineNumbers &amp;&amp; (!markers || !markers[&quot;CodeMirror-linenumbers&quot;]))<tr><td><a id="l1002"></a><a href="#l1002">1002</a><td>        lineView.lineNumber = gutterWrap.appendChild(<tr><td><a id="l1003"></a><a href="#l1003">1003</a><td>          elt(&quot;div&quot;, lineNumberFor(cm.options, lineN),<tr><td><a id="l1004"></a><a href="#l1004">1004</a><td>              &quot;CodeMirror-linenumber CodeMirror-gutter-elt&quot;,<tr><td><a id="l1005"></a><a href="#l1005">1005</a><td>              &quot;left: &quot; + dims.gutterLeft[&quot;CodeMirror-linenumbers&quot;] + &quot;px; width: &quot;<tr><td><a id="l1006"></a><a href="#l1006">1006</a><td>              + cm.display.lineNumInnerWidth + &quot;px&quot;));<tr><td><a id="l1007"></a><a href="#l1007">1007</a><td>      if (markers) for (var k = 0; k &lt; cm.options.gutters.length; ++k) {<tr><td><a id="l1008"></a><a href="#l1008">1008</a><td>        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) &amp;&amp; markers[id];<tr><td><a id="l1009"></a><a href="#l1009">1009</a><td>        if (found)<tr><td><a id="l1010"></a><a href="#l1010">1010</a><td>          gutterWrap.appendChild(elt(&quot;div&quot;, [found], &quot;CodeMirror-gutter-elt&quot;, &quot;left: &quot; +<tr><td><a id="l1011"></a><a href="#l1011">1011</a><td>                                     dims.gutterLeft[id] + &quot;px; width: &quot; + dims.gutterWidth[id] + &quot;px&quot;));<tr><td><a id="l1012"></a><a href="#l1012">1012</a><td>      }<tr><td><a id="l1013"></a><a href="#l1013">1013</a><td>    }<tr><td><a id="l1014"></a><a href="#l1014">1014</a><td>  }<tr><td><a id="l1015"></a><a href="#l1015">1015</a><td><tr><td><a id="l1016"></a><a href="#l1016">1016</a><td>  function updateLineWidgets(cm, lineView, dims) {<tr><td><a id="l1017"></a><a href="#l1017">1017</a><td>    if (lineView.alignable) lineView.alignable = null;<tr><td><a id="l1018"></a><a href="#l1018">1018</a><td>    for (var node = lineView.node.firstChild, next; node; node = next) {<tr><td><a id="l1019"></a><a href="#l1019">1019</a><td>      var next = node.nextSibling;<tr><td><a id="l1020"></a><a href="#l1020">1020</a><td>      if (node.className == &quot;CodeMirror-linewidget&quot;)<tr><td><a id="l1021"></a><a href="#l1021">1021</a><td>        lineView.node.removeChild(node);<tr><td><a id="l1022"></a><a href="#l1022">1022</a><td>    }<tr><td><a id="l1023"></a><a href="#l1023">1023</a><td>    insertLineWidgets(cm, lineView, dims);<tr><td><a id="l1024"></a><a href="#l1024">1024</a><td>  }<tr><td><a id="l1025"></a><a href="#l1025">1025</a><td><tr><td><a id="l1026"></a><a href="#l1026">1026</a><td>  // Build a line&#39;s DOM representation from scratch<tr><td><a id="l1027"></a><a href="#l1027">1027</a><td>  function buildLineElement(cm, lineView, lineN, dims) {<tr><td><a id="l1028"></a><a href="#l1028">1028</a><td>    var built = getLineContent(cm, lineView);<tr><td><a id="l1029"></a><a href="#l1029">1029</a><td>    lineView.text = lineView.node = built.pre;<tr><td><a id="l1030"></a><a href="#l1030">1030</a><td>    if (built.bgClass) lineView.bgClass = built.bgClass;<tr><td><a id="l1031"></a><a href="#l1031">1031</a><td>    if (built.textClass) lineView.textClass = built.textClass;<tr><td><a id="l1032"></a><a href="#l1032">1032</a><td><tr><td><a id="l1033"></a><a href="#l1033">1033</a><td>    updateLineClasses(lineView);<tr><td><a id="l1034"></a><a href="#l1034">1034</a><td>    updateLineGutter(cm, lineView, lineN, dims);<tr><td><a id="l1035"></a><a href="#l1035">1035</a><td>    insertLineWidgets(cm, lineView, dims);<tr><td><a id="l1036"></a><a href="#l1036">1036</a><td>    return lineView.node;<tr><td><a id="l1037"></a><a href="#l1037">1037</a><td>  }<tr><td><a id="l1038"></a><a href="#l1038">1038</a><td><tr><td><a id="l1039"></a><a href="#l1039">1039</a><td>  // A lineView may contain multiple logical lines (when merged by<tr><td><a id="l1040"></a><a href="#l1040">1040</a><td>  // collapsed spans). The widgets for all of them need to be drawn.<tr><td><a id="l1041"></a><a href="#l1041">1041</a><td>  function insertLineWidgets(cm, lineView, dims) {<tr><td><a id="l1042"></a><a href="#l1042">1042</a><td>    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);<tr><td><a id="l1043"></a><a href="#l1043">1043</a><td>    if (lineView.rest) for (var i = 0; i &lt; lineView.rest.length; i++)<tr><td><a id="l1044"></a><a href="#l1044">1044</a><td>      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);<tr><td><a id="l1045"></a><a href="#l1045">1045</a><td>  }<tr><td><a id="l1046"></a><a href="#l1046">1046</a><td><tr><td><a id="l1047"></a><a href="#l1047">1047</a><td>  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {<tr><td><a id="l1048"></a><a href="#l1048">1048</a><td>    if (!line.widgets) return;<tr><td><a id="l1049"></a><a href="#l1049">1049</a><td>    var wrap = ensureLineWrapped(lineView);<tr><td><a id="l1050"></a><a href="#l1050">1050</a><td>    for (var i = 0, ws = line.widgets; i &lt; ws.length; ++i) {<tr><td><a id="l1051"></a><a href="#l1051">1051</a><td>      var widget = ws[i], node = elt(&quot;div&quot;, [widget.node], &quot;CodeMirror-linewidget&quot;);<tr><td><a id="l1052"></a><a href="#l1052">1052</a><td>      if (!widget.handleMouseEvents) node.setAttribute(&quot;cm-ignore-events&quot;, &quot;true&quot;);<tr><td><a id="l1053"></a><a href="#l1053">1053</a><td>      positionLineWidget(widget, node, lineView, dims);<tr><td><a id="l1054"></a><a href="#l1054">1054</a><td>      cm.display.input.setUneditable(node);<tr><td><a id="l1055"></a><a href="#l1055">1055</a><td>      if (allowAbove &amp;&amp; widget.above)<tr><td><a id="l1056"></a><a href="#l1056">1056</a><td>        wrap.insertBefore(node, lineView.gutter || lineView.text);<tr><td><a id="l1057"></a><a href="#l1057">1057</a><td>      else<tr><td><a id="l1058"></a><a href="#l1058">1058</a><td>        wrap.appendChild(node);<tr><td><a id="l1059"></a><a href="#l1059">1059</a><td>      signalLater(widget, &quot;redraw&quot;);<tr><td><a id="l1060"></a><a href="#l1060">1060</a><td>    }<tr><td><a id="l1061"></a><a href="#l1061">1061</a><td>  }<tr><td><a id="l1062"></a><a href="#l1062">1062</a><td><tr><td><a id="l1063"></a><a href="#l1063">1063</a><td>  function positionLineWidget(widget, node, lineView, dims) {<tr><td><a id="l1064"></a><a href="#l1064">1064</a><td>    if (widget.noHScroll) {<tr><td><a id="l1065"></a><a href="#l1065">1065</a><td>      (lineView.alignable || (lineView.alignable = [])).push(node);<tr><td><a id="l1066"></a><a href="#l1066">1066</a><td>      var width = dims.wrapperWidth;<tr><td><a id="l1067"></a><a href="#l1067">1067</a><td>      node.style.left = dims.fixedPos + &quot;px&quot;;<tr><td><a id="l1068"></a><a href="#l1068">1068</a><td>      if (!widget.coverGutter) {<tr><td><a id="l1069"></a><a href="#l1069">1069</a><td>        width -= dims.gutterTotalWidth;<tr><td><a id="l1070"></a><a href="#l1070">1070</a><td>        node.style.paddingLeft = dims.gutterTotalWidth + &quot;px&quot;;<tr><td><a id="l1071"></a><a href="#l1071">1071</a><td>      }<tr><td><a id="l1072"></a><a href="#l1072">1072</a><td>      node.style.width = width + &quot;px&quot;;<tr><td><a id="l1073"></a><a href="#l1073">1073</a><td>    }<tr><td><a id="l1074"></a><a href="#l1074">1074</a><td>    if (widget.coverGutter) {<tr><td><a id="l1075"></a><a href="#l1075">1075</a><td>      node.style.zIndex = 5;<tr><td><a id="l1076"></a><a href="#l1076">1076</a><td>      node.style.position = &quot;relative&quot;;<tr><td><a id="l1077"></a><a href="#l1077">1077</a><td>      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + &quot;px&quot;;<tr><td><a id="l1078"></a><a href="#l1078">1078</a><td>    }<tr><td><a id="l1079"></a><a href="#l1079">1079</a><td>  }<tr><td><a id="l1080"></a><a href="#l1080">1080</a><td><tr><td><a id="l1081"></a><a href="#l1081">1081</a><td>  // POSITION OBJECT<tr><td><a id="l1082"></a><a href="#l1082">1082</a><td><tr><td><a id="l1083"></a><a href="#l1083">1083</a><td>  // A Pos instance represents a position within the text.<tr><td><a id="l1084"></a><a href="#l1084">1084</a><td>  var Pos = CodeMirror.Pos = function(line, ch) {<tr><td><a id="l1085"></a><a href="#l1085">1085</a><td>    if (!(this instanceof Pos)) return new Pos(line, ch);<tr><td><a id="l1086"></a><a href="#l1086">1086</a><td>    this.line = line; this.ch = ch;<tr><td><a id="l1087"></a><a href="#l1087">1087</a><td>  };<tr><td><a id="l1088"></a><a href="#l1088">1088</a><td><tr><td><a id="l1089"></a><a href="#l1089">1089</a><td>  // Compare two positions, return 0 if they are the same, a negative<tr><td><a id="l1090"></a><a href="#l1090">1090</a><td>  // number when a is less, and a positive number otherwise.<tr><td><a id="l1091"></a><a href="#l1091">1091</a><td>  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };<tr><td><a id="l1092"></a><a href="#l1092">1092</a><td><tr><td><a id="l1093"></a><a href="#l1093">1093</a><td>  function copyPos(x) {return Pos(x.line, x.ch);}<tr><td><a id="l1094"></a><a href="#l1094">1094</a><td>  function maxPos(a, b) { return cmp(a, b) &lt; 0 ? b : a; }<tr><td><a id="l1095"></a><a href="#l1095">1095</a><td>  function minPos(a, b) { return cmp(a, b) &lt; 0 ? a : b; }<tr><td><a id="l1096"></a><a href="#l1096">1096</a><td><tr><td><a id="l1097"></a><a href="#l1097">1097</a><td>  // INPUT HANDLING<tr><td><a id="l1098"></a><a href="#l1098">1098</a><td><tr><td><a id="l1099"></a><a href="#l1099">1099</a><td>  function ensureFocus(cm) {<tr><td><a id="l1100"></a><a href="#l1100">1100</a><td>    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }<tr><td><a id="l1101"></a><a href="#l1101">1101</a><td>  }<tr><td><a id="l1102"></a><a href="#l1102">1102</a><td><tr><td><a id="l1103"></a><a href="#l1103">1103</a><td>  // This will be set to a {lineWise: bool, text: [string]} object, so<tr><td><a id="l1104"></a><a href="#l1104">1104</a><td>  // that, when pasting, we know what kind of selections the copied<tr><td><a id="l1105"></a><a href="#l1105">1105</a><td>  // text was made out of.<tr><td><a id="l1106"></a><a href="#l1106">1106</a><td>  var lastCopied = null;<tr><td><a id="l1107"></a><a href="#l1107">1107</a><td><tr><td><a id="l1108"></a><a href="#l1108">1108</a><td>  function applyTextInput(cm, inserted, deleted, sel, origin) {<tr><td><a id="l1109"></a><a href="#l1109">1109</a><td>    var doc = cm.doc;<tr><td><a id="l1110"></a><a href="#l1110">1110</a><td>    cm.display.shift = false;<tr><td><a id="l1111"></a><a href="#l1111">1111</a><td>    if (!sel) sel = doc.sel;<tr><td><a id="l1112"></a><a href="#l1112">1112</a><td><tr><td><a id="l1113"></a><a href="#l1113">1113</a><td>    var paste = cm.state.pasteIncoming || origin == &quot;paste&quot;;<tr><td><a id="l1114"></a><a href="#l1114">1114</a><td>    var textLines = doc.splitLines(inserted), multiPaste = null<tr><td><a id="l1115"></a><a href="#l1115">1115</a><td>    // When pasing N lines into N selections, insert one line per selection<tr><td><a id="l1116"></a><a href="#l1116">1116</a><td>    if (paste &amp;&amp; sel.ranges.length &gt; 1) {<tr><td><a id="l1117"></a><a href="#l1117">1117</a><td>      if (lastCopied &amp;&amp; lastCopied.text.join(&quot;\n&quot;) == inserted) {<tr><td><a id="l1118"></a><a href="#l1118">1118</a><td>        if (sel.ranges.length % lastCopied.text.length == 0) {<tr><td><a id="l1119"></a><a href="#l1119">1119</a><td>          multiPaste = [];<tr><td><a id="l1120"></a><a href="#l1120">1120</a><td>          for (var i = 0; i &lt; lastCopied.text.length; i++)<tr><td><a id="l1121"></a><a href="#l1121">1121</a><td>            multiPaste.push(doc.splitLines(lastCopied.text[i]));<tr><td><a id="l1122"></a><a href="#l1122">1122</a><td>        }<tr><td><a id="l1123"></a><a href="#l1123">1123</a><td>      } else if (textLines.length == sel.ranges.length) {<tr><td><a id="l1124"></a><a href="#l1124">1124</a><td>        multiPaste = map(textLines, function(l) { return [l]; });<tr><td><a id="l1125"></a><a href="#l1125">1125</a><td>      }<tr><td><a id="l1126"></a><a href="#l1126">1126</a><td>    }<tr><td><a id="l1127"></a><a href="#l1127">1127</a><td><tr><td><a id="l1128"></a><a href="#l1128">1128</a><td>    // Normal behavior is to insert the new text into every selection<tr><td><a id="l1129"></a><a href="#l1129">1129</a><td>    for (var i = sel.ranges.length - 1; i &gt;= 0; i--) {<tr><td><a id="l1130"></a><a href="#l1130">1130</a><td>      var range = sel.ranges[i];<tr><td><a id="l1131"></a><a href="#l1131">1131</a><td>      var from = range.from(), to = range.to();<tr><td><a id="l1132"></a><a href="#l1132">1132</a><td>      if (range.empty()) {<tr><td><a id="l1133"></a><a href="#l1133">1133</a><td>        if (deleted &amp;&amp; deleted &gt; 0) // Handle deletion<tr><td><a id="l1134"></a><a href="#l1134">1134</a><td>          from = Pos(from.line, from.ch - deleted);<tr><td><a id="l1135"></a><a href="#l1135">1135</a><td>        else if (cm.state.overwrite &amp;&amp; !paste) // Handle overwrite<tr><td><a id="l1136"></a><a href="#l1136">1136</a><td>          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));<tr><td><a id="l1137"></a><a href="#l1137">1137</a><td>        else if (lastCopied &amp;&amp; lastCopied.lineWise &amp;&amp; lastCopied.text.join(&quot;\n&quot;) == inserted)<tr><td><a id="l1138"></a><a href="#l1138">1138</a><td>          from = to = Pos(from.line, 0)<tr><td><a id="l1139"></a><a href="#l1139">1139</a><td>      }<tr><td><a id="l1140"></a><a href="#l1140">1140</a><td>      var updateInput = cm.curOp.updateInput;<tr><td><a id="l1141"></a><a href="#l1141">1141</a><td>      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,<tr><td><a id="l1142"></a><a href="#l1142">1142</a><td>                         origin: origin || (paste ? &quot;paste&quot; : cm.state.cutIncoming ? &quot;cut&quot; : &quot;+input&quot;)};<tr><td><a id="l1143"></a><a href="#l1143">1143</a><td>      makeChange(cm.doc, changeEvent);<tr><td><a id="l1144"></a><a href="#l1144">1144</a><td>      signalLater(cm, &quot;inputRead&quot;, cm, changeEvent);<tr><td><a id="l1145"></a><a href="#l1145">1145</a><td>    }<tr><td><a id="l1146"></a><a href="#l1146">1146</a><td>    if (inserted &amp;&amp; !paste)<tr><td><a id="l1147"></a><a href="#l1147">1147</a><td>      triggerElectric(cm, inserted);<tr><td><a id="l1148"></a><a href="#l1148">1148</a><td><tr><td><a id="l1149"></a><a href="#l1149">1149</a><td>    ensureCursorVisible(cm);<tr><td><a id="l1150"></a><a href="#l1150">1150</a><td>    cm.curOp.updateInput = updateInput;<tr><td><a id="l1151"></a><a href="#l1151">1151</a><td>    cm.curOp.typing = true;<tr><td><a id="l1152"></a><a href="#l1152">1152</a><td>    cm.state.pasteIncoming = cm.state.cutIncoming = false;<tr><td><a id="l1153"></a><a href="#l1153">1153</a><td>  }<tr><td><a id="l1154"></a><a href="#l1154">1154</a><td><tr><td><a id="l1155"></a><a href="#l1155">1155</a><td>  function handlePaste(e, cm) {<tr><td><a id="l1156"></a><a href="#l1156">1156</a><td>    var pasted = e.clipboardData &amp;&amp; e.clipboardData.getData(&quot;text/plain&quot;);<tr><td><a id="l1157"></a><a href="#l1157">1157</a><td>    if (pasted) {<tr><td><a id="l1158"></a><a href="#l1158">1158</a><td>      e.preventDefault();<tr><td><a id="l1159"></a><a href="#l1159">1159</a><td>      if (!cm.isReadOnly() &amp;&amp; !cm.options.disableInput)<tr><td><a id="l1160"></a><a href="#l1160">1160</a><td>        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, &quot;paste&quot;); });<tr><td><a id="l1161"></a><a href="#l1161">1161</a><td>      return true;<tr><td><a id="l1162"></a><a href="#l1162">1162</a><td>    }<tr><td><a id="l1163"></a><a href="#l1163">1163</a><td>  }<tr><td><a id="l1164"></a><a href="#l1164">1164</a><td><tr><td><a id="l1165"></a><a href="#l1165">1165</a><td>  function triggerElectric(cm, inserted) {<tr><td><a id="l1166"></a><a href="#l1166">1166</a><td>    // When an &#39;electric&#39; character is inserted, immediately trigger a reindent<tr><td><a id="l1167"></a><a href="#l1167">1167</a><td>    if (!cm.options.electricChars || !cm.options.smartIndent) return;<tr><td><a id="l1168"></a><a href="#l1168">1168</a><td>    var sel = cm.doc.sel;<tr><td><a id="l1169"></a><a href="#l1169">1169</a><td><tr><td><a id="l1170"></a><a href="#l1170">1170</a><td>    for (var i = sel.ranges.length - 1; i &gt;= 0; i--) {<tr><td><a id="l1171"></a><a href="#l1171">1171</a><td>      var range = sel.ranges[i];<tr><td><a id="l1172"></a><a href="#l1172">1172</a><td>      if (range.head.ch &gt; 100 || (i &amp;&amp; sel.ranges[i - 1].head.line == range.head.line)) continue;<tr><td><a id="l1173"></a><a href="#l1173">1173</a><td>      var mode = cm.getModeAt(range.head);<tr><td><a id="l1174"></a><a href="#l1174">1174</a><td>      var indented = false;<tr><td><a id="l1175"></a><a href="#l1175">1175</a><td>      if (mode.electricChars) {<tr><td><a id="l1176"></a><a href="#l1176">1176</a><td>        for (var j = 0; j &lt; mode.electricChars.length; j++)<tr><td><a id="l1177"></a><a href="#l1177">1177</a><td>          if (inserted.indexOf(mode.electricChars.charAt(j)) &gt; -1) {<tr><td><a id="l1178"></a><a href="#l1178">1178</a><td>            indented = indentLine(cm, range.head.line, &quot;smart&quot;);<tr><td><a id="l1179"></a><a href="#l1179">1179</a><td>            break;<tr><td><a id="l1180"></a><a href="#l1180">1180</a><td>          }<tr><td><a id="l1181"></a><a href="#l1181">1181</a><td>      } else if (mode.electricInput) {<tr><td><a id="l1182"></a><a href="#l1182">1182</a><td>        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))<tr><td><a id="l1183"></a><a href="#l1183">1183</a><td>          indented = indentLine(cm, range.head.line, &quot;smart&quot;);<tr><td><a id="l1184"></a><a href="#l1184">1184</a><td>      }<tr><td><a id="l1185"></a><a href="#l1185">1185</a><td>      if (indented) signalLater(cm, &quot;electricInput&quot;, cm, range.head.line);<tr><td><a id="l1186"></a><a href="#l1186">1186</a><td>    }<tr><td><a id="l1187"></a><a href="#l1187">1187</a><td>  }<tr><td><a id="l1188"></a><a href="#l1188">1188</a><td><tr><td><a id="l1189"></a><a href="#l1189">1189</a><td>  function copyableRanges(cm) {<tr><td><a id="l1190"></a><a href="#l1190">1190</a><td>    var text = [], ranges = [];<tr><td><a id="l1191"></a><a href="#l1191">1191</a><td>    for (var i = 0; i &lt; cm.doc.sel.ranges.length; i++) {<tr><td><a id="l1192"></a><a href="#l1192">1192</a><td>      var line = cm.doc.sel.ranges[i].head.line;<tr><td><a id="l1193"></a><a href="#l1193">1193</a><td>      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};<tr><td><a id="l1194"></a><a href="#l1194">1194</a><td>      ranges.push(lineRange);<tr><td><a id="l1195"></a><a href="#l1195">1195</a><td>      text.push(cm.getRange(lineRange.anchor, lineRange.head));<tr><td><a id="l1196"></a><a href="#l1196">1196</a><td>    }<tr><td><a id="l1197"></a><a href="#l1197">1197</a><td>    return {text: text, ranges: ranges};<tr><td><a id="l1198"></a><a href="#l1198">1198</a><td>  }<tr><td><a id="l1199"></a><a href="#l1199">1199</a><td><tr><td><a id="l1200"></a><a href="#l1200">1200</a><td>  function disableBrowserMagic(field) {<tr><td><a id="l1201"></a><a href="#l1201">1201</a><td>    field.setAttribute(&quot;autocorrect&quot;, &quot;off&quot;);<tr><td><a id="l1202"></a><a href="#l1202">1202</a><td>    field.setAttribute(&quot;autocapitalize&quot;, &quot;off&quot;);<tr><td><a id="l1203"></a><a href="#l1203">1203</a><td>    field.setAttribute(&quot;spellcheck&quot;, &quot;false&quot;);<tr><td><a id="l1204"></a><a href="#l1204">1204</a><td>  }<tr><td><a id="l1205"></a><a href="#l1205">1205</a><td><tr><td><a id="l1206"></a><a href="#l1206">1206</a><td>  // TEXTAREA INPUT STYLE<tr><td><a id="l1207"></a><a href="#l1207">1207</a><td><tr><td><a id="l1208"></a><a href="#l1208">1208</a><td>  function TextareaInput(cm) {<tr><td><a id="l1209"></a><a href="#l1209">1209</a><td>    this.cm = cm;<tr><td><a id="l1210"></a><a href="#l1210">1210</a><td>    // See input.poll and input.reset<tr><td><a id="l1211"></a><a href="#l1211">1211</a><td>    this.prevInput = &quot;&quot;;<tr><td><a id="l1212"></a><a href="#l1212">1212</a><td><tr><td><a id="l1213"></a><a href="#l1213">1213</a><td>    // Flag that indicates whether we expect input to appear real soon<tr><td><a id="l1214"></a><a href="#l1214">1214</a><td>    // now (after some event like &#39;keypress&#39; or &#39;input&#39;) and are<tr><td><a id="l1215"></a><a href="#l1215">1215</a><td>    // polling intensively.<tr><td><a id="l1216"></a><a href="#l1216">1216</a><td>    this.pollingFast = false;<tr><td><a id="l1217"></a><a href="#l1217">1217</a><td>    // Self-resetting timeout for the poller<tr><td><a id="l1218"></a><a href="#l1218">1218</a><td>    this.polling = new Delayed();<tr><td><a id="l1219"></a><a href="#l1219">1219</a><td>    // Tracks when input.reset has punted to just putting a short<tr><td><a id="l1220"></a><a href="#l1220">1220</a><td>    // string into the textarea instead of the full selection.<tr><td><a id="l1221"></a><a href="#l1221">1221</a><td>    this.inaccurateSelection = false;<tr><td><a id="l1222"></a><a href="#l1222">1222</a><td>    // Used to work around IE issue with selection being forgotten when focus moves away from textarea<tr><td><a id="l1223"></a><a href="#l1223">1223</a><td>    this.hasSelection = false;<tr><td><a id="l1224"></a><a href="#l1224">1224</a><td>    this.composing = null;<tr><td><a id="l1225"></a><a href="#l1225">1225</a><td>  };<tr><td><a id="l1226"></a><a href="#l1226">1226</a><td><tr><td><a id="l1227"></a><a href="#l1227">1227</a><td>  function hiddenTextarea() {<tr><td><a id="l1228"></a><a href="#l1228">1228</a><td>    var te = elt(&quot;textarea&quot;, null, null, &quot;position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none&quot;);<tr><td><a id="l1229"></a><a href="#l1229">1229</a><td>    var div = elt(&quot;div&quot;, [te], null, &quot;overflow: hidden; position: relative; width: 3px; height: 0px;&quot;);<tr><td><a id="l1230"></a><a href="#l1230">1230</a><td>    // The textarea is kept positioned near the cursor to prevent the<tr><td><a id="l1231"></a><a href="#l1231">1231</a><td>    // fact that it&#39;ll be scrolled into view on input from scrolling<tr><td><a id="l1232"></a><a href="#l1232">1232</a><td>    // our fake cursor out of view. On webkit, when wrap=off, paste is<tr><td><a id="l1233"></a><a href="#l1233">1233</a><td>    // very slow. So make the area wide instead.<tr><td><a id="l1234"></a><a href="#l1234">1234</a><td>    if (webkit) te.style.width = &quot;1000px&quot;;<tr><td><a id="l1235"></a><a href="#l1235">1235</a><td>    else te.setAttribute(&quot;wrap&quot;, &quot;off&quot;);<tr><td><a id="l1236"></a><a href="#l1236">1236</a><td>    // If border: 0; -- iOS fails to open keyboard (issue #1287)<tr><td><a id="l1237"></a><a href="#l1237">1237</a><td>    if (ios) te.style.border = &quot;1px solid black&quot;;<tr><td><a id="l1238"></a><a href="#l1238">1238</a><td>    disableBrowserMagic(te);<tr><td><a id="l1239"></a><a href="#l1239">1239</a><td>    return div;<tr><td><a id="l1240"></a><a href="#l1240">1240</a><td>  }<tr><td><a id="l1241"></a><a href="#l1241">1241</a><td><tr><td><a id="l1242"></a><a href="#l1242">1242</a><td>  TextareaInput.prototype = copyObj({<tr><td><a id="l1243"></a><a href="#l1243">1243</a><td>    init: function(display) {<tr><td><a id="l1244"></a><a href="#l1244">1244</a><td>      var input = this, cm = this.cm;<tr><td><a id="l1245"></a><a href="#l1245">1245</a><td><tr><td><a id="l1246"></a><a href="#l1246">1246</a><td>      // Wraps and hides input textarea<tr><td><a id="l1247"></a><a href="#l1247">1247</a><td>      var div = this.wrapper = hiddenTextarea();<tr><td><a id="l1248"></a><a href="#l1248">1248</a><td>      // The semihidden textarea that is focused when the editor is<tr><td><a id="l1249"></a><a href="#l1249">1249</a><td>      // focused, and receives input.<tr><td><a id="l1250"></a><a href="#l1250">1250</a><td>      var te = this.textarea = div.firstChild;<tr><td><a id="l1251"></a><a href="#l1251">1251</a><td>      display.wrapper.insertBefore(div, display.wrapper.firstChild);<tr><td><a id="l1252"></a><a href="#l1252">1252</a><td><tr><td><a id="l1253"></a><a href="#l1253">1253</a><td>      // Needed to hide big blue blinking cursor on Mobile Safari (doesn&#39;t seem to work in iOS 8 anymore)<tr><td><a id="l1254"></a><a href="#l1254">1254</a><td>      if (ios) te.style.width = &quot;0px&quot;;<tr><td><a id="l1255"></a><a href="#l1255">1255</a><td><tr><td><a id="l1256"></a><a href="#l1256">1256</a><td>      on(te, &quot;input&quot;, function() {<tr><td><a id="l1257"></a><a href="#l1257">1257</a><td>        if (ie &amp;&amp; ie_version &gt;= 9 &amp;&amp; input.hasSelection) input.hasSelection = null;<tr><td><a id="l1258"></a><a href="#l1258">1258</a><td>        input.poll();<tr><td><a id="l1259"></a><a href="#l1259">1259</a><td>      });<tr><td><a id="l1260"></a><a href="#l1260">1260</a><td><tr><td><a id="l1261"></a><a href="#l1261">1261</a><td>      on(te, &quot;paste&quot;, function(e) {<tr><td><a id="l1262"></a><a href="#l1262">1262</a><td>        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return<tr><td><a id="l1263"></a><a href="#l1263">1263</a><td><tr><td><a id="l1264"></a><a href="#l1264">1264</a><td>        cm.state.pasteIncoming = true;<tr><td><a id="l1265"></a><a href="#l1265">1265</a><td>        input.fastPoll();<tr><td><a id="l1266"></a><a href="#l1266">1266</a><td>      });<tr><td><a id="l1267"></a><a href="#l1267">1267</a><td><tr><td><a id="l1268"></a><a href="#l1268">1268</a><td>      function prepareCopyCut(e) {<tr><td><a id="l1269"></a><a href="#l1269">1269</a><td>        if (signalDOMEvent(cm, e)) return<tr><td><a id="l1270"></a><a href="#l1270">1270</a><td>        if (cm.somethingSelected()) {<tr><td><a id="l1271"></a><a href="#l1271">1271</a><td>          lastCopied = {lineWise: false, text: cm.getSelections()};<tr><td><a id="l1272"></a><a href="#l1272">1272</a><td>          if (input.inaccurateSelection) {<tr><td><a id="l1273"></a><a href="#l1273">1273</a><td>            input.prevInput = &quot;&quot;;<tr><td><a id="l1274"></a><a href="#l1274">1274</a><td>            input.inaccurateSelection = false;<tr><td><a id="l1275"></a><a href="#l1275">1275</a><td>            te.value = lastCopied.text.join(&quot;\n&quot;);<tr><td><a id="l1276"></a><a href="#l1276">1276</a><td>            selectInput(te);<tr><td><a id="l1277"></a><a href="#l1277">1277</a><td>          }<tr><td><a id="l1278"></a><a href="#l1278">1278</a><td>        } else if (!cm.options.lineWiseCopyCut) {<tr><td><a id="l1279"></a><a href="#l1279">1279</a><td>          return;<tr><td><a id="l1280"></a><a href="#l1280">1280</a><td>        } else {<tr><td><a id="l1281"></a><a href="#l1281">1281</a><td>          var ranges = copyableRanges(cm);<tr><td><a id="l1282"></a><a href="#l1282">1282</a><td>          lastCopied = {lineWise: true, text: ranges.text};<tr><td><a id="l1283"></a><a href="#l1283">1283</a><td>          if (e.type == &quot;cut&quot;) {<tr><td><a id="l1284"></a><a href="#l1284">1284</a><td>            cm.setSelections(ranges.ranges, null, sel_dontScroll);<tr><td><a id="l1285"></a><a href="#l1285">1285</a><td>          } else {<tr><td><a id="l1286"></a><a href="#l1286">1286</a><td>            input.prevInput = &quot;&quot;;<tr><td><a id="l1287"></a><a href="#l1287">1287</a><td>            te.value = ranges.text.join(&quot;\n&quot;);<tr><td><a id="l1288"></a><a href="#l1288">1288</a><td>            selectInput(te);<tr><td><a id="l1289"></a><a href="#l1289">1289</a><td>          }<tr><td><a id="l1290"></a><a href="#l1290">1290</a><td>        }<tr><td><a id="l1291"></a><a href="#l1291">1291</a><td>        if (e.type == &quot;cut&quot;) cm.state.cutIncoming = true;<tr><td><a id="l1292"></a><a href="#l1292">1292</a><td>      }<tr><td><a id="l1293"></a><a href="#l1293">1293</a><td>      on(te, &quot;cut&quot;, prepareCopyCut);<tr><td><a id="l1294"></a><a href="#l1294">1294</a><td>      on(te, &quot;copy&quot;, prepareCopyCut);<tr><td><a id="l1295"></a><a href="#l1295">1295</a><td><tr><td><a id="l1296"></a><a href="#l1296">1296</a><td>      on(display.scroller, &quot;paste&quot;, function(e) {<tr><td><a id="l1297"></a><a href="#l1297">1297</a><td>        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;<tr><td><a id="l1298"></a><a href="#l1298">1298</a><td>        cm.state.pasteIncoming = true;<tr><td><a id="l1299"></a><a href="#l1299">1299</a><td>        input.focus();<tr><td><a id="l1300"></a><a href="#l1300">1300</a><td>      });<tr><td><a id="l1301"></a><a href="#l1301">1301</a><td><tr><td><a id="l1302"></a><a href="#l1302">1302</a><td>      // Prevent normal selection in the editor (we handle our own)<tr><td><a id="l1303"></a><a href="#l1303">1303</a><td>      on(display.lineSpace, &quot;selectstart&quot;, function(e) {<tr><td><a id="l1304"></a><a href="#l1304">1304</a><td>        if (!eventInWidget(display, e)) e_preventDefault(e);<tr><td><a id="l1305"></a><a href="#l1305">1305</a><td>      });<tr><td><a id="l1306"></a><a href="#l1306">1306</a><td><tr><td><a id="l1307"></a><a href="#l1307">1307</a><td>      on(te, &quot;compositionstart&quot;, function() {<tr><td><a id="l1308"></a><a href="#l1308">1308</a><td>        var start = cm.getCursor(&quot;from&quot;);<tr><td><a id="l1309"></a><a href="#l1309">1309</a><td>        if (input.composing) input.composing.range.clear()<tr><td><a id="l1310"></a><a href="#l1310">1310</a><td>        input.composing = {<tr><td><a id="l1311"></a><a href="#l1311">1311</a><td>          start: start,<tr><td><a id="l1312"></a><a href="#l1312">1312</a><td>          range: cm.markText(start, cm.getCursor(&quot;to&quot;), {className: &quot;CodeMirror-composing&quot;})<tr><td><a id="l1313"></a><a href="#l1313">1313</a><td>        };<tr><td><a id="l1314"></a><a href="#l1314">1314</a><td>      });<tr><td><a id="l1315"></a><a href="#l1315">1315</a><td>      on(te, &quot;compositionend&quot;, function() {<tr><td><a id="l1316"></a><a href="#l1316">1316</a><td>        if (input.composing) {<tr><td><a id="l1317"></a><a href="#l1317">1317</a><td>          input.poll();<tr><td><a id="l1318"></a><a href="#l1318">1318</a><td>          input.composing.range.clear();<tr><td><a id="l1319"></a><a href="#l1319">1319</a><td>          input.composing = null;<tr><td><a id="l1320"></a><a href="#l1320">1320</a><td>        }<tr><td><a id="l1321"></a><a href="#l1321">1321</a><td>      });<tr><td><a id="l1322"></a><a href="#l1322">1322</a><td>    },<tr><td><a id="l1323"></a><a href="#l1323">1323</a><td><tr><td><a id="l1324"></a><a href="#l1324">1324</a><td>    prepareSelection: function() {<tr><td><a id="l1325"></a><a href="#l1325">1325</a><td>      // Redraw the selection and/or cursor<tr><td><a id="l1326"></a><a href="#l1326">1326</a><td>      var cm = this.cm, display = cm.display, doc = cm.doc;<tr><td><a id="l1327"></a><a href="#l1327">1327</a><td>      var result = prepareSelection(cm);<tr><td><a id="l1328"></a><a href="#l1328">1328</a><td><tr><td><a id="l1329"></a><a href="#l1329">1329</a><td>      // Move the hidden textarea near the cursor to prevent scrolling artifacts<tr><td><a id="l1330"></a><a href="#l1330">1330</a><td>      if (cm.options.moveInputWithCursor) {<tr><td><a id="l1331"></a><a href="#l1331">1331</a><td>        var headPos = cursorCoords(cm, doc.sel.primary().head, &quot;div&quot;);<tr><td><a id="l1332"></a><a href="#l1332">1332</a><td>        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();<tr><td><a id="l1333"></a><a href="#l1333">1333</a><td>        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,<tr><td><a id="l1334"></a><a href="#l1334">1334</a><td>                                            headPos.top + lineOff.top - wrapOff.top));<tr><td><a id="l1335"></a><a href="#l1335">1335</a><td>        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,<tr><td><a id="l1336"></a><a href="#l1336">1336</a><td>                                             headPos.left + lineOff.left - wrapOff.left));<tr><td><a id="l1337"></a><a href="#l1337">1337</a><td>      }<tr><td><a id="l1338"></a><a href="#l1338">1338</a><td><tr><td><a id="l1339"></a><a href="#l1339">1339</a><td>      return result;<tr><td><a id="l1340"></a><a href="#l1340">1340</a><td>    },<tr><td><a id="l1341"></a><a href="#l1341">1341</a><td><tr><td><a id="l1342"></a><a href="#l1342">1342</a><td>    showSelection: function(drawn) {<tr><td><a id="l1343"></a><a href="#l1343">1343</a><td>      var cm = this.cm, display = cm.display;<tr><td><a id="l1344"></a><a href="#l1344">1344</a><td>      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);<tr><td><a id="l1345"></a><a href="#l1345">1345</a><td>      removeChildrenAndAdd(display.selectionDiv, drawn.selection);<tr><td><a id="l1346"></a><a href="#l1346">1346</a><td>      if (drawn.teTop != null) {<tr><td><a id="l1347"></a><a href="#l1347">1347</a><td>        this.wrapper.style.top = drawn.teTop + &quot;px&quot;;<tr><td><a id="l1348"></a><a href="#l1348">1348</a><td>        this.wrapper.style.left = drawn.teLeft + &quot;px&quot;;<tr><td><a id="l1349"></a><a href="#l1349">1349</a><td>      }<tr><td><a id="l1350"></a><a href="#l1350">1350</a><td>    },<tr><td><a id="l1351"></a><a href="#l1351">1351</a><td><tr><td><a id="l1352"></a><a href="#l1352">1352</a><td>    // Reset the input to correspond to the selection (or to be empty,<tr><td><a id="l1353"></a><a href="#l1353">1353</a><td>    // when not typing and nothing is selected)<tr><td><a id="l1354"></a><a href="#l1354">1354</a><td>    reset: function(typing) {<tr><td><a id="l1355"></a><a href="#l1355">1355</a><td>      if (this.contextMenuPending) return;<tr><td><a id="l1356"></a><a href="#l1356">1356</a><td>      var minimal, selected, cm = this.cm, doc = cm.doc;<tr><td><a id="l1357"></a><a href="#l1357">1357</a><td>      if (cm.somethingSelected()) {<tr><td><a id="l1358"></a><a href="#l1358">1358</a><td>        this.prevInput = &quot;&quot;;<tr><td><a id="l1359"></a><a href="#l1359">1359</a><td>        var range = doc.sel.primary();<tr><td><a id="l1360"></a><a href="#l1360">1360</a><td>        minimal = hasCopyEvent &amp;&amp;<tr><td><a id="l1361"></a><a href="#l1361">1361</a><td>          (range.to().line - range.from().line &gt; 100 || (selected = cm.getSelection()).length &gt; 1000);<tr><td><a id="l1362"></a><a href="#l1362">1362</a><td>        var content = minimal ? &quot;-&quot; : selected || cm.getSelection();<tr><td><a id="l1363"></a><a href="#l1363">1363</a><td>        this.textarea.value = content;<tr><td><a id="l1364"></a><a href="#l1364">1364</a><td>        if (cm.state.focused) selectInput(this.textarea);<tr><td><a id="l1365"></a><a href="#l1365">1365</a><td>        if (ie &amp;&amp; ie_version &gt;= 9) this.hasSelection = content;<tr><td><a id="l1366"></a><a href="#l1366">1366</a><td>      } else if (!typing) {<tr><td><a id="l1367"></a><a href="#l1367">1367</a><td>        this.prevInput = this.textarea.value = &quot;&quot;;<tr><td><a id="l1368"></a><a href="#l1368">1368</a><td>        if (ie &amp;&amp; ie_version &gt;= 9) this.hasSelection = null;<tr><td><a id="l1369"></a><a href="#l1369">1369</a><td>      }<tr><td><a id="l1370"></a><a href="#l1370">1370</a><td>      this.inaccurateSelection = minimal;<tr><td><a id="l1371"></a><a href="#l1371">1371</a><td>    },<tr><td><a id="l1372"></a><a href="#l1372">1372</a><td><tr><td><a id="l1373"></a><a href="#l1373">1373</a><td>    getField: function() { return this.textarea; },<tr><td><a id="l1374"></a><a href="#l1374">1374</a><td><tr><td><a id="l1375"></a><a href="#l1375">1375</a><td>    supportsTouch: function() { return false; },<tr><td><a id="l1376"></a><a href="#l1376">1376</a><td><tr><td><a id="l1377"></a><a href="#l1377">1377</a><td>    focus: function() {<tr><td><a id="l1378"></a><a href="#l1378">1378</a><td>      if (this.cm.options.readOnly != &quot;nocursor&quot; &amp;&amp; (!mobile || activeElt() != this.textarea)) {<tr><td><a id="l1379"></a><a href="#l1379">1379</a><td>        try { this.textarea.focus(); }<tr><td><a id="l1380"></a><a href="#l1380">1380</a><td>        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM<tr><td><a id="l1381"></a><a href="#l1381">1381</a><td>      }<tr><td><a id="l1382"></a><a href="#l1382">1382</a><td>    },<tr><td><a id="l1383"></a><a href="#l1383">1383</a><td><tr><td><a id="l1384"></a><a href="#l1384">1384</a><td>    blur: function() { this.textarea.blur(); },<tr><td><a id="l1385"></a><a href="#l1385">1385</a><td><tr><td><a id="l1386"></a><a href="#l1386">1386</a><td>    resetPosition: function() {<tr><td><a id="l1387"></a><a href="#l1387">1387</a><td>      this.wrapper.style.top = this.wrapper.style.left = 0;<tr><td><a id="l1388"></a><a href="#l1388">1388</a><td>    },<tr><td><a id="l1389"></a><a href="#l1389">1389</a><td><tr><td><a id="l1390"></a><a href="#l1390">1390</a><td>    receivedFocus: function() { this.slowPoll(); },<tr><td><a id="l1391"></a><a href="#l1391">1391</a><td><tr><td><a id="l1392"></a><a href="#l1392">1392</a><td>    // Poll for input changes, using the normal rate of polling. This<tr><td><a id="l1393"></a><a href="#l1393">1393</a><td>    // runs as long as the editor is focused.<tr><td><a id="l1394"></a><a href="#l1394">1394</a><td>    slowPoll: function() {<tr><td><a id="l1395"></a><a href="#l1395">1395</a><td>      var input = this;<tr><td><a id="l1396"></a><a href="#l1396">1396</a><td>      if (input.pollingFast) return;<tr><td><a id="l1397"></a><a href="#l1397">1397</a><td>      input.polling.set(this.cm.options.pollInterval, function() {<tr><td><a id="l1398"></a><a href="#l1398">1398</a><td>        input.poll();<tr><td><a id="l1399"></a><a href="#l1399">1399</a><td>        if (input.cm.state.focused) input.slowPoll();<tr><td><a id="l1400"></a><a href="#l1400">1400</a><td>      });<tr><td><a id="l1401"></a><a href="#l1401">1401</a><td>    },<tr><td><a id="l1402"></a><a href="#l1402">1402</a><td><tr><td><a id="l1403"></a><a href="#l1403">1403</a><td>    // When an event has just come in that is likely to add or change<tr><td><a id="l1404"></a><a href="#l1404">1404</a><td>    // something in the input textarea, we poll faster, to ensure that<tr><td><a id="l1405"></a><a href="#l1405">1405</a><td>    // the change appears on the screen quickly.<tr><td><a id="l1406"></a><a href="#l1406">1406</a><td>    fastPoll: function() {<tr><td><a id="l1407"></a><a href="#l1407">1407</a><td>      var missed = false, input = this;<tr><td><a id="l1408"></a><a href="#l1408">1408</a><td>      input.pollingFast = true;<tr><td><a id="l1409"></a><a href="#l1409">1409</a><td>      function p() {<tr><td><a id="l1410"></a><a href="#l1410">1410</a><td>        var changed = input.poll();<tr><td><a id="l1411"></a><a href="#l1411">1411</a><td>        if (!changed &amp;&amp; !missed) {missed = true; input.polling.set(60, p);}<tr><td><a id="l1412"></a><a href="#l1412">1412</a><td>        else {input.pollingFast = false; input.slowPoll();}<tr><td><a id="l1413"></a><a href="#l1413">1413</a><td>      }<tr><td><a id="l1414"></a><a href="#l1414">1414</a><td>      input.polling.set(20, p);<tr><td><a id="l1415"></a><a href="#l1415">1415</a><td>    },<tr><td><a id="l1416"></a><a href="#l1416">1416</a><td><tr><td><a id="l1417"></a><a href="#l1417">1417</a><td>    // Read input from the textarea, and update the document to match.<tr><td><a id="l1418"></a><a href="#l1418">1418</a><td>    // When something is selected, it is present in the textarea, and<tr><td><a id="l1419"></a><a href="#l1419">1419</a><td>    // selected (unless it is huge, in which case a placeholder is<tr><td><a id="l1420"></a><a href="#l1420">1420</a><td>    // used). When nothing is selected, the cursor sits after previously<tr><td><a id="l1421"></a><a href="#l1421">1421</a><td>    // seen text (can be empty), which is stored in prevInput (we must<tr><td><a id="l1422"></a><a href="#l1422">1422</a><td>    // not reset the textarea when typing, because that breaks IME).<tr><td><a id="l1423"></a><a href="#l1423">1423</a><td>    poll: function() {<tr><td><a id="l1424"></a><a href="#l1424">1424</a><td>      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;<tr><td><a id="l1425"></a><a href="#l1425">1425</a><td>      // Since this is called a *lot*, try to bail out as cheaply as<tr><td><a id="l1426"></a><a href="#l1426">1426</a><td>      // possible when it is clear that nothing happened. hasSelection<tr><td><a id="l1427"></a><a href="#l1427">1427</a><td>      // will be the case when there is a lot of text in the textarea,<tr><td><a id="l1428"></a><a href="#l1428">1428</a><td>      // in which case reading its value would be expensive.<tr><td><a id="l1429"></a><a href="#l1429">1429</a><td>      if (this.contextMenuPending || !cm.state.focused ||<tr><td><a id="l1430"></a><a href="#l1430">1430</a><td>          (hasSelection(input) &amp;&amp; !prevInput &amp;&amp; !this.composing) ||<tr><td><a id="l1431"></a><a href="#l1431">1431</a><td>          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)<tr><td><a id="l1432"></a><a href="#l1432">1432</a><td>        return false;<tr><td><a id="l1433"></a><a href="#l1433">1433</a><td><tr><td><a id="l1434"></a><a href="#l1434">1434</a><td>      var text = input.value;<tr><td><a id="l1435"></a><a href="#l1435">1435</a><td>      // If nothing changed, bail.<tr><td><a id="l1436"></a><a href="#l1436">1436</a><td>      if (text == prevInput &amp;&amp; !cm.somethingSelected()) return false;<tr><td><a id="l1437"></a><a href="#l1437">1437</a><td>      // Work around nonsensical selection resetting in IE9/10, and<tr><td><a id="l1438"></a><a href="#l1438">1438</a><td>      // inexplicable appearance of private area unicode characters on<tr><td><a id="l1439"></a><a href="#l1439">1439</a><td>      // some key combos in Mac (#2689).<tr><td><a id="l1440"></a><a href="#l1440">1440</a><td>      if (ie &amp;&amp; ie_version &gt;= 9 &amp;&amp; this.hasSelection === text ||<tr><td><a id="l1441"></a><a href="#l1441">1441</a><td>          mac &amp;&amp; /[\uf700-\uf7ff]/.test(text)) {<tr><td><a id="l1442"></a><a href="#l1442">1442</a><td>        cm.display.input.reset();<tr><td><a id="l1443"></a><a href="#l1443">1443</a><td>        return false;<tr><td><a id="l1444"></a><a href="#l1444">1444</a><td>      }<tr><td><a id="l1445"></a><a href="#l1445">1445</a><td><tr><td><a id="l1446"></a><a href="#l1446">1446</a><td>      if (cm.doc.sel == cm.display.selForContextMenu) {<tr><td><a id="l1447"></a><a href="#l1447">1447</a><td>        var first = text.charCodeAt(0);<tr><td><a id="l1448"></a><a href="#l1448">1448</a><td>        if (first == 0x200b &amp;&amp; !prevInput) prevInput = &quot;\u200b&quot;;<tr><td><a id="l1449"></a><a href="#l1449">1449</a><td>        if (first == 0x21da) { this.reset(); return this.cm.execCommand(&quot;undo&quot;); }<tr><td><a id="l1450"></a><a href="#l1450">1450</a><td>      }<tr><td><a id="l1451"></a><a href="#l1451">1451</a><td>      // Find the part of the input that is actually new<tr><td><a id="l1452"></a><a href="#l1452">1452</a><td>      var same = 0, l = Math.min(prevInput.length, text.length);<tr><td><a id="l1453"></a><a href="#l1453">1453</a><td>      while (same &lt; l &amp;&amp; prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;<tr><td><a id="l1454"></a><a href="#l1454">1454</a><td><tr><td><a id="l1455"></a><a href="#l1455">1455</a><td>      var self = this;<tr><td><a id="l1456"></a><a href="#l1456">1456</a><td>      runInOp(cm, function() {<tr><td><a id="l1457"></a><a href="#l1457">1457</a><td>        applyTextInput(cm, text.slice(same), prevInput.length - same,<tr><td><a id="l1458"></a><a href="#l1458">1458</a><td>                       null, self.composing ? &quot;*compose&quot; : null);<tr><td><a id="l1459"></a><a href="#l1459">1459</a><td><tr><td><a id="l1460"></a><a href="#l1460">1460</a><td>        // Don&#39;t leave long text in the textarea, since it makes further polling slow<tr><td><a id="l1461"></a><a href="#l1461">1461</a><td>        if (text.length &gt; 1000 || text.indexOf(&quot;\n&quot;) &gt; -1) input.value = self.prevInput = &quot;&quot;;<tr><td><a id="l1462"></a><a href="#l1462">1462</a><td>        else self.prevInput = text;<tr><td><a id="l1463"></a><a href="#l1463">1463</a><td><tr><td><a id="l1464"></a><a href="#l1464">1464</a><td>        if (self.composing) {<tr><td><a id="l1465"></a><a href="#l1465">1465</a><td>          self.composing.range.clear();<tr><td><a id="l1466"></a><a href="#l1466">1466</a><td>          self.composing.range = cm.markText(self.composing.start, cm.getCursor(&quot;to&quot;),<tr><td><a id="l1467"></a><a href="#l1467">1467</a><td>                                             {className: &quot;CodeMirror-composing&quot;});<tr><td><a id="l1468"></a><a href="#l1468">1468</a><td>        }<tr><td><a id="l1469"></a><a href="#l1469">1469</a><td>      });<tr><td><a id="l1470"></a><a href="#l1470">1470</a><td>      return true;<tr><td><a id="l1471"></a><a href="#l1471">1471</a><td>    },<tr><td><a id="l1472"></a><a href="#l1472">1472</a><td><tr><td><a id="l1473"></a><a href="#l1473">1473</a><td>    ensurePolled: function() {<tr><td><a id="l1474"></a><a href="#l1474">1474</a><td>      if (this.pollingFast &amp;&amp; this.poll()) this.pollingFast = false;<tr><td><a id="l1475"></a><a href="#l1475">1475</a><td>    },<tr><td><a id="l1476"></a><a href="#l1476">1476</a><td><tr><td><a id="l1477"></a><a href="#l1477">1477</a><td>    onKeyPress: function() {<tr><td><a id="l1478"></a><a href="#l1478">1478</a><td>      if (ie &amp;&amp; ie_version &gt;= 9) this.hasSelection = null;<tr><td><a id="l1479"></a><a href="#l1479">1479</a><td>      this.fastPoll();<tr><td><a id="l1480"></a><a href="#l1480">1480</a><td>    },<tr><td><a id="l1481"></a><a href="#l1481">1481</a><td><tr><td><a id="l1482"></a><a href="#l1482">1482</a><td>    onContextMenu: function(e) {<tr><td><a id="l1483"></a><a href="#l1483">1483</a><td>      var input = this, cm = input.cm, display = cm.display, te = input.textarea;<tr><td><a id="l1484"></a><a href="#l1484">1484</a><td>      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;<tr><td><a id="l1485"></a><a href="#l1485">1485</a><td>      if (!pos || presto) return; // Opera is difficult.<tr><td><a id="l1486"></a><a href="#l1486">1486</a><td><tr><td><a id="l1487"></a><a href="#l1487">1487</a><td>      // Reset the current text selection only if the click is done outside of the selection<tr><td><a id="l1488"></a><a href="#l1488">1488</a><td>      // and &#39;resetSelectionOnContextMenu&#39; option is true.<tr><td><a id="l1489"></a><a href="#l1489">1489</a><td>      var reset = cm.options.resetSelectionOnContextMenu;<tr><td><a id="l1490"></a><a href="#l1490">1490</a><td>      if (reset &amp;&amp; cm.doc.sel.contains(pos) == -1)<tr><td><a id="l1491"></a><a href="#l1491">1491</a><td>        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);<tr><td><a id="l1492"></a><a href="#l1492">1492</a><td><tr><td><a id="l1493"></a><a href="#l1493">1493</a><td>      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;<tr><td><a id="l1494"></a><a href="#l1494">1494</a><td>      input.wrapper.style.cssText = &quot;position: absolute&quot;<tr><td><a id="l1495"></a><a href="#l1495">1495</a><td>      var wrapperBox = input.wrapper.getBoundingClientRect()<tr><td><a id="l1496"></a><a href="#l1496">1496</a><td>      te.style.cssText = &quot;position: absolute; width: 30px; height: 30px; top: &quot; + (e.clientY - wrapperBox.top - 5) +<tr><td><a id="l1497"></a><a href="#l1497">1497</a><td>        &quot;px; left: &quot; + (e.clientX - wrapperBox.left - 5) + &quot;px; z-index: 1000; background: &quot; +<tr><td><a id="l1498"></a><a href="#l1498">1498</a><td>        (ie ? &quot;rgba(255, 255, 255, .05)&quot; : &quot;transparent&quot;) +<tr><td><a id="l1499"></a><a href="#l1499">1499</a><td>        &quot;; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);&quot;;<tr><td><a id="l1500"></a><a href="#l1500">1500</a><td>      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)<tr><td><a id="l1501"></a><a href="#l1501">1501</a><td>      display.input.focus();<tr><td><a id="l1502"></a><a href="#l1502">1502</a><td>      if (webkit) window.scrollTo(null, oldScrollY);<tr><td><a id="l1503"></a><a href="#l1503">1503</a><td>      display.input.reset();<tr><td><a id="l1504"></a><a href="#l1504">1504</a><td>      // Adds &quot;Select all&quot; to context menu in FF<tr><td><a id="l1505"></a><a href="#l1505">1505</a><td>      if (!cm.somethingSelected()) te.value = input.prevInput = &quot; &quot;;<tr><td><a id="l1506"></a><a href="#l1506">1506</a><td>      input.contextMenuPending = true;<tr><td><a id="l1507"></a><a href="#l1507">1507</a><td>      display.selForContextMenu = cm.doc.sel;<tr><td><a id="l1508"></a><a href="#l1508">1508</a><td>      clearTimeout(display.detectingSelectAll);<tr><td><a id="l1509"></a><a href="#l1509">1509</a><td><tr><td><a id="l1510"></a><a href="#l1510">1510</a><td>      // Select-all will be greyed out if there&#39;s nothing to select, so<tr><td><a id="l1511"></a><a href="#l1511">1511</a><td>      // this adds a zero-width space so that we can later check whether<tr><td><a id="l1512"></a><a href="#l1512">1512</a><td>      // it got selected.<tr><td><a id="l1513"></a><a href="#l1513">1513</a><td>      function prepareSelectAllHack() {<tr><td><a id="l1514"></a><a href="#l1514">1514</a><td>        if (te.selectionStart != null) {<tr><td><a id="l1515"></a><a href="#l1515">1515</a><td>          var selected = cm.somethingSelected();<tr><td><a id="l1516"></a><a href="#l1516">1516</a><td>          var extval = &quot;\u200b&quot; + (selected ? te.value : &quot;&quot;);<tr><td><a id="l1517"></a><a href="#l1517">1517</a><td>          te.value = &quot;\u21da&quot;; // Used to catch context-menu undo<tr><td><a id="l1518"></a><a href="#l1518">1518</a><td>          te.value = extval;<tr><td><a id="l1519"></a><a href="#l1519">1519</a><td>          input.prevInput = selected ? &quot;&quot; : &quot;\u200b&quot;;<tr><td><a id="l1520"></a><a href="#l1520">1520</a><td>          te.selectionStart = 1; te.selectionEnd = extval.length;<tr><td><a id="l1521"></a><a href="#l1521">1521</a><td>          // Re-set this, in case some other handler touched the<tr><td><a id="l1522"></a><a href="#l1522">1522</a><td>          // selection in the meantime.<tr><td><a id="l1523"></a><a href="#l1523">1523</a><td>          display.selForContextMenu = cm.doc.sel;<tr><td><a id="l1524"></a><a href="#l1524">1524</a><td>        }<tr><td><a id="l1525"></a><a href="#l1525">1525</a><td>      }<tr><td><a id="l1526"></a><a href="#l1526">1526</a><td>      function rehide() {<tr><td><a id="l1527"></a><a href="#l1527">1527</a><td>        input.contextMenuPending = false;<tr><td><a id="l1528"></a><a href="#l1528">1528</a><td>        input.wrapper.style.cssText = oldWrapperCSS<tr><td><a id="l1529"></a><a href="#l1529">1529</a><td>        te.style.cssText = oldCSS;<tr><td><a id="l1530"></a><a href="#l1530">1530</a><td>        if (ie &amp;&amp; ie_version &lt; 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);<tr><td><a id="l1531"></a><a href="#l1531">1531</a><td><tr><td><a id="l1532"></a><a href="#l1532">1532</a><td>        // Try to detect the user choosing select-all<tr><td><a id="l1533"></a><a href="#l1533">1533</a><td>        if (te.selectionStart != null) {<tr><td><a id="l1534"></a><a href="#l1534">1534</a><td>          if (!ie || (ie &amp;&amp; ie_version &lt; 9)) prepareSelectAllHack();<tr><td><a id="l1535"></a><a href="#l1535">1535</a><td>          var i = 0, poll = function() {<tr><td><a id="l1536"></a><a href="#l1536">1536</a><td>            if (display.selForContextMenu == cm.doc.sel &amp;&amp; te.selectionStart == 0 &amp;&amp;<tr><td><a id="l1537"></a><a href="#l1537">1537</a><td>                te.selectionEnd &gt; 0 &amp;&amp; input.prevInput == &quot;\u200b&quot;)<tr><td><a id="l1538"></a><a href="#l1538">1538</a><td>              operation(cm, commands.selectAll)(cm);<tr><td><a id="l1539"></a><a href="#l1539">1539</a><td>            else if (i++ &lt; 10) display.detectingSelectAll = setTimeout(poll, 500);<tr><td><a id="l1540"></a><a href="#l1540">1540</a><td>            else display.input.reset();<tr><td><a id="l1541"></a><a href="#l1541">1541</a><td>          };<tr><td><a id="l1542"></a><a href="#l1542">1542</a><td>          display.detectingSelectAll = setTimeout(poll, 200);<tr><td><a id="l1543"></a><a href="#l1543">1543</a><td>        }<tr><td><a id="l1544"></a><a href="#l1544">1544</a><td>      }<tr><td><a id="l1545"></a><a href="#l1545">1545</a><td><tr><td><a id="l1546"></a><a href="#l1546">1546</a><td>      if (ie &amp;&amp; ie_version &gt;= 9) prepareSelectAllHack();<tr><td><a id="l1547"></a><a href="#l1547">1547</a><td>      if (captureRightClick) {<tr><td><a id="l1548"></a><a href="#l1548">1548</a><td>        e_stop(e);<tr><td><a id="l1549"></a><a href="#l1549">1549</a><td>        var mouseup = function() {<tr><td><a id="l1550"></a><a href="#l1550">1550</a><td>          off(window, &quot;mouseup&quot;, mouseup);<tr><td><a id="l1551"></a><a href="#l1551">1551</a><td>          setTimeout(rehide, 20);<tr><td><a id="l1552"></a><a href="#l1552">1552</a><td>        };<tr><td><a id="l1553"></a><a href="#l1553">1553</a><td>        on(window, &quot;mouseup&quot;, mouseup);<tr><td><a id="l1554"></a><a href="#l1554">1554</a><td>      } else {<tr><td><a id="l1555"></a><a href="#l1555">1555</a><td>        setTimeout(rehide, 50);<tr><td><a id="l1556"></a><a href="#l1556">1556</a><td>      }<tr><td><a id="l1557"></a><a href="#l1557">1557</a><td>    },<tr><td><a id="l1558"></a><a href="#l1558">1558</a><td><tr><td><a id="l1559"></a><a href="#l1559">1559</a><td>    readOnlyChanged: function(val) {<tr><td><a id="l1560"></a><a href="#l1560">1560</a><td>      if (!val) this.reset();<tr><td><a id="l1561"></a><a href="#l1561">1561</a><td>    },<tr><td><a id="l1562"></a><a href="#l1562">1562</a><td><tr><td><a id="l1563"></a><a href="#l1563">1563</a><td>    setUneditable: nothing,<tr><td><a id="l1564"></a><a href="#l1564">1564</a><td><tr><td><a id="l1565"></a><a href="#l1565">1565</a><td>    needsContentAttribute: false<tr><td><a id="l1566"></a><a href="#l1566">1566</a><td>  }, TextareaInput.prototype);<tr><td><a id="l1567"></a><a href="#l1567">1567</a><td><tr><td><a id="l1568"></a><a href="#l1568">1568</a><td>  // CONTENTEDITABLE INPUT STYLE<tr><td><a id="l1569"></a><a href="#l1569">1569</a><td><tr><td><a id="l1570"></a><a href="#l1570">1570</a><td>  function ContentEditableInput(cm) {<tr><td><a id="l1571"></a><a href="#l1571">1571</a><td>    this.cm = cm;<tr><td><a id="l1572"></a><a href="#l1572">1572</a><td>    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;<tr><td><a id="l1573"></a><a href="#l1573">1573</a><td>    this.polling = new Delayed();<tr><td><a id="l1574"></a><a href="#l1574">1574</a><td>    this.gracePeriod = false;<tr><td><a id="l1575"></a><a href="#l1575">1575</a><td>  }<tr><td><a id="l1576"></a><a href="#l1576">1576</a><td><tr><td><a id="l1577"></a><a href="#l1577">1577</a><td>  ContentEditableInput.prototype = copyObj({<tr><td><a id="l1578"></a><a href="#l1578">1578</a><td>    init: function(display) {<tr><td><a id="l1579"></a><a href="#l1579">1579</a><td>      var input = this, cm = input.cm;<tr><td><a id="l1580"></a><a href="#l1580">1580</a><td>      var div = input.div = display.lineDiv;<tr><td><a id="l1581"></a><a href="#l1581">1581</a><td>      disableBrowserMagic(div);<tr><td><a id="l1582"></a><a href="#l1582">1582</a><td><tr><td><a id="l1583"></a><a href="#l1583">1583</a><td>      on(div, &quot;paste&quot;, function(e) {<tr><td><a id="l1584"></a><a href="#l1584">1584</a><td>        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);<tr><td><a id="l1585"></a><a href="#l1585">1585</a><td>      })<tr><td><a id="l1586"></a><a href="#l1586">1586</a><td><tr><td><a id="l1587"></a><a href="#l1587">1587</a><td>      on(div, &quot;compositionstart&quot;, function(e) {<tr><td><a id="l1588"></a><a href="#l1588">1588</a><td>        var data = e.data;<tr><td><a id="l1589"></a><a href="#l1589">1589</a><td>        input.composing = {sel: cm.doc.sel, data: data, startData: data};<tr><td><a id="l1590"></a><a href="#l1590">1590</a><td>        if (!data) return;<tr><td><a id="l1591"></a><a href="#l1591">1591</a><td>        var prim = cm.doc.sel.primary();<tr><td><a id="l1592"></a><a href="#l1592">1592</a><td>        var line = cm.getLine(prim.head.line);<tr><td><a id="l1593"></a><a href="#l1593">1593</a><td>        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));<tr><td><a id="l1594"></a><a href="#l1594">1594</a><td>        if (found &gt; -1 &amp;&amp; found &lt;= prim.head.ch)<tr><td><a id="l1595"></a><a href="#l1595">1595</a><td>          input.composing.sel = simpleSelection(Pos(prim.head.line, found),<tr><td><a id="l1596"></a><a href="#l1596">1596</a><td>                                                Pos(prim.head.line, found + data.length));<tr><td><a id="l1597"></a><a href="#l1597">1597</a><td>      });<tr><td><a id="l1598"></a><a href="#l1598">1598</a><td>      on(div, &quot;compositionupdate&quot;, function(e) {<tr><td><a id="l1599"></a><a href="#l1599">1599</a><td>        input.composing.data = e.data;<tr><td><a id="l1600"></a><a href="#l1600">1600</a><td>      });<tr><td><a id="l1601"></a><a href="#l1601">1601</a><td>      on(div, &quot;compositionend&quot;, function(e) {<tr><td><a id="l1602"></a><a href="#l1602">1602</a><td>        var ours = input.composing;<tr><td><a id="l1603"></a><a href="#l1603">1603</a><td>        if (!ours) return;<tr><td><a id="l1604"></a><a href="#l1604">1604</a><td>        if (e.data != ours.startData &amp;&amp; !/\u200b/.test(e.data))<tr><td><a id="l1605"></a><a href="#l1605">1605</a><td>          ours.data = e.data;<tr><td><a id="l1606"></a><a href="#l1606">1606</a><td>        // Need a small delay to prevent other code (input event,<tr><td><a id="l1607"></a><a href="#l1607">1607</a><td>        // selection polling) from doing damage when fired right after<tr><td><a id="l1608"></a><a href="#l1608">1608</a><td>        // compositionend.<tr><td><a id="l1609"></a><a href="#l1609">1609</a><td>        setTimeout(function() {<tr><td><a id="l1610"></a><a href="#l1610">1610</a><td>          if (!ours.handled)<tr><td><a id="l1611"></a><a href="#l1611">1611</a><td>            input.applyComposition(ours);<tr><td><a id="l1612"></a><a href="#l1612">1612</a><td>          if (input.composing == ours)<tr><td><a id="l1613"></a><a href="#l1613">1613</a><td>            input.composing = null;<tr><td><a id="l1614"></a><a href="#l1614">1614</a><td>        }, 50);<tr><td><a id="l1615"></a><a href="#l1615">1615</a><td>      });<tr><td><a id="l1616"></a><a href="#l1616">1616</a><td><tr><td><a id="l1617"></a><a href="#l1617">1617</a><td>      on(div, &quot;touchstart&quot;, function() {<tr><td><a id="l1618"></a><a href="#l1618">1618</a><td>        input.forceCompositionEnd();<tr><td><a id="l1619"></a><a href="#l1619">1619</a><td>      });<tr><td><a id="l1620"></a><a href="#l1620">1620</a><td><tr><td><a id="l1621"></a><a href="#l1621">1621</a><td>      on(div, &quot;input&quot;, function() {<tr><td><a id="l1622"></a><a href="#l1622">1622</a><td>        if (input.composing) return;<tr><td><a id="l1623"></a><a href="#l1623">1623</a><td>        if (cm.isReadOnly() || !input.pollContent())<tr><td><a id="l1624"></a><a href="#l1624">1624</a><td>          runInOp(input.cm, function() {regChange(cm);});<tr><td><a id="l1625"></a><a href="#l1625">1625</a><td>      });<tr><td><a id="l1626"></a><a href="#l1626">1626</a><td><tr><td><a id="l1627"></a><a href="#l1627">1627</a><td>      function onCopyCut(e) {<tr><td><a id="l1628"></a><a href="#l1628">1628</a><td>        if (signalDOMEvent(cm, e)) return<tr><td><a id="l1629"></a><a href="#l1629">1629</a><td>        if (cm.somethingSelected()) {<tr><td><a id="l1630"></a><a href="#l1630">1630</a><td>          lastCopied = {lineWise: false, text: cm.getSelections()};<tr><td><a id="l1631"></a><a href="#l1631">1631</a><td>          if (e.type == &quot;cut&quot;) cm.replaceSelection(&quot;&quot;, null, &quot;cut&quot;);<tr><td><a id="l1632"></a><a href="#l1632">1632</a><td>        } else if (!cm.options.lineWiseCopyCut) {<tr><td><a id="l1633"></a><a href="#l1633">1633</a><td>          return;<tr><td><a id="l1634"></a><a href="#l1634">1634</a><td>        } else {<tr><td><a id="l1635"></a><a href="#l1635">1635</a><td>          var ranges = copyableRanges(cm);<tr><td><a id="l1636"></a><a href="#l1636">1636</a><td>          lastCopied = {lineWise: true, text: ranges.text};<tr><td><a id="l1637"></a><a href="#l1637">1637</a><td>          if (e.type == &quot;cut&quot;) {<tr><td><a id="l1638"></a><a href="#l1638">1638</a><td>            cm.operation(function() {<tr><td><a id="l1639"></a><a href="#l1639">1639</a><td>              cm.setSelections(ranges.ranges, 0, sel_dontScroll);<tr><td><a id="l1640"></a><a href="#l1640">1640</a><td>              cm.replaceSelection(&quot;&quot;, null, &quot;cut&quot;);<tr><td><a id="l1641"></a><a href="#l1641">1641</a><td>            });<tr><td><a id="l1642"></a><a href="#l1642">1642</a><td>          }<tr><td><a id="l1643"></a><a href="#l1643">1643</a><td>        }<tr><td><a id="l1644"></a><a href="#l1644">1644</a><td>        // iOS exposes the clipboard API, but seems to discard content inserted into it<tr><td><a id="l1645"></a><a href="#l1645">1645</a><td>        if (e.clipboardData &amp;&amp; !ios) {<tr><td><a id="l1646"></a><a href="#l1646">1646</a><td>          e.preventDefault();<tr><td><a id="l1647"></a><a href="#l1647">1647</a><td>          e.clipboardData.clearData();<tr><td><a id="l1648"></a><a href="#l1648">1648</a><td>          e.clipboardData.setData(&quot;text/plain&quot;, lastCopied.text.join(&quot;\n&quot;));<tr><td><a id="l1649"></a><a href="#l1649">1649</a><td>        } else {<tr><td><a id="l1650"></a><a href="#l1650">1650</a><td>          // Old-fashioned briefly-focus-a-textarea hack<tr><td><a id="l1651"></a><a href="#l1651">1651</a><td>          var kludge = hiddenTextarea(), te = kludge.firstChild;<tr><td><a id="l1652"></a><a href="#l1652">1652</a><td>          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);<tr><td><a id="l1653"></a><a href="#l1653">1653</a><td>          te.value = lastCopied.text.join(&quot;\n&quot;);<tr><td><a id="l1654"></a><a href="#l1654">1654</a><td>          var hadFocus = document.activeElement;<tr><td><a id="l1655"></a><a href="#l1655">1655</a><td>          selectInput(te);<tr><td><a id="l1656"></a><a href="#l1656">1656</a><td>          setTimeout(function() {<tr><td><a id="l1657"></a><a href="#l1657">1657</a><td>            cm.display.lineSpace.removeChild(kludge);<tr><td><a id="l1658"></a><a href="#l1658">1658</a><td>            hadFocus.focus();<tr><td><a id="l1659"></a><a href="#l1659">1659</a><td>          }, 50);<tr><td><a id="l1660"></a><a href="#l1660">1660</a><td>        }<tr><td><a id="l1661"></a><a href="#l1661">1661</a><td>      }<tr><td><a id="l1662"></a><a href="#l1662">1662</a><td>      on(div, &quot;copy&quot;, onCopyCut);<tr><td><a id="l1663"></a><a href="#l1663">1663</a><td>      on(div, &quot;cut&quot;, onCopyCut);<tr><td><a id="l1664"></a><a href="#l1664">1664</a><td>    },<tr><td><a id="l1665"></a><a href="#l1665">1665</a><td><tr><td><a id="l1666"></a><a href="#l1666">1666</a><td>    prepareSelection: function() {<tr><td><a id="l1667"></a><a href="#l1667">1667</a><td>      var result = prepareSelection(this.cm, false);<tr><td><a id="l1668"></a><a href="#l1668">1668</a><td>      result.focus = this.cm.state.focused;<tr><td><a id="l1669"></a><a href="#l1669">1669</a><td>      return result;<tr><td><a id="l1670"></a><a href="#l1670">1670</a><td>    },<tr><td><a id="l1671"></a><a href="#l1671">1671</a><td><tr><td><a id="l1672"></a><a href="#l1672">1672</a><td>    showSelection: function(info, takeFocus) {<tr><td><a id="l1673"></a><a href="#l1673">1673</a><td>      if (!info || !this.cm.display.view.length) return;<tr><td><a id="l1674"></a><a href="#l1674">1674</a><td>      if (info.focus || takeFocus) this.showPrimarySelection();<tr><td><a id="l1675"></a><a href="#l1675">1675</a><td>      this.showMultipleSelections(info);<tr><td><a id="l1676"></a><a href="#l1676">1676</a><td>    },<tr><td><a id="l1677"></a><a href="#l1677">1677</a><td><tr><td><a id="l1678"></a><a href="#l1678">1678</a><td>    showPrimarySelection: function() {<tr><td><a id="l1679"></a><a href="#l1679">1679</a><td>      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();<tr><td><a id="l1680"></a><a href="#l1680">1680</a><td>      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);<tr><td><a id="l1681"></a><a href="#l1681">1681</a><td>      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);<tr><td><a id="l1682"></a><a href="#l1682">1682</a><td>      if (curAnchor &amp;&amp; !curAnchor.bad &amp;&amp; curFocus &amp;&amp; !curFocus.bad &amp;&amp;<tr><td><a id="l1683"></a><a href="#l1683">1683</a><td>          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &amp;&amp;<tr><td><a id="l1684"></a><a href="#l1684">1684</a><td>          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)<tr><td><a id="l1685"></a><a href="#l1685">1685</a><td>        return;<tr><td><a id="l1686"></a><a href="#l1686">1686</a><td><tr><td><a id="l1687"></a><a href="#l1687">1687</a><td>      var start = posToDOM(this.cm, prim.from());<tr><td><a id="l1688"></a><a href="#l1688">1688</a><td>      var end = posToDOM(this.cm, prim.to());<tr><td><a id="l1689"></a><a href="#l1689">1689</a><td>      if (!start &amp;&amp; !end) return;<tr><td><a id="l1690"></a><a href="#l1690">1690</a><td><tr><td><a id="l1691"></a><a href="#l1691">1691</a><td>      var view = this.cm.display.view;<tr><td><a id="l1692"></a><a href="#l1692">1692</a><td>      var old = sel.rangeCount &amp;&amp; sel.getRangeAt(0);<tr><td><a id="l1693"></a><a href="#l1693">1693</a><td>      if (!start) {<tr><td><a id="l1694"></a><a href="#l1694">1694</a><td>        start = {node: view[0].measure.map[2], offset: 0};<tr><td><a id="l1695"></a><a href="#l1695">1695</a><td>      } else if (!end) { // FIXME dangerously hacky<tr><td><a id="l1696"></a><a href="#l1696">1696</a><td>        var measure = view[view.length - 1].measure;<tr><td><a id="l1697"></a><a href="#l1697">1697</a><td>        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;<tr><td><a id="l1698"></a><a href="#l1698">1698</a><td>        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};<tr><td><a id="l1699"></a><a href="#l1699">1699</a><td>      }<tr><td><a id="l1700"></a><a href="#l1700">1700</a><td><tr><td><a id="l1701"></a><a href="#l1701">1701</a><td>      try { var rng = range(start.node, start.offset, end.offset, end.node); }<tr><td><a id="l1702"></a><a href="#l1702">1702</a><td>      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible<tr><td><a id="l1703"></a><a href="#l1703">1703</a><td>      if (rng) {<tr><td><a id="l1704"></a><a href="#l1704">1704</a><td>        if (!gecko &amp;&amp; this.cm.state.focused) {<tr><td><a id="l1705"></a><a href="#l1705">1705</a><td>          sel.collapse(start.node, start.offset);<tr><td><a id="l1706"></a><a href="#l1706">1706</a><td>          if (!rng.collapsed) sel.addRange(rng);<tr><td><a id="l1707"></a><a href="#l1707">1707</a><td>        } else {<tr><td><a id="l1708"></a><a href="#l1708">1708</a><td>          sel.removeAllRanges();<tr><td><a id="l1709"></a><a href="#l1709">1709</a><td>          sel.addRange(rng);<tr><td><a id="l1710"></a><a href="#l1710">1710</a><td>        }<tr><td><a id="l1711"></a><a href="#l1711">1711</a><td>        if (old &amp;&amp; sel.anchorNode == null) sel.addRange(old);<tr><td><a id="l1712"></a><a href="#l1712">1712</a><td>        else if (gecko) this.startGracePeriod();<tr><td><a id="l1713"></a><a href="#l1713">1713</a><td>      }<tr><td><a id="l1714"></a><a href="#l1714">1714</a><td>      this.rememberSelection();<tr><td><a id="l1715"></a><a href="#l1715">1715</a><td>    },<tr><td><a id="l1716"></a><a href="#l1716">1716</a><td><tr><td><a id="l1717"></a><a href="#l1717">1717</a><td>    startGracePeriod: function() {<tr><td><a id="l1718"></a><a href="#l1718">1718</a><td>      var input = this;<tr><td><a id="l1719"></a><a href="#l1719">1719</a><td>      clearTimeout(this.gracePeriod);<tr><td><a id="l1720"></a><a href="#l1720">1720</a><td>      this.gracePeriod = setTimeout(function() {<tr><td><a id="l1721"></a><a href="#l1721">1721</a><td>        input.gracePeriod = false;<tr><td><a id="l1722"></a><a href="#l1722">1722</a><td>        if (input.selectionChanged())<tr><td><a id="l1723"></a><a href="#l1723">1723</a><td>          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });<tr><td><a id="l1724"></a><a href="#l1724">1724</a><td>      }, 20);<tr><td><a id="l1725"></a><a href="#l1725">1725</a><td>    },<tr><td><a id="l1726"></a><a href="#l1726">1726</a><td><tr><td><a id="l1727"></a><a href="#l1727">1727</a><td>    showMultipleSelections: function(info) {<tr><td><a id="l1728"></a><a href="#l1728">1728</a><td>      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);<tr><td><a id="l1729"></a><a href="#l1729">1729</a><td>      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);<tr><td><a id="l1730"></a><a href="#l1730">1730</a><td>    },<tr><td><a id="l1731"></a><a href="#l1731">1731</a><td><tr><td><a id="l1732"></a><a href="#l1732">1732</a><td>    rememberSelection: function() {<tr><td><a id="l1733"></a><a href="#l1733">1733</a><td>      var sel = window.getSelection();<tr><td><a id="l1734"></a><a href="#l1734">1734</a><td>      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;<tr><td><a id="l1735"></a><a href="#l1735">1735</a><td>      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;<tr><td><a id="l1736"></a><a href="#l1736">1736</a><td>    },<tr><td><a id="l1737"></a><a href="#l1737">1737</a><td><tr><td><a id="l1738"></a><a href="#l1738">1738</a><td>    selectionInEditor: function() {<tr><td><a id="l1739"></a><a href="#l1739">1739</a><td>      var sel = window.getSelection();<tr><td><a id="l1740"></a><a href="#l1740">1740</a><td>      if (!sel.rangeCount) return false;<tr><td><a id="l1741"></a><a href="#l1741">1741</a><td>      var node = sel.getRangeAt(0).commonAncestorContainer;<tr><td><a id="l1742"></a><a href="#l1742">1742</a><td>      return contains(this.div, node);<tr><td><a id="l1743"></a><a href="#l1743">1743</a><td>    },<tr><td><a id="l1744"></a><a href="#l1744">1744</a><td><tr><td><a id="l1745"></a><a href="#l1745">1745</a><td>    focus: function() {<tr><td><a id="l1746"></a><a href="#l1746">1746</a><td>      if (this.cm.options.readOnly != &quot;nocursor&quot;) this.div.focus();<tr><td><a id="l1747"></a><a href="#l1747">1747</a><td>    },<tr><td><a id="l1748"></a><a href="#l1748">1748</a><td>    blur: function() { this.div.blur(); },<tr><td><a id="l1749"></a><a href="#l1749">1749</a><td>    getField: function() { return this.div; },<tr><td><a id="l1750"></a><a href="#l1750">1750</a><td><tr><td><a id="l1751"></a><a href="#l1751">1751</a><td>    supportsTouch: function() { return true; },<tr><td><a id="l1752"></a><a href="#l1752">1752</a><td><tr><td><a id="l1753"></a><a href="#l1753">1753</a><td>    receivedFocus: function() {<tr><td><a id="l1754"></a><a href="#l1754">1754</a><td>      var input = this;<tr><td><a id="l1755"></a><a href="#l1755">1755</a><td>      if (this.selectionInEditor())<tr><td><a id="l1756"></a><a href="#l1756">1756</a><td>        this.pollSelection();<tr><td><a id="l1757"></a><a href="#l1757">1757</a><td>      else<tr><td><a id="l1758"></a><a href="#l1758">1758</a><td>        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });<tr><td><a id="l1759"></a><a href="#l1759">1759</a><td><tr><td><a id="l1760"></a><a href="#l1760">1760</a><td>      function poll() {<tr><td><a id="l1761"></a><a href="#l1761">1761</a><td>        if (input.cm.state.focused) {<tr><td><a id="l1762"></a><a href="#l1762">1762</a><td>          input.pollSelection();<tr><td><a id="l1763"></a><a href="#l1763">1763</a><td>          input.polling.set(input.cm.options.pollInterval, poll);<tr><td><a id="l1764"></a><a href="#l1764">1764</a><td>        }<tr><td><a id="l1765"></a><a href="#l1765">1765</a><td>      }<tr><td><a id="l1766"></a><a href="#l1766">1766</a><td>      this.polling.set(this.cm.options.pollInterval, poll);<tr><td><a id="l1767"></a><a href="#l1767">1767</a><td>    },<tr><td><a id="l1768"></a><a href="#l1768">1768</a><td><tr><td><a id="l1769"></a><a href="#l1769">1769</a><td>    selectionChanged: function() {<tr><td><a id="l1770"></a><a href="#l1770">1770</a><td>      var sel = window.getSelection();<tr><td><a id="l1771"></a><a href="#l1771">1771</a><td>      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||<tr><td><a id="l1772"></a><a href="#l1772">1772</a><td>        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;<tr><td><a id="l1773"></a><a href="#l1773">1773</a><td>    },<tr><td><a id="l1774"></a><a href="#l1774">1774</a><td><tr><td><a id="l1775"></a><a href="#l1775">1775</a><td>    pollSelection: function() {<tr><td><a id="l1776"></a><a href="#l1776">1776</a><td>      if (!this.composing &amp;&amp; !this.gracePeriod &amp;&amp; this.selectionChanged()) {<tr><td><a id="l1777"></a><a href="#l1777">1777</a><td>        var sel = window.getSelection(), cm = this.cm;<tr><td><a id="l1778"></a><a href="#l1778">1778</a><td>        this.rememberSelection();<tr><td><a id="l1779"></a><a href="#l1779">1779</a><td>        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);<tr><td><a id="l1780"></a><a href="#l1780">1780</a><td>        var head = domToPos(cm, sel.focusNode, sel.focusOffset);<tr><td><a id="l1781"></a><a href="#l1781">1781</a><td>        if (anchor &amp;&amp; head) runInOp(cm, function() {<tr><td><a id="l1782"></a><a href="#l1782">1782</a><td>          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);<tr><td><a id="l1783"></a><a href="#l1783">1783</a><td>          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;<tr><td><a id="l1784"></a><a href="#l1784">1784</a><td>        });<tr><td><a id="l1785"></a><a href="#l1785">1785</a><td>      }<tr><td><a id="l1786"></a><a href="#l1786">1786</a><td>    },<tr><td><a id="l1787"></a><a href="#l1787">1787</a><td><tr><td><a id="l1788"></a><a href="#l1788">1788</a><td>    pollContent: function() {<tr><td><a id="l1789"></a><a href="#l1789">1789</a><td>      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();<tr><td><a id="l1790"></a><a href="#l1790">1790</a><td>      var from = sel.from(), to = sel.to();<tr><td><a id="l1791"></a><a href="#l1791">1791</a><td>      if (from.line &lt; display.viewFrom || to.line &gt; display.viewTo - 1) return false;<tr><td><a id="l1792"></a><a href="#l1792">1792</a><td><tr><td><a id="l1793"></a><a href="#l1793">1793</a><td>      var fromIndex;<tr><td><a id="l1794"></a><a href="#l1794">1794</a><td>      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {<tr><td><a id="l1795"></a><a href="#l1795">1795</a><td>        var fromLine = lineNo(display.view[0].line);<tr><td><a id="l1796"></a><a href="#l1796">1796</a><td>        var fromNode = display.view[0].node;<tr><td><a id="l1797"></a><a href="#l1797">1797</a><td>      } else {<tr><td><a id="l1798"></a><a href="#l1798">1798</a><td>        var fromLine = lineNo(display.view[fromIndex].line);<tr><td><a id="l1799"></a><a href="#l1799">1799</a><td>        var fromNode = display.view[fromIndex - 1].node.nextSibling;<tr><td><a id="l1800"></a><a href="#l1800">1800</a><td>      }<tr><td><a id="l1801"></a><a href="#l1801">1801</a><td>      var toIndex = findViewIndex(cm, to.line);<tr><td><a id="l1802"></a><a href="#l1802">1802</a><td>      if (toIndex == display.view.length - 1) {<tr><td><a id="l1803"></a><a href="#l1803">1803</a><td>        var toLine = display.viewTo - 1;<tr><td><a id="l1804"></a><a href="#l1804">1804</a><td>        var toNode = display.lineDiv.lastChild;<tr><td><a id="l1805"></a><a href="#l1805">1805</a><td>      } else {<tr><td><a id="l1806"></a><a href="#l1806">1806</a><td>        var toLine = lineNo(display.view[toIndex + 1].line) - 1;<tr><td><a id="l1807"></a><a href="#l1807">1807</a><td>        var toNode = display.view[toIndex + 1].node.previousSibling;<tr><td><a id="l1808"></a><a href="#l1808">1808</a><td>      }<tr><td><a id="l1809"></a><a href="#l1809">1809</a><td><tr><td><a id="l1810"></a><a href="#l1810">1810</a><td>      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));<tr><td><a id="l1811"></a><a href="#l1811">1811</a><td>      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));<tr><td><a id="l1812"></a><a href="#l1812">1812</a><td>      while (newText.length &gt; 1 &amp;&amp; oldText.length &gt; 1) {<tr><td><a id="l1813"></a><a href="#l1813">1813</a><td>        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }<tr><td><a id="l1814"></a><a href="#l1814">1814</a><td>        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }<tr><td><a id="l1815"></a><a href="#l1815">1815</a><td>        else break;<tr><td><a id="l1816"></a><a href="#l1816">1816</a><td>      }<tr><td><a id="l1817"></a><a href="#l1817">1817</a><td><tr><td><a id="l1818"></a><a href="#l1818">1818</a><td>      var cutFront = 0, cutEnd = 0;<tr><td><a id="l1819"></a><a href="#l1819">1819</a><td>      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);<tr><td><a id="l1820"></a><a href="#l1820">1820</a><td>      while (cutFront &lt; maxCutFront &amp;&amp; newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))<tr><td><a id="l1821"></a><a href="#l1821">1821</a><td>        ++cutFront;<tr><td><a id="l1822"></a><a href="#l1822">1822</a><td>      var newBot = lst(newText), oldBot = lst(oldText);<tr><td><a id="l1823"></a><a href="#l1823">1823</a><td>      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),<tr><td><a id="l1824"></a><a href="#l1824">1824</a><td>                               oldBot.length - (oldText.length == 1 ? cutFront : 0));<tr><td><a id="l1825"></a><a href="#l1825">1825</a><td>      while (cutEnd &lt; maxCutEnd &amp;&amp;<tr><td><a id="l1826"></a><a href="#l1826">1826</a><td>             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))<tr><td><a id="l1827"></a><a href="#l1827">1827</a><td>        ++cutEnd;<tr><td><a id="l1828"></a><a href="#l1828">1828</a><td><tr><td><a id="l1829"></a><a href="#l1829">1829</a><td>      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);<tr><td><a id="l1830"></a><a href="#l1830">1830</a><td>      newText[0] = newText[0].slice(cutFront);<tr><td><a id="l1831"></a><a href="#l1831">1831</a><td><tr><td><a id="l1832"></a><a href="#l1832">1832</a><td>      var chFrom = Pos(fromLine, cutFront);<tr><td><a id="l1833"></a><a href="#l1833">1833</a><td>      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);<tr><td><a id="l1834"></a><a href="#l1834">1834</a><td>      if (newText.length &gt; 1 || newText[0] || cmp(chFrom, chTo)) {<tr><td><a id="l1835"></a><a href="#l1835">1835</a><td>        replaceRange(cm.doc, newText, chFrom, chTo, &quot;+input&quot;);<tr><td><a id="l1836"></a><a href="#l1836">1836</a><td>        return true;<tr><td><a id="l1837"></a><a href="#l1837">1837</a><td>      }<tr><td><a id="l1838"></a><a href="#l1838">1838</a><td>    },<tr><td><a id="l1839"></a><a href="#l1839">1839</a><td><tr><td><a id="l1840"></a><a href="#l1840">1840</a><td>    ensurePolled: function() {<tr><td><a id="l1841"></a><a href="#l1841">1841</a><td>      this.forceCompositionEnd();<tr><td><a id="l1842"></a><a href="#l1842">1842</a><td>    },<tr><td><a id="l1843"></a><a href="#l1843">1843</a><td>    reset: function() {<tr><td><a id="l1844"></a><a href="#l1844">1844</a><td>      this.forceCompositionEnd();<tr><td><a id="l1845"></a><a href="#l1845">1845</a><td>    },<tr><td><a id="l1846"></a><a href="#l1846">1846</a><td>    forceCompositionEnd: function() {<tr><td><a id="l1847"></a><a href="#l1847">1847</a><td>      if (!this.composing || this.composing.handled) return;<tr><td><a id="l1848"></a><a href="#l1848">1848</a><td>      this.applyComposition(this.composing);<tr><td><a id="l1849"></a><a href="#l1849">1849</a><td>      this.composing.handled = true;<tr><td><a id="l1850"></a><a href="#l1850">1850</a><td>      this.div.blur();<tr><td><a id="l1851"></a><a href="#l1851">1851</a><td>      this.div.focus();<tr><td><a id="l1852"></a><a href="#l1852">1852</a><td>    },<tr><td><a id="l1853"></a><a href="#l1853">1853</a><td>    applyComposition: function(composing) {<tr><td><a id="l1854"></a><a href="#l1854">1854</a><td>      if (this.cm.isReadOnly())<tr><td><a id="l1855"></a><a href="#l1855">1855</a><td>        operation(this.cm, regChange)(this.cm)<tr><td><a id="l1856"></a><a href="#l1856">1856</a><td>      else if (composing.data &amp;&amp; composing.data != composing.startData)<tr><td><a id="l1857"></a><a href="#l1857">1857</a><td>        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);<tr><td><a id="l1858"></a><a href="#l1858">1858</a><td>    },<tr><td><a id="l1859"></a><a href="#l1859">1859</a><td><tr><td><a id="l1860"></a><a href="#l1860">1860</a><td>    setUneditable: function(node) {<tr><td><a id="l1861"></a><a href="#l1861">1861</a><td>      node.contentEditable = &quot;false&quot;<tr><td><a id="l1862"></a><a href="#l1862">1862</a><td>    },<tr><td><a id="l1863"></a><a href="#l1863">1863</a><td><tr><td><a id="l1864"></a><a href="#l1864">1864</a><td>    onKeyPress: function(e) {<tr><td><a id="l1865"></a><a href="#l1865">1865</a><td>      e.preventDefault();<tr><td><a id="l1866"></a><a href="#l1866">1866</a><td>      if (!this.cm.isReadOnly())<tr><td><a id="l1867"></a><a href="#l1867">1867</a><td>        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);<tr><td><a id="l1868"></a><a href="#l1868">1868</a><td>    },<tr><td><a id="l1869"></a><a href="#l1869">1869</a><td><tr><td><a id="l1870"></a><a href="#l1870">1870</a><td>    readOnlyChanged: function(val) {<tr><td><a id="l1871"></a><a href="#l1871">1871</a><td>      this.div.contentEditable = String(val != &quot;nocursor&quot;)<tr><td><a id="l1872"></a><a href="#l1872">1872</a><td>    },<tr><td><a id="l1873"></a><a href="#l1873">1873</a><td><tr><td><a id="l1874"></a><a href="#l1874">1874</a><td>    onContextMenu: nothing,<tr><td><a id="l1875"></a><a href="#l1875">1875</a><td>    resetPosition: nothing,<tr><td><a id="l1876"></a><a href="#l1876">1876</a><td><tr><td><a id="l1877"></a><a href="#l1877">1877</a><td>    needsContentAttribute: true<tr><td><a id="l1878"></a><a href="#l1878">1878</a><td>  }, ContentEditableInput.prototype);<tr><td><a id="l1879"></a><a href="#l1879">1879</a><td><tr><td><a id="l1880"></a><a href="#l1880">1880</a><td>  function posToDOM(cm, pos) {<tr><td><a id="l1881"></a><a href="#l1881">1881</a><td>    var view = findViewForLine(cm, pos.line);<tr><td><a id="l1882"></a><a href="#l1882">1882</a><td>    if (!view || view.hidden) return null;<tr><td><a id="l1883"></a><a href="#l1883">1883</a><td>    var line = getLine(cm.doc, pos.line);<tr><td><a id="l1884"></a><a href="#l1884">1884</a><td>    var info = mapFromLineView(view, line, pos.line);<tr><td><a id="l1885"></a><a href="#l1885">1885</a><td><tr><td><a id="l1886"></a><a href="#l1886">1886</a><td>    var order = getOrder(line), side = &quot;left&quot;;<tr><td><a id="l1887"></a><a href="#l1887">1887</a><td>    if (order) {<tr><td><a id="l1888"></a><a href="#l1888">1888</a><td>      var partPos = getBidiPartAt(order, pos.ch);<tr><td><a id="l1889"></a><a href="#l1889">1889</a><td>      side = partPos % 2 ? &quot;right&quot; : &quot;left&quot;;<tr><td><a id="l1890"></a><a href="#l1890">1890</a><td>    }<tr><td><a id="l1891"></a><a href="#l1891">1891</a><td>    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);<tr><td><a id="l1892"></a><a href="#l1892">1892</a><td>    result.offset = result.collapse == &quot;right&quot; ? result.end : result.start;<tr><td><a id="l1893"></a><a href="#l1893">1893</a><td>    return result;<tr><td><a id="l1894"></a><a href="#l1894">1894</a><td>  }<tr><td><a id="l1895"></a><a href="#l1895">1895</a><td><tr><td><a id="l1896"></a><a href="#l1896">1896</a><td>  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }<tr><td><a id="l1897"></a><a href="#l1897">1897</a><td><tr><td><a id="l1898"></a><a href="#l1898">1898</a><td>  function domToPos(cm, node, offset) {<tr><td><a id="l1899"></a><a href="#l1899">1899</a><td>    var lineNode;<tr><td><a id="l1900"></a><a href="#l1900">1900</a><td>    if (node == cm.display.lineDiv) {<tr><td><a id="l1901"></a><a href="#l1901">1901</a><td>      lineNode = cm.display.lineDiv.childNodes[offset];<tr><td><a id="l1902"></a><a href="#l1902">1902</a><td>      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);<tr><td><a id="l1903"></a><a href="#l1903">1903</a><td>      node = null; offset = 0;<tr><td><a id="l1904"></a><a href="#l1904">1904</a><td>    } else {<tr><td><a id="l1905"></a><a href="#l1905">1905</a><td>      for (lineNode = node;; lineNode = lineNode.parentNode) {<tr><td><a id="l1906"></a><a href="#l1906">1906</a><td>        if (!lineNode || lineNode == cm.display.lineDiv) return null;<tr><td><a id="l1907"></a><a href="#l1907">1907</a><td>        if (lineNode.parentNode &amp;&amp; lineNode.parentNode == cm.display.lineDiv) break;<tr><td><a id="l1908"></a><a href="#l1908">1908</a><td>      }<tr><td><a id="l1909"></a><a href="#l1909">1909</a><td>    }<tr><td><a id="l1910"></a><a href="#l1910">1910</a><td>    for (var i = 0; i &lt; cm.display.view.length; i++) {<tr><td><a id="l1911"></a><a href="#l1911">1911</a><td>      var lineView = cm.display.view[i];<tr><td><a id="l1912"></a><a href="#l1912">1912</a><td>      if (lineView.node == lineNode)<tr><td><a id="l1913"></a><a href="#l1913">1913</a><td>        return locateNodeInLineView(lineView, node, offset);<tr><td><a id="l1914"></a><a href="#l1914">1914</a><td>    }<tr><td><a id="l1915"></a><a href="#l1915">1915</a><td>  }<tr><td><a id="l1916"></a><a href="#l1916">1916</a><td><tr><td><a id="l1917"></a><a href="#l1917">1917</a><td>  function locateNodeInLineView(lineView, node, offset) {<tr><td><a id="l1918"></a><a href="#l1918">1918</a><td>    var wrapper = lineView.text.firstChild, bad = false;<tr><td><a id="l1919"></a><a href="#l1919">1919</a><td>    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);<tr><td><a id="l1920"></a><a href="#l1920">1920</a><td>    if (node == wrapper) {<tr><td><a id="l1921"></a><a href="#l1921">1921</a><td>      bad = true;<tr><td><a id="l1922"></a><a href="#l1922">1922</a><td>      node = wrapper.childNodes[offset];<tr><td><a id="l1923"></a><a href="#l1923">1923</a><td>      offset = 0;<tr><td><a id="l1924"></a><a href="#l1924">1924</a><td>      if (!node) {<tr><td><a id="l1925"></a><a href="#l1925">1925</a><td>        var line = lineView.rest ? lst(lineView.rest) : lineView.line;<tr><td><a id="l1926"></a><a href="#l1926">1926</a><td>        return badPos(Pos(lineNo(line), line.text.length), bad);<tr><td><a id="l1927"></a><a href="#l1927">1927</a><td>      }<tr><td><a id="l1928"></a><a href="#l1928">1928</a><td>    }<tr><td><a id="l1929"></a><a href="#l1929">1929</a><td><tr><td><a id="l1930"></a><a href="#l1930">1930</a><td>    var textNode = node.nodeType == 3 ? node : null, topNode = node;<tr><td><a id="l1931"></a><a href="#l1931">1931</a><td>    if (!textNode &amp;&amp; node.childNodes.length == 1 &amp;&amp; node.firstChild.nodeType == 3) {<tr><td><a id="l1932"></a><a href="#l1932">1932</a><td>      textNode = node.firstChild;<tr><td><a id="l1933"></a><a href="#l1933">1933</a><td>      if (offset) offset = textNode.nodeValue.length;<tr><td><a id="l1934"></a><a href="#l1934">1934</a><td>    }<tr><td><a id="l1935"></a><a href="#l1935">1935</a><td>    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;<tr><td><a id="l1936"></a><a href="#l1936">1936</a><td>    var measure = lineView.measure, maps = measure.maps;<tr><td><a id="l1937"></a><a href="#l1937">1937</a><td><tr><td><a id="l1938"></a><a href="#l1938">1938</a><td>    function find(textNode, topNode, offset) {<tr><td><a id="l1939"></a><a href="#l1939">1939</a><td>      for (var i = -1; i &lt; (maps ? maps.length : 0); i++) {<tr><td><a id="l1940"></a><a href="#l1940">1940</a><td>        var map = i &lt; 0 ? measure.map : maps[i];<tr><td><a id="l1941"></a><a href="#l1941">1941</a><td>        for (var j = 0; j &lt; map.length; j += 3) {<tr><td><a id="l1942"></a><a href="#l1942">1942</a><td>          var curNode = map[j + 2];<tr><td><a id="l1943"></a><a href="#l1943">1943</a><td>          if (curNode == textNode || curNode == topNode) {<tr><td><a id="l1944"></a><a href="#l1944">1944</a><td>            var line = lineNo(i &lt; 0 ? lineView.line : lineView.rest[i]);<tr><td><a id="l1945"></a><a href="#l1945">1945</a><td>            var ch = map[j] + offset;<tr><td><a id="l1946"></a><a href="#l1946">1946</a><td>            if (offset &lt; 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];<tr><td><a id="l1947"></a><a href="#l1947">1947</a><td>            return Pos(line, ch);<tr><td><a id="l1948"></a><a href="#l1948">1948</a><td>          }<tr><td><a id="l1949"></a><a href="#l1949">1949</a><td>        }<tr><td><a id="l1950"></a><a href="#l1950">1950</a><td>      }<tr><td><a id="l1951"></a><a href="#l1951">1951</a><td>    }<tr><td><a id="l1952"></a><a href="#l1952">1952</a><td>    var found = find(textNode, topNode, offset);<tr><td><a id="l1953"></a><a href="#l1953">1953</a><td>    if (found) return badPos(found, bad);<tr><td><a id="l1954"></a><a href="#l1954">1954</a><td><tr><td><a id="l1955"></a><a href="#l1955">1955</a><td>    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems<tr><td><a id="l1956"></a><a href="#l1956">1956</a><td>    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {<tr><td><a id="l1957"></a><a href="#l1957">1957</a><td>      found = find(after, after.firstChild, 0);<tr><td><a id="l1958"></a><a href="#l1958">1958</a><td>      if (found)<tr><td><a id="l1959"></a><a href="#l1959">1959</a><td>        return badPos(Pos(found.line, found.ch - dist), bad);<tr><td><a id="l1960"></a><a href="#l1960">1960</a><td>      else<tr><td><a id="l1961"></a><a href="#l1961">1961</a><td>        dist += after.textContent.length;<tr><td><a id="l1962"></a><a href="#l1962">1962</a><td>    }<tr><td><a id="l1963"></a><a href="#l1963">1963</a><td>    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {<tr><td><a id="l1964"></a><a href="#l1964">1964</a><td>      found = find(before, before.firstChild, -1);<tr><td><a id="l1965"></a><a href="#l1965">1965</a><td>      if (found)<tr><td><a id="l1966"></a><a href="#l1966">1966</a><td>        return badPos(Pos(found.line, found.ch + dist), bad);<tr><td><a id="l1967"></a><a href="#l1967">1967</a><td>      else<tr><td><a id="l1968"></a><a href="#l1968">1968</a><td>        dist += after.textContent.length;<tr><td><a id="l1969"></a><a href="#l1969">1969</a><td>    }<tr><td><a id="l1970"></a><a href="#l1970">1970</a><td>  }<tr><td><a id="l1971"></a><a href="#l1971">1971</a><td><tr><td><a id="l1972"></a><a href="#l1972">1972</a><td>  function domTextBetween(cm, from, to, fromLine, toLine) {<tr><td><a id="l1973"></a><a href="#l1973">1973</a><td>    var text = &quot;&quot;, closing = false, lineSep = cm.doc.lineSeparator();<tr><td><a id="l1974"></a><a href="#l1974">1974</a><td>    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }<tr><td><a id="l1975"></a><a href="#l1975">1975</a><td>    function walk(node) {<tr><td><a id="l1976"></a><a href="#l1976">1976</a><td>      if (node.nodeType == 1) {<tr><td><a id="l1977"></a><a href="#l1977">1977</a><td>        var cmText = node.getAttribute(&quot;cm-text&quot;);<tr><td><a id="l1978"></a><a href="#l1978">1978</a><td>        if (cmText != null) {<tr><td><a id="l1979"></a><a href="#l1979">1979</a><td>          if (cmText == &quot;&quot;) cmText = node.textContent.replace(/\u200b/g, &quot;&quot;);<tr><td><a id="l1980"></a><a href="#l1980">1980</a><td>          text += cmText;<tr><td><a id="l1981"></a><a href="#l1981">1981</a><td>          return;<tr><td><a id="l1982"></a><a href="#l1982">1982</a><td>        }<tr><td><a id="l1983"></a><a href="#l1983">1983</a><td>        var markerID = node.getAttribute(&quot;cm-marker&quot;), range;<tr><td><a id="l1984"></a><a href="#l1984">1984</a><td>        if (markerID) {<tr><td><a id="l1985"></a><a href="#l1985">1985</a><td>          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));<tr><td><a id="l1986"></a><a href="#l1986">1986</a><td>          if (found.length &amp;&amp; (range = found[0].find()))<tr><td><a id="l1987"></a><a href="#l1987">1987</a><td>            text += getBetween(cm.doc, range.from, range.to).join(lineSep);<tr><td><a id="l1988"></a><a href="#l1988">1988</a><td>          return;<tr><td><a id="l1989"></a><a href="#l1989">1989</a><td>        }<tr><td><a id="l1990"></a><a href="#l1990">1990</a><td>        if (node.getAttribute(&quot;contenteditable&quot;) == &quot;false&quot;) return;<tr><td><a id="l1991"></a><a href="#l1991">1991</a><td>        for (var i = 0; i &lt; node.childNodes.length; i++)<tr><td><a id="l1992"></a><a href="#l1992">1992</a><td>          walk(node.childNodes[i]);<tr><td><a id="l1993"></a><a href="#l1993">1993</a><td>        if (/^(pre|div|p)$/i.test(node.nodeName))<tr><td><a id="l1994"></a><a href="#l1994">1994</a><td>          closing = true;<tr><td><a id="l1995"></a><a href="#l1995">1995</a><td>      } else if (node.nodeType == 3) {<tr><td><a id="l1996"></a><a href="#l1996">1996</a><td>        var val = node.nodeValue;<tr><td><a id="l1997"></a><a href="#l1997">1997</a><td>        if (!val) return;<tr><td><a id="l1998"></a><a href="#l1998">1998</a><td>        if (closing) {<tr><td><a id="l1999"></a><a href="#l1999">1999</a><td>          text += lineSep;<tr><td><a id="l2000"></a><a href="#l2000">2000</a><td>          closing = false;<tr><td><a id="l2001"></a><a href="#l2001">2001</a><td>        }<tr><td><a id="l2002"></a><a href="#l2002">2002</a><td>        text += val;<tr><td><a id="l2003"></a><a href="#l2003">2003</a><td>      }<tr><td><a id="l2004"></a><a href="#l2004">2004</a><td>    }<tr><td><a id="l2005"></a><a href="#l2005">2005</a><td>    for (;;) {<tr><td><a id="l2006"></a><a href="#l2006">2006</a><td>      walk(from);<tr><td><a id="l2007"></a><a href="#l2007">2007</a><td>      if (from == to) break;<tr><td><a id="l2008"></a><a href="#l2008">2008</a><td>      from = from.nextSibling;<tr><td><a id="l2009"></a><a href="#l2009">2009</a><td>    }<tr><td><a id="l2010"></a><a href="#l2010">2010</a><td>    return text;<tr><td><a id="l2011"></a><a href="#l2011">2011</a><td>  }<tr><td><a id="l2012"></a><a href="#l2012">2012</a><td><tr><td><a id="l2013"></a><a href="#l2013">2013</a><td>  CodeMirror.inputStyles = {&quot;textarea&quot;: TextareaInput, &quot;contenteditable&quot;: ContentEditableInput};<tr><td><a id="l2014"></a><a href="#l2014">2014</a><td><tr><td><a id="l2015"></a><a href="#l2015">2015</a><td>  // SELECTION / CURSOR<tr><td><a id="l2016"></a><a href="#l2016">2016</a><td><tr><td><a id="l2017"></a><a href="#l2017">2017</a><td>  // Selection objects are immutable. A new one is created every time<tr><td><a id="l2018"></a><a href="#l2018">2018</a><td>  // the selection changes. A selection is one or more non-overlapping<tr><td><a id="l2019"></a><a href="#l2019">2019</a><td>  // (and non-touching) ranges, sorted, and an integer that indicates<tr><td><a id="l2020"></a><a href="#l2020">2020</a><td>  // which one is the primary selection (the one that&#39;s scrolled into<tr><td><a id="l2021"></a><a href="#l2021">2021</a><td>  // view, that getCursor returns, etc).<tr><td><a id="l2022"></a><a href="#l2022">2022</a><td>  function Selection(ranges, primIndex) {<tr><td><a id="l2023"></a><a href="#l2023">2023</a><td>    this.ranges = ranges;<tr><td><a id="l2024"></a><a href="#l2024">2024</a><td>    this.primIndex = primIndex;<tr><td><a id="l2025"></a><a href="#l2025">2025</a><td>  }<tr><td><a id="l2026"></a><a href="#l2026">2026</a><td><tr><td><a id="l2027"></a><a href="#l2027">2027</a><td>  Selection.prototype = {<tr><td><a id="l2028"></a><a href="#l2028">2028</a><td>    primary: function() { return this.ranges[this.primIndex]; },<tr><td><a id="l2029"></a><a href="#l2029">2029</a><td>    equals: function(other) {<tr><td><a id="l2030"></a><a href="#l2030">2030</a><td>      if (other == this) return true;<tr><td><a id="l2031"></a><a href="#l2031">2031</a><td>      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;<tr><td><a id="l2032"></a><a href="#l2032">2032</a><td>      for (var i = 0; i &lt; this.ranges.length; i++) {<tr><td><a id="l2033"></a><a href="#l2033">2033</a><td>        var here = this.ranges[i], there = other.ranges[i];<tr><td><a id="l2034"></a><a href="#l2034">2034</a><td>        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;<tr><td><a id="l2035"></a><a href="#l2035">2035</a><td>      }<tr><td><a id="l2036"></a><a href="#l2036">2036</a><td>      return true;<tr><td><a id="l2037"></a><a href="#l2037">2037</a><td>    },<tr><td><a id="l2038"></a><a href="#l2038">2038</a><td>    deepCopy: function() {<tr><td><a id="l2039"></a><a href="#l2039">2039</a><td>      for (var out = [], i = 0; i &lt; this.ranges.length; i++)<tr><td><a id="l2040"></a><a href="#l2040">2040</a><td>        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));<tr><td><a id="l2041"></a><a href="#l2041">2041</a><td>      return new Selection(out, this.primIndex);<tr><td><a id="l2042"></a><a href="#l2042">2042</a><td>    },<tr><td><a id="l2043"></a><a href="#l2043">2043</a><td>    somethingSelected: function() {<tr><td><a id="l2044"></a><a href="#l2044">2044</a><td>      for (var i = 0; i &lt; this.ranges.length; i++)<tr><td><a id="l2045"></a><a href="#l2045">2045</a><td>        if (!this.ranges[i].empty()) return true;<tr><td><a id="l2046"></a><a href="#l2046">2046</a><td>      return false;<tr><td><a id="l2047"></a><a href="#l2047">2047</a><td>    },<tr><td><a id="l2048"></a><a href="#l2048">2048</a><td>    contains: function(pos, end) {<tr><td><a id="l2049"></a><a href="#l2049">2049</a><td>      if (!end) end = pos;<tr><td><a id="l2050"></a><a href="#l2050">2050</a><td>      for (var i = 0; i &lt; this.ranges.length; i++) {<tr><td><a id="l2051"></a><a href="#l2051">2051</a><td>        var range = this.ranges[i];<tr><td><a id="l2052"></a><a href="#l2052">2052</a><td>        if (cmp(end, range.from()) &gt;= 0 &amp;&amp; cmp(pos, range.to()) &lt;= 0)<tr><td><a id="l2053"></a><a href="#l2053">2053</a><td>          return i;<tr><td><a id="l2054"></a><a href="#l2054">2054</a><td>      }<tr><td><a id="l2055"></a><a href="#l2055">2055</a><td>      return -1;<tr><td><a id="l2056"></a><a href="#l2056">2056</a><td>    }<tr><td><a id="l2057"></a><a href="#l2057">2057</a><td>  };<tr><td><a id="l2058"></a><a href="#l2058">2058</a><td><tr><td><a id="l2059"></a><a href="#l2059">2059</a><td>  function Range(anchor, head) {<tr><td><a id="l2060"></a><a href="#l2060">2060</a><td>    this.anchor = anchor; this.head = head;<tr><td><a id="l2061"></a><a href="#l2061">2061</a><td>  }<tr><td><a id="l2062"></a><a href="#l2062">2062</a><td><tr><td><a id="l2063"></a><a href="#l2063">2063</a><td>  Range.prototype = {<tr><td><a id="l2064"></a><a href="#l2064">2064</a><td>    from: function() { return minPos(this.anchor, this.head); },<tr><td><a id="l2065"></a><a href="#l2065">2065</a><td>    to: function() { return maxPos(this.anchor, this.head); },<tr><td><a id="l2066"></a><a href="#l2066">2066</a><td>    empty: function() {<tr><td><a id="l2067"></a><a href="#l2067">2067</a><td>      return this.head.line == this.anchor.line &amp;&amp; this.head.ch == this.anchor.ch;<tr><td><a id="l2068"></a><a href="#l2068">2068</a><td>    }<tr><td><a id="l2069"></a><a href="#l2069">2069</a><td>  };<tr><td><a id="l2070"></a><a href="#l2070">2070</a><td><tr><td><a id="l2071"></a><a href="#l2071">2071</a><td>  // Take an unsorted, potentially overlapping set of ranges, and<tr><td><a id="l2072"></a><a href="#l2072">2072</a><td>  // build a selection out of it. &#39;Consumes&#39; ranges array (modifying<tr><td><a id="l2073"></a><a href="#l2073">2073</a><td>  // it).<tr><td><a id="l2074"></a><a href="#l2074">2074</a><td>  function normalizeSelection(ranges, primIndex) {<tr><td><a id="l2075"></a><a href="#l2075">2075</a><td>    var prim = ranges[primIndex];<tr><td><a id="l2076"></a><a href="#l2076">2076</a><td>    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });<tr><td><a id="l2077"></a><a href="#l2077">2077</a><td>    primIndex = indexOf(ranges, prim);<tr><td><a id="l2078"></a><a href="#l2078">2078</a><td>    for (var i = 1; i &lt; ranges.length; i++) {<tr><td><a id="l2079"></a><a href="#l2079">2079</a><td>      var cur = ranges[i], prev = ranges[i - 1];<tr><td><a id="l2080"></a><a href="#l2080">2080</a><td>      if (cmp(prev.to(), cur.from()) &gt;= 0) {<tr><td><a id="l2081"></a><a href="#l2081">2081</a><td>        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());<tr><td><a id="l2082"></a><a href="#l2082">2082</a><td>        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;<tr><td><a id="l2083"></a><a href="#l2083">2083</a><td>        if (i &lt;= primIndex) --primIndex;<tr><td><a id="l2084"></a><a href="#l2084">2084</a><td>        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));<tr><td><a id="l2085"></a><a href="#l2085">2085</a><td>      }<tr><td><a id="l2086"></a><a href="#l2086">2086</a><td>    }<tr><td><a id="l2087"></a><a href="#l2087">2087</a><td>    return new Selection(ranges, primIndex);<tr><td><a id="l2088"></a><a href="#l2088">2088</a><td>  }<tr><td><a id="l2089"></a><a href="#l2089">2089</a><td><tr><td><a id="l2090"></a><a href="#l2090">2090</a><td>  function simpleSelection(anchor, head) {<tr><td><a id="l2091"></a><a href="#l2091">2091</a><td>    return new Selection([new Range(anchor, head || anchor)], 0);<tr><td><a id="l2092"></a><a href="#l2092">2092</a><td>  }<tr><td><a id="l2093"></a><a href="#l2093">2093</a><td><tr><td><a id="l2094"></a><a href="#l2094">2094</a><td>  // Most of the external API clips given positions to make sure they<tr><td><a id="l2095"></a><a href="#l2095">2095</a><td>  // actually exist within the document.<tr><td><a id="l2096"></a><a href="#l2096">2096</a><td>  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}<tr><td><a id="l2097"></a><a href="#l2097">2097</a><td>  function clipPos(doc, pos) {<tr><td><a id="l2098"></a><a href="#l2098">2098</a><td>    if (pos.line &lt; doc.first) return Pos(doc.first, 0);<tr><td><a id="l2099"></a><a href="#l2099">2099</a><td>    var last = doc.first + doc.size - 1;<tr><td><a id="l2100"></a><a href="#l2100">2100</a><td>    if (pos.line &gt; last) return Pos(last, getLine(doc, last).text.length);<tr><td><a id="l2101"></a><a href="#l2101">2101</a><td>    return clipToLen(pos, getLine(doc, pos.line).text.length);<tr><td><a id="l2102"></a><a href="#l2102">2102</a><td>  }<tr><td><a id="l2103"></a><a href="#l2103">2103</a><td>  function clipToLen(pos, linelen) {<tr><td><a id="l2104"></a><a href="#l2104">2104</a><td>    var ch = pos.ch;<tr><td><a id="l2105"></a><a href="#l2105">2105</a><td>    if (ch == null || ch &gt; linelen) return Pos(pos.line, linelen);<tr><td><a id="l2106"></a><a href="#l2106">2106</a><td>    else if (ch &lt; 0) return Pos(pos.line, 0);<tr><td><a id="l2107"></a><a href="#l2107">2107</a><td>    else return pos;<tr><td><a id="l2108"></a><a href="#l2108">2108</a><td>  }<tr><td><a id="l2109"></a><a href="#l2109">2109</a><td>  function isLine(doc, l) {return l &gt;= doc.first &amp;&amp; l &lt; doc.first + doc.size;}<tr><td><a id="l2110"></a><a href="#l2110">2110</a><td>  function clipPosArray(doc, array) {<tr><td><a id="l2111"></a><a href="#l2111">2111</a><td>    for (var out = [], i = 0; i &lt; array.length; i++) out[i] = clipPos(doc, array[i]);<tr><td><a id="l2112"></a><a href="#l2112">2112</a><td>    return out;<tr><td><a id="l2113"></a><a href="#l2113">2113</a><td>  }<tr><td><a id="l2114"></a><a href="#l2114">2114</a><td><tr><td><a id="l2115"></a><a href="#l2115">2115</a><td>  // SELECTION UPDATES<tr><td><a id="l2116"></a><a href="#l2116">2116</a><td><tr><td><a id="l2117"></a><a href="#l2117">2117</a><td>  // The &#39;scroll&#39; parameter given to many of these indicated whether<tr><td><a id="l2118"></a><a href="#l2118">2118</a><td>  // the new cursor position should be scrolled into view after<tr><td><a id="l2119"></a><a href="#l2119">2119</a><td>  // modifying the selection.<tr><td><a id="l2120"></a><a href="#l2120">2120</a><td><tr><td><a id="l2121"></a><a href="#l2121">2121</a><td>  // If shift is held or the extend flag is set, extends a range to<tr><td><a id="l2122"></a><a href="#l2122">2122</a><td>  // include a given position (and optionally a second position).<tr><td><a id="l2123"></a><a href="#l2123">2123</a><td>  // Otherwise, simply returns the range between the given positions.<tr><td><a id="l2124"></a><a href="#l2124">2124</a><td>  // Used for cursor motion and such.<tr><td><a id="l2125"></a><a href="#l2125">2125</a><td>  function extendRange(doc, range, head, other) {<tr><td><a id="l2126"></a><a href="#l2126">2126</a><td>    if (doc.cm &amp;&amp; doc.cm.display.shift || doc.extend) {<tr><td><a id="l2127"></a><a href="#l2127">2127</a><td>      var anchor = range.anchor;<tr><td><a id="l2128"></a><a href="#l2128">2128</a><td>      if (other) {<tr><td><a id="l2129"></a><a href="#l2129">2129</a><td>        var posBefore = cmp(head, anchor) &lt; 0;<tr><td><a id="l2130"></a><a href="#l2130">2130</a><td>        if (posBefore != (cmp(other, anchor) &lt; 0)) {<tr><td><a id="l2131"></a><a href="#l2131">2131</a><td>          anchor = head;<tr><td><a id="l2132"></a><a href="#l2132">2132</a><td>          head = other;<tr><td><a id="l2133"></a><a href="#l2133">2133</a><td>        } else if (posBefore != (cmp(head, other) &lt; 0)) {<tr><td><a id="l2134"></a><a href="#l2134">2134</a><td>          head = other;<tr><td><a id="l2135"></a><a href="#l2135">2135</a><td>        }<tr><td><a id="l2136"></a><a href="#l2136">2136</a><td>      }<tr><td><a id="l2137"></a><a href="#l2137">2137</a><td>      return new Range(anchor, head);<tr><td><a id="l2138"></a><a href="#l2138">2138</a><td>    } else {<tr><td><a id="l2139"></a><a href="#l2139">2139</a><td>      return new Range(other || head, head);<tr><td><a id="l2140"></a><a href="#l2140">2140</a><td>    }<tr><td><a id="l2141"></a><a href="#l2141">2141</a><td>  }<tr><td><a id="l2142"></a><a href="#l2142">2142</a><td><tr><td><a id="l2143"></a><a href="#l2143">2143</a><td>  // Extend the primary selection range, discard the rest.<tr><td><a id="l2144"></a><a href="#l2144">2144</a><td>  function extendSelection(doc, head, other, options) {<tr><td><a id="l2145"></a><a href="#l2145">2145</a><td>    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);<tr><td><a id="l2146"></a><a href="#l2146">2146</a><td>  }<tr><td><a id="l2147"></a><a href="#l2147">2147</a><td><tr><td><a id="l2148"></a><a href="#l2148">2148</a><td>  // Extend all selections (pos is an array of selections with length<tr><td><a id="l2149"></a><a href="#l2149">2149</a><td>  // equal the number of selections)<tr><td><a id="l2150"></a><a href="#l2150">2150</a><td>  function extendSelections(doc, heads, options) {<tr><td><a id="l2151"></a><a href="#l2151">2151</a><td>    for (var out = [], i = 0; i &lt; doc.sel.ranges.length; i++)<tr><td><a id="l2152"></a><a href="#l2152">2152</a><td>      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);<tr><td><a id="l2153"></a><a href="#l2153">2153</a><td>    var newSel = normalizeSelection(out, doc.sel.primIndex);<tr><td><a id="l2154"></a><a href="#l2154">2154</a><td>    setSelection(doc, newSel, options);<tr><td><a id="l2155"></a><a href="#l2155">2155</a><td>  }<tr><td><a id="l2156"></a><a href="#l2156">2156</a><td><tr><td><a id="l2157"></a><a href="#l2157">2157</a><td>  // Updates a single range in the selection.<tr><td><a id="l2158"></a><a href="#l2158">2158</a><td>  function replaceOneSelection(doc, i, range, options) {<tr><td><a id="l2159"></a><a href="#l2159">2159</a><td>    var ranges = doc.sel.ranges.slice(0);<tr><td><a id="l2160"></a><a href="#l2160">2160</a><td>    ranges[i] = range;<tr><td><a id="l2161"></a><a href="#l2161">2161</a><td>    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);<tr><td><a id="l2162"></a><a href="#l2162">2162</a><td>  }<tr><td><a id="l2163"></a><a href="#l2163">2163</a><td><tr><td><a id="l2164"></a><a href="#l2164">2164</a><td>  // Reset the selection to a single range.<tr><td><a id="l2165"></a><a href="#l2165">2165</a><td>  function setSimpleSelection(doc, anchor, head, options) {<tr><td><a id="l2166"></a><a href="#l2166">2166</a><td>    setSelection(doc, simpleSelection(anchor, head), options);<tr><td><a id="l2167"></a><a href="#l2167">2167</a><td>  }<tr><td><a id="l2168"></a><a href="#l2168">2168</a><td><tr><td><a id="l2169"></a><a href="#l2169">2169</a><td>  // Give beforeSelectionChange handlers a change to influence a<tr><td><a id="l2170"></a><a href="#l2170">2170</a><td>  // selection update.<tr><td><a id="l2171"></a><a href="#l2171">2171</a><td>  function filterSelectionChange(doc, sel, options) {<tr><td><a id="l2172"></a><a href="#l2172">2172</a><td>    var obj = {<tr><td><a id="l2173"></a><a href="#l2173">2173</a><td>      ranges: sel.ranges,<tr><td><a id="l2174"></a><a href="#l2174">2174</a><td>      update: function(ranges) {<tr><td><a id="l2175"></a><a href="#l2175">2175</a><td>        this.ranges = [];<tr><td><a id="l2176"></a><a href="#l2176">2176</a><td>        for (var i = 0; i &lt; ranges.length; i++)<tr><td><a id="l2177"></a><a href="#l2177">2177</a><td>          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),<tr><td><a id="l2178"></a><a href="#l2178">2178</a><td>                                     clipPos(doc, ranges[i].head));<tr><td><a id="l2179"></a><a href="#l2179">2179</a><td>      },<tr><td><a id="l2180"></a><a href="#l2180">2180</a><td>      origin: options &amp;&amp; options.origin<tr><td><a id="l2181"></a><a href="#l2181">2181</a><td>    };<tr><td><a id="l2182"></a><a href="#l2182">2182</a><td>    signal(doc, &quot;beforeSelectionChange&quot;, doc, obj);<tr><td><a id="l2183"></a><a href="#l2183">2183</a><td>    if (doc.cm) signal(doc.cm, &quot;beforeSelectionChange&quot;, doc.cm, obj);<tr><td><a id="l2184"></a><a href="#l2184">2184</a><td>    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);<tr><td><a id="l2185"></a><a href="#l2185">2185</a><td>    else return sel;<tr><td><a id="l2186"></a><a href="#l2186">2186</a><td>  }<tr><td><a id="l2187"></a><a href="#l2187">2187</a><td><tr><td><a id="l2188"></a><a href="#l2188">2188</a><td>  function setSelectionReplaceHistory(doc, sel, options) {<tr><td><a id="l2189"></a><a href="#l2189">2189</a><td>    var done = doc.history.done, last = lst(done);<tr><td><a id="l2190"></a><a href="#l2190">2190</a><td>    if (last &amp;&amp; last.ranges) {<tr><td><a id="l2191"></a><a href="#l2191">2191</a><td>      done[done.length - 1] = sel;<tr><td><a id="l2192"></a><a href="#l2192">2192</a><td>      setSelectionNoUndo(doc, sel, options);<tr><td><a id="l2193"></a><a href="#l2193">2193</a><td>    } else {<tr><td><a id="l2194"></a><a href="#l2194">2194</a><td>      setSelection(doc, sel, options);<tr><td><a id="l2195"></a><a href="#l2195">2195</a><td>    }<tr><td><a id="l2196"></a><a href="#l2196">2196</a><td>  }<tr><td><a id="l2197"></a><a href="#l2197">2197</a><td><tr><td><a id="l2198"></a><a href="#l2198">2198</a><td>  // Set a new selection.<tr><td><a id="l2199"></a><a href="#l2199">2199</a><td>  function setSelection(doc, sel, options) {<tr><td><a id="l2200"></a><a href="#l2200">2200</a><td>    setSelectionNoUndo(doc, sel, options);<tr><td><a id="l2201"></a><a href="#l2201">2201</a><td>    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);<tr><td><a id="l2202"></a><a href="#l2202">2202</a><td>  }<tr><td><a id="l2203"></a><a href="#l2203">2203</a><td><tr><td><a id="l2204"></a><a href="#l2204">2204</a><td>  function setSelectionNoUndo(doc, sel, options) {<tr><td><a id="l2205"></a><a href="#l2205">2205</a><td>    if (hasHandler(doc, &quot;beforeSelectionChange&quot;) || doc.cm &amp;&amp; hasHandler(doc.cm, &quot;beforeSelectionChange&quot;))<tr><td><a id="l2206"></a><a href="#l2206">2206</a><td>      sel = filterSelectionChange(doc, sel, options);<tr><td><a id="l2207"></a><a href="#l2207">2207</a><td><tr><td><a id="l2208"></a><a href="#l2208">2208</a><td>    var bias = options &amp;&amp; options.bias ||<tr><td><a id="l2209"></a><a href="#l2209">2209</a><td>      (cmp(sel.primary().head, doc.sel.primary().head) &lt; 0 ? -1 : 1);<tr><td><a id="l2210"></a><a href="#l2210">2210</a><td>    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));<tr><td><a id="l2211"></a><a href="#l2211">2211</a><td><tr><td><a id="l2212"></a><a href="#l2212">2212</a><td>    if (!(options &amp;&amp; options.scroll === false) &amp;&amp; doc.cm)<tr><td><a id="l2213"></a><a href="#l2213">2213</a><td>      ensureCursorVisible(doc.cm);<tr><td><a id="l2214"></a><a href="#l2214">2214</a><td>  }<tr><td><a id="l2215"></a><a href="#l2215">2215</a><td><tr><td><a id="l2216"></a><a href="#l2216">2216</a><td>  function setSelectionInner(doc, sel) {<tr><td><a id="l2217"></a><a href="#l2217">2217</a><td>    if (sel.equals(doc.sel)) return;<tr><td><a id="l2218"></a><a href="#l2218">2218</a><td><tr><td><a id="l2219"></a><a href="#l2219">2219</a><td>    doc.sel = sel;<tr><td><a id="l2220"></a><a href="#l2220">2220</a><td><tr><td><a id="l2221"></a><a href="#l2221">2221</a><td>    if (doc.cm) {<tr><td><a id="l2222"></a><a href="#l2222">2222</a><td>      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;<tr><td><a id="l2223"></a><a href="#l2223">2223</a><td>      signalCursorActivity(doc.cm);<tr><td><a id="l2224"></a><a href="#l2224">2224</a><td>    }<tr><td><a id="l2225"></a><a href="#l2225">2225</a><td>    signalLater(doc, &quot;cursorActivity&quot;, doc);<tr><td><a id="l2226"></a><a href="#l2226">2226</a><td>  }<tr><td><a id="l2227"></a><a href="#l2227">2227</a><td><tr><td><a id="l2228"></a><a href="#l2228">2228</a><td>  // Verify that the selection does not partially select any atomic<tr><td><a id="l2229"></a><a href="#l2229">2229</a><td>  // marked ranges.<tr><td><a id="l2230"></a><a href="#l2230">2230</a><td>  function reCheckSelection(doc) {<tr><td><a id="l2231"></a><a href="#l2231">2231</a><td>    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);<tr><td><a id="l2232"></a><a href="#l2232">2232</a><td>  }<tr><td><a id="l2233"></a><a href="#l2233">2233</a><td><tr><td><a id="l2234"></a><a href="#l2234">2234</a><td>  // Return a selection that does not partially select any atomic<tr><td><a id="l2235"></a><a href="#l2235">2235</a><td>  // ranges.<tr><td><a id="l2236"></a><a href="#l2236">2236</a><td>  function skipAtomicInSelection(doc, sel, bias, mayClear) {<tr><td><a id="l2237"></a><a href="#l2237">2237</a><td>    var out;<tr><td><a id="l2238"></a><a href="#l2238">2238</a><td>    for (var i = 0; i &lt; sel.ranges.length; i++) {<tr><td><a id="l2239"></a><a href="#l2239">2239</a><td>      var range = sel.ranges[i];<tr><td><a id="l2240"></a><a href="#l2240">2240</a><td>      var old = sel.ranges.length == doc.sel.ranges.length &amp;&amp; doc.sel.ranges[i];<tr><td><a id="l2241"></a><a href="#l2241">2241</a><td>      var newAnchor = skipAtomic(doc, range.anchor, old &amp;&amp; old.anchor, bias, mayClear);<tr><td><a id="l2242"></a><a href="#l2242">2242</a><td>      var newHead = skipAtomic(doc, range.head, old &amp;&amp; old.head, bias, mayClear);<tr><td><a id="l2243"></a><a href="#l2243">2243</a><td>      if (out || newAnchor != range.anchor || newHead != range.head) {<tr><td><a id="l2244"></a><a href="#l2244">2244</a><td>        if (!out) out = sel.ranges.slice(0, i);<tr><td><a id="l2245"></a><a href="#l2245">2245</a><td>        out[i] = new Range(newAnchor, newHead);<tr><td><a id="l2246"></a><a href="#l2246">2246</a><td>      }<tr><td><a id="l2247"></a><a href="#l2247">2247</a><td>    }<tr><td><a id="l2248"></a><a href="#l2248">2248</a><td>    return out ? normalizeSelection(out, sel.primIndex) : sel;<tr><td><a id="l2249"></a><a href="#l2249">2249</a><td>  }<tr><td><a id="l2250"></a><a href="#l2250">2250</a><td><tr><td><a id="l2251"></a><a href="#l2251">2251</a><td>  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {<tr><td><a id="l2252"></a><a href="#l2252">2252</a><td>    var line = getLine(doc, pos.line);<tr><td><a id="l2253"></a><a href="#l2253">2253</a><td>    if (line.markedSpans) for (var i = 0; i &lt; line.markedSpans.length; ++i) {<tr><td><a id="l2254"></a><a href="#l2254">2254</a><td>      var sp = line.markedSpans[i], m = sp.marker;<tr><td><a id="l2255"></a><a href="#l2255">2255</a><td>      if ((sp.from == null || (m.inclusiveLeft ? sp.from &lt;= pos.ch : sp.from &lt; pos.ch)) &amp;&amp;<tr><td><a id="l2256"></a><a href="#l2256">2256</a><td>          (sp.to == null || (m.inclusiveRight ? sp.to &gt;= pos.ch : sp.to &gt; pos.ch))) {<tr><td><a id="l2257"></a><a href="#l2257">2257</a><td>        if (mayClear) {<tr><td><a id="l2258"></a><a href="#l2258">2258</a><td>          signal(m, &quot;beforeCursorEnter&quot;);<tr><td><a id="l2259"></a><a href="#l2259">2259</a><td>          if (m.explicitlyCleared) {<tr><td><a id="l2260"></a><a href="#l2260">2260</a><td>            if (!line.markedSpans) break;<tr><td><a id="l2261"></a><a href="#l2261">2261</a><td>            else {--i; continue;}<tr><td><a id="l2262"></a><a href="#l2262">2262</a><td>          }<tr><td><a id="l2263"></a><a href="#l2263">2263</a><td>        }<tr><td><a id="l2264"></a><a href="#l2264">2264</a><td>        if (!m.atomic) continue;<tr><td><a id="l2265"></a><a href="#l2265">2265</a><td><tr><td><a id="l2266"></a><a href="#l2266">2266</a><td>        if (oldPos) {<tr><td><a id="l2267"></a><a href="#l2267">2267</a><td>          var near = m.find(dir &lt; 0 ? 1 : -1), diff;<tr><td><a id="l2268"></a><a href="#l2268">2268</a><td>          if (dir &lt; 0 ? m.inclusiveRight : m.inclusiveLeft)<tr><td><a id="l2269"></a><a href="#l2269">2269</a><td>            near = movePos(doc, near, -dir, near &amp;&amp; near.line == pos.line ? line : null);<tr><td><a id="l2270"></a><a href="#l2270">2270</a><td>          if (near &amp;&amp; near.line == pos.line &amp;&amp; (diff = cmp(near, oldPos)) &amp;&amp; (dir &lt; 0 ? diff &lt; 0 : diff &gt; 0))<tr><td><a id="l2271"></a><a href="#l2271">2271</a><td>            return skipAtomicInner(doc, near, pos, dir, mayClear);<tr><td><a id="l2272"></a><a href="#l2272">2272</a><td>        }<tr><td><a id="l2273"></a><a href="#l2273">2273</a><td><tr><td><a id="l2274"></a><a href="#l2274">2274</a><td>        var far = m.find(dir &lt; 0 ? -1 : 1);<tr><td><a id="l2275"></a><a href="#l2275">2275</a><td>        if (dir &lt; 0 ? m.inclusiveLeft : m.inclusiveRight)<tr><td><a id="l2276"></a><a href="#l2276">2276</a><td>          far = movePos(doc, far, dir, far.line == pos.line ? line : null);<tr><td><a id="l2277"></a><a href="#l2277">2277</a><td>        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;<tr><td><a id="l2278"></a><a href="#l2278">2278</a><td>      }<tr><td><a id="l2279"></a><a href="#l2279">2279</a><td>    }<tr><td><a id="l2280"></a><a href="#l2280">2280</a><td>    return pos;<tr><td><a id="l2281"></a><a href="#l2281">2281</a><td>  }<tr><td><a id="l2282"></a><a href="#l2282">2282</a><td><tr><td><a id="l2283"></a><a href="#l2283">2283</a><td>  // Ensure a given position is not inside an atomic range.<tr><td><a id="l2284"></a><a href="#l2284">2284</a><td>  function skipAtomic(doc, pos, oldPos, bias, mayClear) {<tr><td><a id="l2285"></a><a href="#l2285">2285</a><td>    var dir = bias || 1;<tr><td><a id="l2286"></a><a href="#l2286">2286</a><td>    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||<tr><td><a id="l2287"></a><a href="#l2287">2287</a><td>        (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, dir, true)) ||<tr><td><a id="l2288"></a><a href="#l2288">2288</a><td>        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||<tr><td><a id="l2289"></a><a href="#l2289">2289</a><td>        (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, -dir, true));<tr><td><a id="l2290"></a><a href="#l2290">2290</a><td>    if (!found) {<tr><td><a id="l2291"></a><a href="#l2291">2291</a><td>      doc.cantEdit = true;<tr><td><a id="l2292"></a><a href="#l2292">2292</a><td>      return Pos(doc.first, 0);<tr><td><a id="l2293"></a><a href="#l2293">2293</a><td>    }<tr><td><a id="l2294"></a><a href="#l2294">2294</a><td>    return found;<tr><td><a id="l2295"></a><a href="#l2295">2295</a><td>  }<tr><td><a id="l2296"></a><a href="#l2296">2296</a><td><tr><td><a id="l2297"></a><a href="#l2297">2297</a><td>  function movePos(doc, pos, dir, line) {<tr><td><a id="l2298"></a><a href="#l2298">2298</a><td>    if (dir &lt; 0 &amp;&amp; pos.ch == 0) {<tr><td><a id="l2299"></a><a href="#l2299">2299</a><td>      if (pos.line &gt; doc.first) return clipPos(doc, Pos(pos.line - 1));<tr><td><a id="l2300"></a><a href="#l2300">2300</a><td>      else return null;<tr><td><a id="l2301"></a><a href="#l2301">2301</a><td>    } else if (dir &gt; 0 &amp;&amp; pos.ch == (line || getLine(doc, pos.line)).text.length) {<tr><td><a id="l2302"></a><a href="#l2302">2302</a><td>      if (pos.line &lt; doc.first + doc.size - 1) return Pos(pos.line + 1, 0);<tr><td><a id="l2303"></a><a href="#l2303">2303</a><td>      else return null;<tr><td><a id="l2304"></a><a href="#l2304">2304</a><td>    } else {<tr><td><a id="l2305"></a><a href="#l2305">2305</a><td>      return new Pos(pos.line, pos.ch + dir);<tr><td><a id="l2306"></a><a href="#l2306">2306</a><td>    }<tr><td><a id="l2307"></a><a href="#l2307">2307</a><td>  }<tr><td><a id="l2308"></a><a href="#l2308">2308</a><td><tr><td><a id="l2309"></a><a href="#l2309">2309</a><td>  // SELECTION DRAWING<tr><td><a id="l2310"></a><a href="#l2310">2310</a><td><tr><td><a id="l2311"></a><a href="#l2311">2311</a><td>  function updateSelection(cm) {<tr><td><a id="l2312"></a><a href="#l2312">2312</a><td>    cm.display.input.showSelection(cm.display.input.prepareSelection());<tr><td><a id="l2313"></a><a href="#l2313">2313</a><td>  }<tr><td><a id="l2314"></a><a href="#l2314">2314</a><td><tr><td><a id="l2315"></a><a href="#l2315">2315</a><td>  function prepareSelection(cm, primary) {<tr><td><a id="l2316"></a><a href="#l2316">2316</a><td>    var doc = cm.doc, result = {};<tr><td><a id="l2317"></a><a href="#l2317">2317</a><td>    var curFragment = result.cursors = document.createDocumentFragment();<tr><td><a id="l2318"></a><a href="#l2318">2318</a><td>    var selFragment = result.selection = document.createDocumentFragment();<tr><td><a id="l2319"></a><a href="#l2319">2319</a><td><tr><td><a id="l2320"></a><a href="#l2320">2320</a><td>    for (var i = 0; i &lt; doc.sel.ranges.length; i++) {<tr><td><a id="l2321"></a><a href="#l2321">2321</a><td>      if (primary === false &amp;&amp; i == doc.sel.primIndex) continue;<tr><td><a id="l2322"></a><a href="#l2322">2322</a><td>      var range = doc.sel.ranges[i];<tr><td><a id="l2323"></a><a href="#l2323">2323</a><td>      if (range.from().line &gt;= cm.display.viewTo || range.to().line &lt; cm.display.viewFrom) continue;<tr><td><a id="l2324"></a><a href="#l2324">2324</a><td>      var collapsed = range.empty();<tr><td><a id="l2325"></a><a href="#l2325">2325</a><td>      if (collapsed || cm.options.showCursorWhenSelecting)<tr><td><a id="l2326"></a><a href="#l2326">2326</a><td>        drawSelectionCursor(cm, range.head, curFragment);<tr><td><a id="l2327"></a><a href="#l2327">2327</a><td>      if (!collapsed)<tr><td><a id="l2328"></a><a href="#l2328">2328</a><td>        drawSelectionRange(cm, range, selFragment);<tr><td><a id="l2329"></a><a href="#l2329">2329</a><td>    }<tr><td><a id="l2330"></a><a href="#l2330">2330</a><td>    return result;<tr><td><a id="l2331"></a><a href="#l2331">2331</a><td>  }<tr><td><a id="l2332"></a><a href="#l2332">2332</a><td><tr><td><a id="l2333"></a><a href="#l2333">2333</a><td>  // Draws a cursor for the given range<tr><td><a id="l2334"></a><a href="#l2334">2334</a><td>  function drawSelectionCursor(cm, head, output) {<tr><td><a id="l2335"></a><a href="#l2335">2335</a><td>    var pos = cursorCoords(cm, head, &quot;div&quot;, null, null, !cm.options.singleCursorHeightPerLine);<tr><td><a id="l2336"></a><a href="#l2336">2336</a><td><tr><td><a id="l2337"></a><a href="#l2337">2337</a><td>    var cursor = output.appendChild(elt(&quot;div&quot;, &quot;\u00a0&quot;, &quot;CodeMirror-cursor&quot;));<tr><td><a id="l2338"></a><a href="#l2338">2338</a><td>    cursor.style.left = pos.left + &quot;px&quot;;<tr><td><a id="l2339"></a><a href="#l2339">2339</a><td>    cursor.style.top = pos.top + &quot;px&quot;;<tr><td><a id="l2340"></a><a href="#l2340">2340</a><td>    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + &quot;px&quot;;<tr><td><a id="l2341"></a><a href="#l2341">2341</a><td><tr><td><a id="l2342"></a><a href="#l2342">2342</a><td>    if (pos.other) {<tr><td><a id="l2343"></a><a href="#l2343">2343</a><td>      // Secondary cursor, shown when on a &#39;jump&#39; in bi-directional text<tr><td><a id="l2344"></a><a href="#l2344">2344</a><td>      var otherCursor = output.appendChild(elt(&quot;div&quot;, &quot;\u00a0&quot;, &quot;CodeMirror-cursor CodeMirror-secondarycursor&quot;));<tr><td><a id="l2345"></a><a href="#l2345">2345</a><td>      otherCursor.style.display = &quot;&quot;;<tr><td><a id="l2346"></a><a href="#l2346">2346</a><td>      otherCursor.style.left = pos.other.left + &quot;px&quot;;<tr><td><a id="l2347"></a><a href="#l2347">2347</a><td>      otherCursor.style.top = pos.other.top + &quot;px&quot;;<tr><td><a id="l2348"></a><a href="#l2348">2348</a><td>      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + &quot;px&quot;;<tr><td><a id="l2349"></a><a href="#l2349">2349</a><td>    }<tr><td><a id="l2350"></a><a href="#l2350">2350</a><td>  }<tr><td><a id="l2351"></a><a href="#l2351">2351</a><td><tr><td><a id="l2352"></a><a href="#l2352">2352</a><td>  // Draws the given range as a highlighted selection<tr><td><a id="l2353"></a><a href="#l2353">2353</a><td>  function drawSelectionRange(cm, range, output) {<tr><td><a id="l2354"></a><a href="#l2354">2354</a><td>    var display = cm.display, doc = cm.doc;<tr><td><a id="l2355"></a><a href="#l2355">2355</a><td>    var fragment = document.createDocumentFragment();<tr><td><a id="l2356"></a><a href="#l2356">2356</a><td>    var padding = paddingH(cm.display), leftSide = padding.left;<tr><td><a id="l2357"></a><a href="#l2357">2357</a><td>    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;<tr><td><a id="l2358"></a><a href="#l2358">2358</a><td><tr><td><a id="l2359"></a><a href="#l2359">2359</a><td>    function add(left, top, width, bottom) {<tr><td><a id="l2360"></a><a href="#l2360">2360</a><td>      if (top &lt; 0) top = 0;<tr><td><a id="l2361"></a><a href="#l2361">2361</a><td>      top = Math.round(top);<tr><td><a id="l2362"></a><a href="#l2362">2362</a><td>      bottom = Math.round(bottom);<tr><td><a id="l2363"></a><a href="#l2363">2363</a><td>      fragment.appendChild(elt(&quot;div&quot;, null, &quot;CodeMirror-selected&quot;, &quot;position: absolute; left: &quot; + left +<tr><td><a id="l2364"></a><a href="#l2364">2364</a><td>                               &quot;px; top: &quot; + top + &quot;px; width: &quot; + (width == null ? rightSide - left : width) +<tr><td><a id="l2365"></a><a href="#l2365">2365</a><td>                               &quot;px; height: &quot; + (bottom - top) + &quot;px&quot;));<tr><td><a id="l2366"></a><a href="#l2366">2366</a><td>    }<tr><td><a id="l2367"></a><a href="#l2367">2367</a><td><tr><td><a id="l2368"></a><a href="#l2368">2368</a><td>    function drawForLine(line, fromArg, toArg) {<tr><td><a id="l2369"></a><a href="#l2369">2369</a><td>      var lineObj = getLine(doc, line);<tr><td><a id="l2370"></a><a href="#l2370">2370</a><td>      var lineLen = lineObj.text.length;<tr><td><a id="l2371"></a><a href="#l2371">2371</a><td>      var start, end;<tr><td><a id="l2372"></a><a href="#l2372">2372</a><td>      function coords(ch, bias) {<tr><td><a id="l2373"></a><a href="#l2373">2373</a><td>        return charCoords(cm, Pos(line, ch), &quot;div&quot;, lineObj, bias);<tr><td><a id="l2374"></a><a href="#l2374">2374</a><td>      }<tr><td><a id="l2375"></a><a href="#l2375">2375</a><td><tr><td><a id="l2376"></a><a href="#l2376">2376</a><td>      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {<tr><td><a id="l2377"></a><a href="#l2377">2377</a><td>        var leftPos = coords(from, &quot;left&quot;), rightPos, left, right;<tr><td><a id="l2378"></a><a href="#l2378">2378</a><td>        if (from == to) {<tr><td><a id="l2379"></a><a href="#l2379">2379</a><td>          rightPos = leftPos;<tr><td><a id="l2380"></a><a href="#l2380">2380</a><td>          left = right = leftPos.left;<tr><td><a id="l2381"></a><a href="#l2381">2381</a><td>        } else {<tr><td><a id="l2382"></a><a href="#l2382">2382</a><td>          rightPos = coords(to - 1, &quot;right&quot;);<tr><td><a id="l2383"></a><a href="#l2383">2383</a><td>          if (dir == &quot;rtl&quot;) { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }<tr><td><a id="l2384"></a><a href="#l2384">2384</a><td>          left = leftPos.left;<tr><td><a id="l2385"></a><a href="#l2385">2385</a><td>          right = rightPos.right;<tr><td><a id="l2386"></a><a href="#l2386">2386</a><td>        }<tr><td><a id="l2387"></a><a href="#l2387">2387</a><td>        if (fromArg == null &amp;&amp; from == 0) left = leftSide;<tr><td><a id="l2388"></a><a href="#l2388">2388</a><td>        if (rightPos.top - leftPos.top &gt; 3) { // Different lines, draw top part<tr><td><a id="l2389"></a><a href="#l2389">2389</a><td>          add(left, leftPos.top, null, leftPos.bottom);<tr><td><a id="l2390"></a><a href="#l2390">2390</a><td>          left = leftSide;<tr><td><a id="l2391"></a><a href="#l2391">2391</a><td>          if (leftPos.bottom &lt; rightPos.top) add(left, leftPos.bottom, null, rightPos.top);<tr><td><a id="l2392"></a><a href="#l2392">2392</a><td>        }<tr><td><a id="l2393"></a><a href="#l2393">2393</a><td>        if (toArg == null &amp;&amp; to == lineLen) right = rightSide;<tr><td><a id="l2394"></a><a href="#l2394">2394</a><td>        if (!start || leftPos.top &lt; start.top || leftPos.top == start.top &amp;&amp; leftPos.left &lt; start.left)<tr><td><a id="l2395"></a><a href="#l2395">2395</a><td>          start = leftPos;<tr><td><a id="l2396"></a><a href="#l2396">2396</a><td>        if (!end || rightPos.bottom &gt; end.bottom || rightPos.bottom == end.bottom &amp;&amp; rightPos.right &gt; end.right)<tr><td><a id="l2397"></a><a href="#l2397">2397</a><td>          end = rightPos;<tr><td><a id="l2398"></a><a href="#l2398">2398</a><td>        if (left &lt; leftSide + 1) left = leftSide;<tr><td><a id="l2399"></a><a href="#l2399">2399</a><td>        add(left, rightPos.top, right - left, rightPos.bottom);<tr><td><a id="l2400"></a><a href="#l2400">2400</a><td>      });<tr><td><a id="l2401"></a><a href="#l2401">2401</a><td>      return {start: start, end: end};<tr><td><a id="l2402"></a><a href="#l2402">2402</a><td>    }<tr><td><a id="l2403"></a><a href="#l2403">2403</a><td><tr><td><a id="l2404"></a><a href="#l2404">2404</a><td>    var sFrom = range.from(), sTo = range.to();<tr><td><a id="l2405"></a><a href="#l2405">2405</a><td>    if (sFrom.line == sTo.line) {<tr><td><a id="l2406"></a><a href="#l2406">2406</a><td>      drawForLine(sFrom.line, sFrom.ch, sTo.ch);<tr><td><a id="l2407"></a><a href="#l2407">2407</a><td>    } else {<tr><td><a id="l2408"></a><a href="#l2408">2408</a><td>      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);<tr><td><a id="l2409"></a><a href="#l2409">2409</a><td>      var singleVLine = visualLine(fromLine) == visualLine(toLine);<tr><td><a id="l2410"></a><a href="#l2410">2410</a><td>      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;<tr><td><a id="l2411"></a><a href="#l2411">2411</a><td>      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;<tr><td><a id="l2412"></a><a href="#l2412">2412</a><td>      if (singleVLine) {<tr><td><a id="l2413"></a><a href="#l2413">2413</a><td>        if (leftEnd.top &lt; rightStart.top - 2) {<tr><td><a id="l2414"></a><a href="#l2414">2414</a><td>          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);<tr><td><a id="l2415"></a><a href="#l2415">2415</a><td>          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);<tr><td><a id="l2416"></a><a href="#l2416">2416</a><td>        } else {<tr><td><a id="l2417"></a><a href="#l2417">2417</a><td>          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);<tr><td><a id="l2418"></a><a href="#l2418">2418</a><td>        }<tr><td><a id="l2419"></a><a href="#l2419">2419</a><td>      }<tr><td><a id="l2420"></a><a href="#l2420">2420</a><td>      if (leftEnd.bottom &lt; rightStart.top)<tr><td><a id="l2421"></a><a href="#l2421">2421</a><td>        add(leftSide, leftEnd.bottom, null, rightStart.top);<tr><td><a id="l2422"></a><a href="#l2422">2422</a><td>    }<tr><td><a id="l2423"></a><a href="#l2423">2423</a><td><tr><td><a id="l2424"></a><a href="#l2424">2424</a><td>    output.appendChild(fragment);<tr><td><a id="l2425"></a><a href="#l2425">2425</a><td>  }<tr><td><a id="l2426"></a><a href="#l2426">2426</a><td><tr><td><a id="l2427"></a><a href="#l2427">2427</a><td>  // Cursor-blinking<tr><td><a id="l2428"></a><a href="#l2428">2428</a><td>  function restartBlink(cm) {<tr><td><a id="l2429"></a><a href="#l2429">2429</a><td>    if (!cm.state.focused) return;<tr><td><a id="l2430"></a><a href="#l2430">2430</a><td>    var display = cm.display;<tr><td><a id="l2431"></a><a href="#l2431">2431</a><td>    clearInterval(display.blinker);<tr><td><a id="l2432"></a><a href="#l2432">2432</a><td>    var on = true;<tr><td><a id="l2433"></a><a href="#l2433">2433</a><td>    display.cursorDiv.style.visibility = &quot;&quot;;<tr><td><a id="l2434"></a><a href="#l2434">2434</a><td>    if (cm.options.cursorBlinkRate &gt; 0)<tr><td><a id="l2435"></a><a href="#l2435">2435</a><td>      display.blinker = setInterval(function() {<tr><td><a id="l2436"></a><a href="#l2436">2436</a><td>        display.cursorDiv.style.visibility = (on = !on) ? &quot;&quot; : &quot;hidden&quot;;<tr><td><a id="l2437"></a><a href="#l2437">2437</a><td>      }, cm.options.cursorBlinkRate);<tr><td><a id="l2438"></a><a href="#l2438">2438</a><td>    else if (cm.options.cursorBlinkRate &lt; 0)<tr><td><a id="l2439"></a><a href="#l2439">2439</a><td>      display.cursorDiv.style.visibility = &quot;hidden&quot;;<tr><td><a id="l2440"></a><a href="#l2440">2440</a><td>  }<tr><td><a id="l2441"></a><a href="#l2441">2441</a><td><tr><td><a id="l2442"></a><a href="#l2442">2442</a><td>  // HIGHLIGHT WORKER<tr><td><a id="l2443"></a><a href="#l2443">2443</a><td><tr><td><a id="l2444"></a><a href="#l2444">2444</a><td>  function startWorker(cm, time) {<tr><td><a id="l2445"></a><a href="#l2445">2445</a><td>    if (cm.doc.mode.startState &amp;&amp; cm.doc.frontier &lt; cm.display.viewTo)<tr><td><a id="l2446"></a><a href="#l2446">2446</a><td>      cm.state.highlight.set(time, bind(highlightWorker, cm));<tr><td><a id="l2447"></a><a href="#l2447">2447</a><td>  }<tr><td><a id="l2448"></a><a href="#l2448">2448</a><td><tr><td><a id="l2449"></a><a href="#l2449">2449</a><td>  function highlightWorker(cm) {<tr><td><a id="l2450"></a><a href="#l2450">2450</a><td>    var doc = cm.doc;<tr><td><a id="l2451"></a><a href="#l2451">2451</a><td>    if (doc.frontier &lt; doc.first) doc.frontier = doc.first;<tr><td><a id="l2452"></a><a href="#l2452">2452</a><td>    if (doc.frontier &gt;= cm.display.viewTo) return;<tr><td><a id="l2453"></a><a href="#l2453">2453</a><td>    var end = +new Date + cm.options.workTime;<tr><td><a id="l2454"></a><a href="#l2454">2454</a><td>    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));<tr><td><a id="l2455"></a><a href="#l2455">2455</a><td>    var changedLines = [];<tr><td><a id="l2456"></a><a href="#l2456">2456</a><td><tr><td><a id="l2457"></a><a href="#l2457">2457</a><td>    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {<tr><td><a id="l2458"></a><a href="#l2458">2458</a><td>      if (doc.frontier &gt;= cm.display.viewFrom) { // Visible<tr><td><a id="l2459"></a><a href="#l2459">2459</a><td>        var oldStyles = line.styles, tooLong = line.text.length &gt; cm.options.maxHighlightLength;<tr><td><a id="l2460"></a><a href="#l2460">2460</a><td>        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);<tr><td><a id="l2461"></a><a href="#l2461">2461</a><td>        line.styles = highlighted.styles;<tr><td><a id="l2462"></a><a href="#l2462">2462</a><td>        var oldCls = line.styleClasses, newCls = highlighted.classes;<tr><td><a id="l2463"></a><a href="#l2463">2463</a><td>        if (newCls) line.styleClasses = newCls;<tr><td><a id="l2464"></a><a href="#l2464">2464</a><td>        else if (oldCls) line.styleClasses = null;<tr><td><a id="l2465"></a><a href="#l2465">2465</a><td>        var ischange = !oldStyles || oldStyles.length != line.styles.length ||<tr><td><a id="l2466"></a><a href="#l2466">2466</a><td>          oldCls != newCls &amp;&amp; (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);<tr><td><a id="l2467"></a><a href="#l2467">2467</a><td>        for (var i = 0; !ischange &amp;&amp; i &lt; oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];<tr><td><a id="l2468"></a><a href="#l2468">2468</a><td>        if (ischange) changedLines.push(doc.frontier);<tr><td><a id="l2469"></a><a href="#l2469">2469</a><td>        line.stateAfter = tooLong ? state : copyState(doc.mode, state);<tr><td><a id="l2470"></a><a href="#l2470">2470</a><td>      } else {<tr><td><a id="l2471"></a><a href="#l2471">2471</a><td>        if (line.text.length &lt;= cm.options.maxHighlightLength)<tr><td><a id="l2472"></a><a href="#l2472">2472</a><td>          processLine(cm, line.text, state);<tr><td><a id="l2473"></a><a href="#l2473">2473</a><td>        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;<tr><td><a id="l2474"></a><a href="#l2474">2474</a><td>      }<tr><td><a id="l2475"></a><a href="#l2475">2475</a><td>      ++doc.frontier;<tr><td><a id="l2476"></a><a href="#l2476">2476</a><td>      if (+new Date &gt; end) {<tr><td><a id="l2477"></a><a href="#l2477">2477</a><td>        startWorker(cm, cm.options.workDelay);<tr><td><a id="l2478"></a><a href="#l2478">2478</a><td>        return true;<tr><td><a id="l2479"></a><a href="#l2479">2479</a><td>      }<tr><td><a id="l2480"></a><a href="#l2480">2480</a><td>    });<tr><td><a id="l2481"></a><a href="#l2481">2481</a><td>    if (changedLines.length) runInOp(cm, function() {<tr><td><a id="l2482"></a><a href="#l2482">2482</a><td>      for (var i = 0; i &lt; changedLines.length; i++)<tr><td><a id="l2483"></a><a href="#l2483">2483</a><td>        regLineChange(cm, changedLines[i], &quot;text&quot;);<tr><td><a id="l2484"></a><a href="#l2484">2484</a><td>    });<tr><td><a id="l2485"></a><a href="#l2485">2485</a><td>  }<tr><td><a id="l2486"></a><a href="#l2486">2486</a><td><tr><td><a id="l2487"></a><a href="#l2487">2487</a><td>  // Finds the line to start with when starting a parse. Tries to<tr><td><a id="l2488"></a><a href="#l2488">2488</a><td>  // find a line with a stateAfter, so that it can start with a<tr><td><a id="l2489"></a><a href="#l2489">2489</a><td>  // valid state. If that fails, it returns the line with the<tr><td><a id="l2490"></a><a href="#l2490">2490</a><td>  // smallest indentation, which tends to need the least context to<tr><td><a id="l2491"></a><a href="#l2491">2491</a><td>  // parse correctly.<tr><td><a id="l2492"></a><a href="#l2492">2492</a><td>  function findStartLine(cm, n, precise) {<tr><td><a id="l2493"></a><a href="#l2493">2493</a><td>    var minindent, minline, doc = cm.doc;<tr><td><a id="l2494"></a><a href="#l2494">2494</a><td>    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);<tr><td><a id="l2495"></a><a href="#l2495">2495</a><td>    for (var search = n; search &gt; lim; --search) {<tr><td><a id="l2496"></a><a href="#l2496">2496</a><td>      if (search &lt;= doc.first) return doc.first;<tr><td><a id="l2497"></a><a href="#l2497">2497</a><td>      var line = getLine(doc, search - 1);<tr><td><a id="l2498"></a><a href="#l2498">2498</a><td>      if (line.stateAfter &amp;&amp; (!precise || search &lt;= doc.frontier)) return search;<tr><td><a id="l2499"></a><a href="#l2499">2499</a><td>      var indented = countColumn(line.text, null, cm.options.tabSize);<tr><td><a id="l2500"></a><a href="#l2500">2500</a><td>      if (minline == null || minindent &gt; indented) {<tr><td><a id="l2501"></a><a href="#l2501">2501</a><td>        minline = search - 1;<tr><td><a id="l2502"></a><a href="#l2502">2502</a><td>        minindent = indented;<tr><td><a id="l2503"></a><a href="#l2503">2503</a><td>      }<tr><td><a id="l2504"></a><a href="#l2504">2504</a><td>    }<tr><td><a id="l2505"></a><a href="#l2505">2505</a><td>    return minline;<tr><td><a id="l2506"></a><a href="#l2506">2506</a><td>  }<tr><td><a id="l2507"></a><a href="#l2507">2507</a><td><tr><td><a id="l2508"></a><a href="#l2508">2508</a><td>  function getStateBefore(cm, n, precise) {<tr><td><a id="l2509"></a><a href="#l2509">2509</a><td>    var doc = cm.doc, display = cm.display;<tr><td><a id="l2510"></a><a href="#l2510">2510</a><td>    if (!doc.mode.startState) return true;<tr><td><a id="l2511"></a><a href="#l2511">2511</a><td>    var pos = findStartLine(cm, n, precise), state = pos &gt; doc.first &amp;&amp; getLine(doc, pos-1).stateAfter;<tr><td><a id="l2512"></a><a href="#l2512">2512</a><td>    if (!state) state = startState(doc.mode);<tr><td><a id="l2513"></a><a href="#l2513">2513</a><td>    else state = copyState(doc.mode, state);<tr><td><a id="l2514"></a><a href="#l2514">2514</a><td>    doc.iter(pos, n, function(line) {<tr><td><a id="l2515"></a><a href="#l2515">2515</a><td>      processLine(cm, line.text, state);<tr><td><a id="l2516"></a><a href="#l2516">2516</a><td>      var save = pos == n - 1 || pos % 5 == 0 || pos &gt;= display.viewFrom &amp;&amp; pos &lt; display.viewTo;<tr><td><a id="l2517"></a><a href="#l2517">2517</a><td>      line.stateAfter = save ? copyState(doc.mode, state) : null;<tr><td><a id="l2518"></a><a href="#l2518">2518</a><td>      ++pos;<tr><td><a id="l2519"></a><a href="#l2519">2519</a><td>    });<tr><td><a id="l2520"></a><a href="#l2520">2520</a><td>    if (precise) doc.frontier = pos;<tr><td><a id="l2521"></a><a href="#l2521">2521</a><td>    return state;<tr><td><a id="l2522"></a><a href="#l2522">2522</a><td>  }<tr><td><a id="l2523"></a><a href="#l2523">2523</a><td><tr><td><a id="l2524"></a><a href="#l2524">2524</a><td>  // POSITION MEASUREMENT<tr><td><a id="l2525"></a><a href="#l2525">2525</a><td><tr><td><a id="l2526"></a><a href="#l2526">2526</a><td>  function paddingTop(display) {return display.lineSpace.offsetTop;}<tr><td><a id="l2527"></a><a href="#l2527">2527</a><td>  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}<tr><td><a id="l2528"></a><a href="#l2528">2528</a><td>  function paddingH(display) {<tr><td><a id="l2529"></a><a href="#l2529">2529</a><td>    if (display.cachedPaddingH) return display.cachedPaddingH;<tr><td><a id="l2530"></a><a href="#l2530">2530</a><td>    var e = removeChildrenAndAdd(display.measure, elt(&quot;pre&quot;, &quot;x&quot;));<tr><td><a id="l2531"></a><a href="#l2531">2531</a><td>    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;<tr><td><a id="l2532"></a><a href="#l2532">2532</a><td>    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};<tr><td><a id="l2533"></a><a href="#l2533">2533</a><td>    if (!isNaN(data.left) &amp;&amp; !isNaN(data.right)) display.cachedPaddingH = data;<tr><td><a id="l2534"></a><a href="#l2534">2534</a><td>    return data;<tr><td><a id="l2535"></a><a href="#l2535">2535</a><td>  }<tr><td><a id="l2536"></a><a href="#l2536">2536</a><td><tr><td><a id="l2537"></a><a href="#l2537">2537</a><td>  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }<tr><td><a id="l2538"></a><a href="#l2538">2538</a><td>  function displayWidth(cm) {<tr><td><a id="l2539"></a><a href="#l2539">2539</a><td>    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;<tr><td><a id="l2540"></a><a href="#l2540">2540</a><td>  }<tr><td><a id="l2541"></a><a href="#l2541">2541</a><td>  function displayHeight(cm) {<tr><td><a id="l2542"></a><a href="#l2542">2542</a><td>    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;<tr><td><a id="l2543"></a><a href="#l2543">2543</a><td>  }<tr><td><a id="l2544"></a><a href="#l2544">2544</a><td><tr><td><a id="l2545"></a><a href="#l2545">2545</a><td>  // Ensure the lineView.wrapping.heights array is populated. This is<tr><td><a id="l2546"></a><a href="#l2546">2546</a><td>  // an array of bottom offsets for the lines that make up a drawn<tr><td><a id="l2547"></a><a href="#l2547">2547</a><td>  // line. When lineWrapping is on, there might be more than one<tr><td><a id="l2548"></a><a href="#l2548">2548</a><td>  // height.<tr><td><a id="l2549"></a><a href="#l2549">2549</a><td>  function ensureLineHeights(cm, lineView, rect) {<tr><td><a id="l2550"></a><a href="#l2550">2550</a><td>    var wrapping = cm.options.lineWrapping;<tr><td><a id="l2551"></a><a href="#l2551">2551</a><td>    var curWidth = wrapping &amp;&amp; displayWidth(cm);<tr><td><a id="l2552"></a><a href="#l2552">2552</a><td>    if (!lineView.measure.heights || wrapping &amp;&amp; lineView.measure.width != curWidth) {<tr><td><a id="l2553"></a><a href="#l2553">2553</a><td>      var heights = lineView.measure.heights = [];<tr><td><a id="l2554"></a><a href="#l2554">2554</a><td>      if (wrapping) {<tr><td><a id="l2555"></a><a href="#l2555">2555</a><td>        lineView.measure.width = curWidth;<tr><td><a id="l2556"></a><a href="#l2556">2556</a><td>        var rects = lineView.text.firstChild.getClientRects();<tr><td><a id="l2557"></a><a href="#l2557">2557</a><td>        for (var i = 0; i &lt; rects.length - 1; i++) {<tr><td><a id="l2558"></a><a href="#l2558">2558</a><td>          var cur = rects[i], next = rects[i + 1];<tr><td><a id="l2559"></a><a href="#l2559">2559</a><td>          if (Math.abs(cur.bottom - next.bottom) &gt; 2)<tr><td><a id="l2560"></a><a href="#l2560">2560</a><td>            heights.push((cur.bottom + next.top) / 2 - rect.top);<tr><td><a id="l2561"></a><a href="#l2561">2561</a><td>        }<tr><td><a id="l2562"></a><a href="#l2562">2562</a><td>      }<tr><td><a id="l2563"></a><a href="#l2563">2563</a><td>      heights.push(rect.bottom - rect.top);<tr><td><a id="l2564"></a><a href="#l2564">2564</a><td>    }<tr><td><a id="l2565"></a><a href="#l2565">2565</a><td>  }<tr><td><a id="l2566"></a><a href="#l2566">2566</a><td><tr><td><a id="l2567"></a><a href="#l2567">2567</a><td>  // Find a line map (mapping character offsets to text nodes) and a<tr><td><a id="l2568"></a><a href="#l2568">2568</a><td>  // measurement cache for the given line number. (A line view might<tr><td><a id="l2569"></a><a href="#l2569">2569</a><td>  // contain multiple lines when collapsed ranges are present.)<tr><td><a id="l2570"></a><a href="#l2570">2570</a><td>  function mapFromLineView(lineView, line, lineN) {<tr><td><a id="l2571"></a><a href="#l2571">2571</a><td>    if (lineView.line == line)<tr><td><a id="l2572"></a><a href="#l2572">2572</a><td>      return {map: lineView.measure.map, cache: lineView.measure.cache};<tr><td><a id="l2573"></a><a href="#l2573">2573</a><td>    for (var i = 0; i &lt; lineView.rest.length; i++)<tr><td><a id="l2574"></a><a href="#l2574">2574</a><td>      if (lineView.rest[i] == line)<tr><td><a id="l2575"></a><a href="#l2575">2575</a><td>        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};<tr><td><a id="l2576"></a><a href="#l2576">2576</a><td>    for (var i = 0; i &lt; lineView.rest.length; i++)<tr><td><a id="l2577"></a><a href="#l2577">2577</a><td>      if (lineNo(lineView.rest[i]) &gt; lineN)<tr><td><a id="l2578"></a><a href="#l2578">2578</a><td>        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};<tr><td><a id="l2579"></a><a href="#l2579">2579</a><td>  }<tr><td><a id="l2580"></a><a href="#l2580">2580</a><td><tr><td><a id="l2581"></a><a href="#l2581">2581</a><td>  // Render a line into the hidden node display.externalMeasured. Used<tr><td><a id="l2582"></a><a href="#l2582">2582</a><td>  // when measurement is needed for a line that&#39;s not in the viewport.<tr><td><a id="l2583"></a><a href="#l2583">2583</a><td>  function updateExternalMeasurement(cm, line) {<tr><td><a id="l2584"></a><a href="#l2584">2584</a><td>    line = visualLine(line);<tr><td><a id="l2585"></a><a href="#l2585">2585</a><td>    var lineN = lineNo(line);<tr><td><a id="l2586"></a><a href="#l2586">2586</a><td>    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);<tr><td><a id="l2587"></a><a href="#l2587">2587</a><td>    view.lineN = lineN;<tr><td><a id="l2588"></a><a href="#l2588">2588</a><td>    var built = view.built = buildLineContent(cm, view);<tr><td><a id="l2589"></a><a href="#l2589">2589</a><td>    view.text = built.pre;<tr><td><a id="l2590"></a><a href="#l2590">2590</a><td>    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);<tr><td><a id="l2591"></a><a href="#l2591">2591</a><td>    return view;<tr><td><a id="l2592"></a><a href="#l2592">2592</a><td>  }<tr><td><a id="l2593"></a><a href="#l2593">2593</a><td><tr><td><a id="l2594"></a><a href="#l2594">2594</a><td>  // Get a {top, bottom, left, right} box (in line-local coordinates)<tr><td><a id="l2595"></a><a href="#l2595">2595</a><td>  // for a given character.<tr><td><a id="l2596"></a><a href="#l2596">2596</a><td>  function measureChar(cm, line, ch, bias) {<tr><td><a id="l2597"></a><a href="#l2597">2597</a><td>    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);<tr><td><a id="l2598"></a><a href="#l2598">2598</a><td>  }<tr><td><a id="l2599"></a><a href="#l2599">2599</a><td><tr><td><a id="l2600"></a><a href="#l2600">2600</a><td>  // Find a line view that corresponds to the given line number.<tr><td><a id="l2601"></a><a href="#l2601">2601</a><td>  function findViewForLine(cm, lineN) {<tr><td><a id="l2602"></a><a href="#l2602">2602</a><td>    if (lineN &gt;= cm.display.viewFrom &amp;&amp; lineN &lt; cm.display.viewTo)<tr><td><a id="l2603"></a><a href="#l2603">2603</a><td>      return cm.display.view[findViewIndex(cm, lineN)];<tr><td><a id="l2604"></a><a href="#l2604">2604</a><td>    var ext = cm.display.externalMeasured;<tr><td><a id="l2605"></a><a href="#l2605">2605</a><td>    if (ext &amp;&amp; lineN &gt;= ext.lineN &amp;&amp; lineN &lt; ext.lineN + ext.size)<tr><td><a id="l2606"></a><a href="#l2606">2606</a><td>      return ext;<tr><td><a id="l2607"></a><a href="#l2607">2607</a><td>  }<tr><td><a id="l2608"></a><a href="#l2608">2608</a><td><tr><td><a id="l2609"></a><a href="#l2609">2609</a><td>  // Measurement can be split in two steps, the set-up work that<tr><td><a id="l2610"></a><a href="#l2610">2610</a><td>  // applies to the whole line, and the measurement of the actual<tr><td><a id="l2611"></a><a href="#l2611">2611</a><td>  // character. Functions like coordsChar, that need to do a lot of<tr><td><a id="l2612"></a><a href="#l2612">2612</a><td>  // measurements in a row, can thus ensure that the set-up work is<tr><td><a id="l2613"></a><a href="#l2613">2613</a><td>  // only done once.<tr><td><a id="l2614"></a><a href="#l2614">2614</a><td>  function prepareMeasureForLine(cm, line) {<tr><td><a id="l2615"></a><a href="#l2615">2615</a><td>    var lineN = lineNo(line);<tr><td><a id="l2616"></a><a href="#l2616">2616</a><td>    var view = findViewForLine(cm, lineN);<tr><td><a id="l2617"></a><a href="#l2617">2617</a><td>    if (view &amp;&amp; !view.text) {<tr><td><a id="l2618"></a><a href="#l2618">2618</a><td>      view = null;<tr><td><a id="l2619"></a><a href="#l2619">2619</a><td>    } else if (view &amp;&amp; view.changes) {<tr><td><a id="l2620"></a><a href="#l2620">2620</a><td>      updateLineForChanges(cm, view, lineN, getDimensions(cm));<tr><td><a id="l2621"></a><a href="#l2621">2621</a><td>      cm.curOp.forceUpdate = true;<tr><td><a id="l2622"></a><a href="#l2622">2622</a><td>    }<tr><td><a id="l2623"></a><a href="#l2623">2623</a><td>    if (!view)<tr><td><a id="l2624"></a><a href="#l2624">2624</a><td>      view = updateExternalMeasurement(cm, line);<tr><td><a id="l2625"></a><a href="#l2625">2625</a><td><tr><td><a id="l2626"></a><a href="#l2626">2626</a><td>    var info = mapFromLineView(view, line, lineN);<tr><td><a id="l2627"></a><a href="#l2627">2627</a><td>    return {<tr><td><a id="l2628"></a><a href="#l2628">2628</a><td>      line: line, view: view, rect: null,<tr><td><a id="l2629"></a><a href="#l2629">2629</a><td>      map: info.map, cache: info.cache, before: info.before,<tr><td><a id="l2630"></a><a href="#l2630">2630</a><td>      hasHeights: false<tr><td><a id="l2631"></a><a href="#l2631">2631</a><td>    };<tr><td><a id="l2632"></a><a href="#l2632">2632</a><td>  }<tr><td><a id="l2633"></a><a href="#l2633">2633</a><td><tr><td><a id="l2634"></a><a href="#l2634">2634</a><td>  // Given a prepared measurement object, measures the position of an<tr><td><a id="l2635"></a><a href="#l2635">2635</a><td>  // actual character (or fetches it from the cache).<tr><td><a id="l2636"></a><a href="#l2636">2636</a><td>  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {<tr><td><a id="l2637"></a><a href="#l2637">2637</a><td>    if (prepared.before) ch = -1;<tr><td><a id="l2638"></a><a href="#l2638">2638</a><td>    var key = ch + (bias || &quot;&quot;), found;<tr><td><a id="l2639"></a><a href="#l2639">2639</a><td>    if (prepared.cache.hasOwnProperty(key)) {<tr><td><a id="l2640"></a><a href="#l2640">2640</a><td>      found = prepared.cache[key];<tr><td><a id="l2641"></a><a href="#l2641">2641</a><td>    } else {<tr><td><a id="l2642"></a><a href="#l2642">2642</a><td>      if (!prepared.rect)<tr><td><a id="l2643"></a><a href="#l2643">2643</a><td>        prepared.rect = prepared.view.text.getBoundingClientRect();<tr><td><a id="l2644"></a><a href="#l2644">2644</a><td>      if (!prepared.hasHeights) {<tr><td><a id="l2645"></a><a href="#l2645">2645</a><td>        ensureLineHeights(cm, prepared.view, prepared.rect);<tr><td><a id="l2646"></a><a href="#l2646">2646</a><td>        prepared.hasHeights = true;<tr><td><a id="l2647"></a><a href="#l2647">2647</a><td>      }<tr><td><a id="l2648"></a><a href="#l2648">2648</a><td>      found = measureCharInner(cm, prepared, ch, bias);<tr><td><a id="l2649"></a><a href="#l2649">2649</a><td>      if (!found.bogus) prepared.cache[key] = found;<tr><td><a id="l2650"></a><a href="#l2650">2650</a><td>    }<tr><td><a id="l2651"></a><a href="#l2651">2651</a><td>    return {left: found.left, right: found.right,<tr><td><a id="l2652"></a><a href="#l2652">2652</a><td>            top: varHeight ? found.rtop : found.top,<tr><td><a id="l2653"></a><a href="#l2653">2653</a><td>            bottom: varHeight ? found.rbottom : found.bottom};<tr><td><a id="l2654"></a><a href="#l2654">2654</a><td>  }<tr><td><a id="l2655"></a><a href="#l2655">2655</a><td><tr><td><a id="l2656"></a><a href="#l2656">2656</a><td>  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};<tr><td><a id="l2657"></a><a href="#l2657">2657</a><td><tr><td><a id="l2658"></a><a href="#l2658">2658</a><td>  function nodeAndOffsetInLineMap(map, ch, bias) {<tr><td><a id="l2659"></a><a href="#l2659">2659</a><td>    var node, start, end, collapse;<tr><td><a id="l2660"></a><a href="#l2660">2660</a><td>    // First, search the line map for the text node corresponding to,<tr><td><a id="l2661"></a><a href="#l2661">2661</a><td>    // or closest to, the target character.<tr><td><a id="l2662"></a><a href="#l2662">2662</a><td>    for (var i = 0; i &lt; map.length; i += 3) {<tr><td><a id="l2663"></a><a href="#l2663">2663</a><td>      var mStart = map[i], mEnd = map[i + 1];<tr><td><a id="l2664"></a><a href="#l2664">2664</a><td>      if (ch &lt; mStart) {<tr><td><a id="l2665"></a><a href="#l2665">2665</a><td>        start = 0; end = 1;<tr><td><a id="l2666"></a><a href="#l2666">2666</a><td>        collapse = &quot;left&quot;;<tr><td><a id="l2667"></a><a href="#l2667">2667</a><td>      } else if (ch &lt; mEnd) {<tr><td><a id="l2668"></a><a href="#l2668">2668</a><td>        start = ch - mStart;<tr><td><a id="l2669"></a><a href="#l2669">2669</a><td>        end = start + 1;<tr><td><a id="l2670"></a><a href="#l2670">2670</a><td>      } else if (i == map.length - 3 || ch == mEnd &amp;&amp; map[i + 3] &gt; ch) {<tr><td><a id="l2671"></a><a href="#l2671">2671</a><td>        end = mEnd - mStart;<tr><td><a id="l2672"></a><a href="#l2672">2672</a><td>        start = end - 1;<tr><td><a id="l2673"></a><a href="#l2673">2673</a><td>        if (ch &gt;= mEnd) collapse = &quot;right&quot;;<tr><td><a id="l2674"></a><a href="#l2674">2674</a><td>      }<tr><td><a id="l2675"></a><a href="#l2675">2675</a><td>      if (start != null) {<tr><td><a id="l2676"></a><a href="#l2676">2676</a><td>        node = map[i + 2];<tr><td><a id="l2677"></a><a href="#l2677">2677</a><td>        if (mStart == mEnd &amp;&amp; bias == (node.insertLeft ? &quot;left&quot; : &quot;right&quot;))<tr><td><a id="l2678"></a><a href="#l2678">2678</a><td>          collapse = bias;<tr><td><a id="l2679"></a><a href="#l2679">2679</a><td>        if (bias == &quot;left&quot; &amp;&amp; start == 0)<tr><td><a id="l2680"></a><a href="#l2680">2680</a><td>          while (i &amp;&amp; map[i - 2] == map[i - 3] &amp;&amp; map[i - 1].insertLeft) {<tr><td><a id="l2681"></a><a href="#l2681">2681</a><td>            node = map[(i -= 3) + 2];<tr><td><a id="l2682"></a><a href="#l2682">2682</a><td>            collapse = &quot;left&quot;;<tr><td><a id="l2683"></a><a href="#l2683">2683</a><td>          }<tr><td><a id="l2684"></a><a href="#l2684">2684</a><td>        if (bias == &quot;right&quot; &amp;&amp; start == mEnd - mStart)<tr><td><a id="l2685"></a><a href="#l2685">2685</a><td>          while (i &lt; map.length - 3 &amp;&amp; map[i + 3] == map[i + 4] &amp;&amp; !map[i + 5].insertLeft) {<tr><td><a id="l2686"></a><a href="#l2686">2686</a><td>            node = map[(i += 3) + 2];<tr><td><a id="l2687"></a><a href="#l2687">2687</a><td>            collapse = &quot;right&quot;;<tr><td><a id="l2688"></a><a href="#l2688">2688</a><td>          }<tr><td><a id="l2689"></a><a href="#l2689">2689</a><td>        break;<tr><td><a id="l2690"></a><a href="#l2690">2690</a><td>      }<tr><td><a id="l2691"></a><a href="#l2691">2691</a><td>    }<tr><td><a id="l2692"></a><a href="#l2692">2692</a><td>    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};<tr><td><a id="l2693"></a><a href="#l2693">2693</a><td>  }<tr><td><a id="l2694"></a><a href="#l2694">2694</a><td><tr><td><a id="l2695"></a><a href="#l2695">2695</a><td>  function getUsefulRect(rects, bias) {<tr><td><a id="l2696"></a><a href="#l2696">2696</a><td>    var rect = nullRect<tr><td><a id="l2697"></a><a href="#l2697">2697</a><td>    if (bias == &quot;left&quot;) for (var i = 0; i &lt; rects.length; i++) {<tr><td><a id="l2698"></a><a href="#l2698">2698</a><td>      if ((rect = rects[i]).left != rect.right) break<tr><td><a id="l2699"></a><a href="#l2699">2699</a><td>    } else for (var i = rects.length - 1; i &gt;= 0; i--) {<tr><td><a id="l2700"></a><a href="#l2700">2700</a><td>      if ((rect = rects[i]).left != rect.right) break<tr><td><a id="l2701"></a><a href="#l2701">2701</a><td>    }<tr><td><a id="l2702"></a><a href="#l2702">2702</a><td>    return rect<tr><td><a id="l2703"></a><a href="#l2703">2703</a><td>  }<tr><td><a id="l2704"></a><a href="#l2704">2704</a><td><tr><td><a id="l2705"></a><a href="#l2705">2705</a><td>  function measureCharInner(cm, prepared, ch, bias) {<tr><td><a id="l2706"></a><a href="#l2706">2706</a><td>    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);<tr><td><a id="l2707"></a><a href="#l2707">2707</a><td>    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;<tr><td><a id="l2708"></a><a href="#l2708">2708</a><td><tr><td><a id="l2709"></a><a href="#l2709">2709</a><td>    var rect;<tr><td><a id="l2710"></a><a href="#l2710">2710</a><td>    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.<tr><td><a id="l2711"></a><a href="#l2711">2711</a><td>      for (var i = 0; i &lt; 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned<tr><td><a id="l2712"></a><a href="#l2712">2712</a><td>        while (start &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;<tr><td><a id="l2713"></a><a href="#l2713">2713</a><td>        while (place.coverStart + end &lt; place.coverEnd &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;<tr><td><a id="l2714"></a><a href="#l2714">2714</a><td>        if (ie &amp;&amp; ie_version &lt; 9 &amp;&amp; start == 0 &amp;&amp; end == place.coverEnd - place.coverStart)<tr><td><a id="l2715"></a><a href="#l2715">2715</a><td>          rect = node.parentNode.getBoundingClientRect();<tr><td><a id="l2716"></a><a href="#l2716">2716</a><td>        else<tr><td><a id="l2717"></a><a href="#l2717">2717</a><td>          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)<tr><td><a id="l2718"></a><a href="#l2718">2718</a><td>        if (rect.left || rect.right || start == 0) break;<tr><td><a id="l2719"></a><a href="#l2719">2719</a><td>        end = start;<tr><td><a id="l2720"></a><a href="#l2720">2720</a><td>        start = start - 1;<tr><td><a id="l2721"></a><a href="#l2721">2721</a><td>        collapse = &quot;right&quot;;<tr><td><a id="l2722"></a><a href="#l2722">2722</a><td>      }<tr><td><a id="l2723"></a><a href="#l2723">2723</a><td>      if (ie &amp;&amp; ie_version &lt; 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);<tr><td><a id="l2724"></a><a href="#l2724">2724</a><td>    } else { // If it is a widget, simply get the box for the whole widget.<tr><td><a id="l2725"></a><a href="#l2725">2725</a><td>      if (start &gt; 0) collapse = bias = &quot;right&quot;;<tr><td><a id="l2726"></a><a href="#l2726">2726</a><td>      var rects;<tr><td><a id="l2727"></a><a href="#l2727">2727</a><td>      if (cm.options.lineWrapping &amp;&amp; (rects = node.getClientRects()).length &gt; 1)<tr><td><a id="l2728"></a><a href="#l2728">2728</a><td>        rect = rects[bias == &quot;right&quot; ? rects.length - 1 : 0];<tr><td><a id="l2729"></a><a href="#l2729">2729</a><td>      else<tr><td><a id="l2730"></a><a href="#l2730">2730</a><td>        rect = node.getBoundingClientRect();<tr><td><a id="l2731"></a><a href="#l2731">2731</a><td>    }<tr><td><a id="l2732"></a><a href="#l2732">2732</a><td>    if (ie &amp;&amp; ie_version &lt; 9 &amp;&amp; !start &amp;&amp; (!rect || !rect.left &amp;&amp; !rect.right)) {<tr><td><a id="l2733"></a><a href="#l2733">2733</a><td>      var rSpan = node.parentNode.getClientRects()[0];<tr><td><a id="l2734"></a><a href="#l2734">2734</a><td>      if (rSpan)<tr><td><a id="l2735"></a><a href="#l2735">2735</a><td>        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};<tr><td><a id="l2736"></a><a href="#l2736">2736</a><td>      else<tr><td><a id="l2737"></a><a href="#l2737">2737</a><td>        rect = nullRect;<tr><td><a id="l2738"></a><a href="#l2738">2738</a><td>    }<tr><td><a id="l2739"></a><a href="#l2739">2739</a><td><tr><td><a id="l2740"></a><a href="#l2740">2740</a><td>    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;<tr><td><a id="l2741"></a><a href="#l2741">2741</a><td>    var mid = (rtop + rbot) / 2;<tr><td><a id="l2742"></a><a href="#l2742">2742</a><td>    var heights = prepared.view.measure.heights;<tr><td><a id="l2743"></a><a href="#l2743">2743</a><td>    for (var i = 0; i &lt; heights.length - 1; i++)<tr><td><a id="l2744"></a><a href="#l2744">2744</a><td>      if (mid &lt; heights[i]) break;<tr><td><a id="l2745"></a><a href="#l2745">2745</a><td>    var top = i ? heights[i - 1] : 0, bot = heights[i];<tr><td><a id="l2746"></a><a href="#l2746">2746</a><td>    var result = {left: (collapse == &quot;right&quot; ? rect.right : rect.left) - prepared.rect.left,<tr><td><a id="l2747"></a><a href="#l2747">2747</a><td>                  right: (collapse == &quot;left&quot; ? rect.left : rect.right) - prepared.rect.left,<tr><td><a id="l2748"></a><a href="#l2748">2748</a><td>                  top: top, bottom: bot};<tr><td><a id="l2749"></a><a href="#l2749">2749</a><td>    if (!rect.left &amp;&amp; !rect.right) result.bogus = true;<tr><td><a id="l2750"></a><a href="#l2750">2750</a><td>    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }<tr><td><a id="l2751"></a><a href="#l2751">2751</a><td><tr><td><a id="l2752"></a><a href="#l2752">2752</a><td>    return result;<tr><td><a id="l2753"></a><a href="#l2753">2753</a><td>  }<tr><td><a id="l2754"></a><a href="#l2754">2754</a><td><tr><td><a id="l2755"></a><a href="#l2755">2755</a><td>  // Work around problem with bounding client rects on ranges being<tr><td><a id="l2756"></a><a href="#l2756">2756</a><td>  // returned incorrectly when zoomed on IE10 and below.<tr><td><a id="l2757"></a><a href="#l2757">2757</a><td>  function maybeUpdateRectForZooming(measure, rect) {<tr><td><a id="l2758"></a><a href="#l2758">2758</a><td>    if (!window.screen || screen.logicalXDPI == null ||<tr><td><a id="l2759"></a><a href="#l2759">2759</a><td>        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))<tr><td><a id="l2760"></a><a href="#l2760">2760</a><td>      return rect;<tr><td><a id="l2761"></a><a href="#l2761">2761</a><td>    var scaleX = screen.logicalXDPI / screen.deviceXDPI;<tr><td><a id="l2762"></a><a href="#l2762">2762</a><td>    var scaleY = screen.logicalYDPI / screen.deviceYDPI;<tr><td><a id="l2763"></a><a href="#l2763">2763</a><td>    return {left: rect.left * scaleX, right: rect.right * scaleX,<tr><td><a id="l2764"></a><a href="#l2764">2764</a><td>            top: rect.top * scaleY, bottom: rect.bottom * scaleY};<tr><td><a id="l2765"></a><a href="#l2765">2765</a><td>  }<tr><td><a id="l2766"></a><a href="#l2766">2766</a><td><tr><td><a id="l2767"></a><a href="#l2767">2767</a><td>  function clearLineMeasurementCacheFor(lineView) {<tr><td><a id="l2768"></a><a href="#l2768">2768</a><td>    if (lineView.measure) {<tr><td><a id="l2769"></a><a href="#l2769">2769</a><td>      lineView.measure.cache = {};<tr><td><a id="l2770"></a><a href="#l2770">2770</a><td>      lineView.measure.heights = null;<tr><td><a id="l2771"></a><a href="#l2771">2771</a><td>      if (lineView.rest) for (var i = 0; i &lt; lineView.rest.length; i++)<tr><td><a id="l2772"></a><a href="#l2772">2772</a><td>        lineView.measure.caches[i] = {};<tr><td><a id="l2773"></a><a href="#l2773">2773</a><td>    }<tr><td><a id="l2774"></a><a href="#l2774">2774</a><td>  }<tr><td><a id="l2775"></a><a href="#l2775">2775</a><td><tr><td><a id="l2776"></a><a href="#l2776">2776</a><td>  function clearLineMeasurementCache(cm) {<tr><td><a id="l2777"></a><a href="#l2777">2777</a><td>    cm.display.externalMeasure = null;<tr><td><a id="l2778"></a><a href="#l2778">2778</a><td>    removeChildren(cm.display.lineMeasure);<tr><td><a id="l2779"></a><a href="#l2779">2779</a><td>    for (var i = 0; i &lt; cm.display.view.length; i++)<tr><td><a id="l2780"></a><a href="#l2780">2780</a><td>      clearLineMeasurementCacheFor(cm.display.view[i]);<tr><td><a id="l2781"></a><a href="#l2781">2781</a><td>  }<tr><td><a id="l2782"></a><a href="#l2782">2782</a><td><tr><td><a id="l2783"></a><a href="#l2783">2783</a><td>  function clearCaches(cm) {<tr><td><a id="l2784"></a><a href="#l2784">2784</a><td>    clearLineMeasurementCache(cm);<tr><td><a id="l2785"></a><a href="#l2785">2785</a><td>    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;<tr><td><a id="l2786"></a><a href="#l2786">2786</a><td>    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;<tr><td><a id="l2787"></a><a href="#l2787">2787</a><td>    cm.display.lineNumChars = null;<tr><td><a id="l2788"></a><a href="#l2788">2788</a><td>  }<tr><td><a id="l2789"></a><a href="#l2789">2789</a><td><tr><td><a id="l2790"></a><a href="#l2790">2790</a><td>  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }<tr><td><a id="l2791"></a><a href="#l2791">2791</a><td>  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }<tr><td><a id="l2792"></a><a href="#l2792">2792</a><td><tr><td><a id="l2793"></a><a href="#l2793">2793</a><td>  // Converts a {top, bottom, left, right} box from line-local<tr><td><a id="l2794"></a><a href="#l2794">2794</a><td>  // coordinates into another coordinate system. Context may be one of<tr><td><a id="l2795"></a><a href="#l2795">2795</a><td>  // &quot;line&quot;, &quot;div&quot; (display.lineDiv), &quot;local&quot;/null (editor), &quot;window&quot;,<tr><td><a id="l2796"></a><a href="#l2796">2796</a><td>  // or &quot;page&quot;.<tr><td><a id="l2797"></a><a href="#l2797">2797</a><td>  function intoCoordSystem(cm, lineObj, rect, context) {<tr><td><a id="l2798"></a><a href="#l2798">2798</a><td>    if (lineObj.widgets) for (var i = 0; i &lt; lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {<tr><td><a id="l2799"></a><a href="#l2799">2799</a><td>      var size = widgetHeight(lineObj.widgets[i]);<tr><td><a id="l2800"></a><a href="#l2800">2800</a><td>      rect.top += size; rect.bottom += size;<tr><td><a id="l2801"></a><a href="#l2801">2801</a><td>    }<tr><td><a id="l2802"></a><a href="#l2802">2802</a><td>    if (context == &quot;line&quot;) return rect;<tr><td><a id="l2803"></a><a href="#l2803">2803</a><td>    if (!context) context = &quot;local&quot;;<tr><td><a id="l2804"></a><a href="#l2804">2804</a><td>    var yOff = heightAtLine(lineObj);<tr><td><a id="l2805"></a><a href="#l2805">2805</a><td>    if (context == &quot;local&quot;) yOff += paddingTop(cm.display);<tr><td><a id="l2806"></a><a href="#l2806">2806</a><td>    else yOff -= cm.display.viewOffset;<tr><td><a id="l2807"></a><a href="#l2807">2807</a><td>    if (context == &quot;page&quot; || context == &quot;window&quot;) {<tr><td><a id="l2808"></a><a href="#l2808">2808</a><td>      var lOff = cm.display.lineSpace.getBoundingClientRect();<tr><td><a id="l2809"></a><a href="#l2809">2809</a><td>      yOff += lOff.top + (context == &quot;window&quot; ? 0 : pageScrollY());<tr><td><a id="l2810"></a><a href="#l2810">2810</a><td>      var xOff = lOff.left + (context == &quot;window&quot; ? 0 : pageScrollX());<tr><td><a id="l2811"></a><a href="#l2811">2811</a><td>      rect.left += xOff; rect.right += xOff;<tr><td><a id="l2812"></a><a href="#l2812">2812</a><td>    }<tr><td><a id="l2813"></a><a href="#l2813">2813</a><td>    rect.top += yOff; rect.bottom += yOff;<tr><td><a id="l2814"></a><a href="#l2814">2814</a><td>    return rect;<tr><td><a id="l2815"></a><a href="#l2815">2815</a><td>  }<tr><td><a id="l2816"></a><a href="#l2816">2816</a><td><tr><td><a id="l2817"></a><a href="#l2817">2817</a><td>  // Coverts a box from &quot;div&quot; coords to another coordinate system.<tr><td><a id="l2818"></a><a href="#l2818">2818</a><td>  // Context may be &quot;window&quot;, &quot;page&quot;, &quot;div&quot;, or &quot;local&quot;/null.<tr><td><a id="l2819"></a><a href="#l2819">2819</a><td>  function fromCoordSystem(cm, coords, context) {<tr><td><a id="l2820"></a><a href="#l2820">2820</a><td>    if (context == &quot;div&quot;) return coords;<tr><td><a id="l2821"></a><a href="#l2821">2821</a><td>    var left = coords.left, top = coords.top;<tr><td><a id="l2822"></a><a href="#l2822">2822</a><td>    // First move into &quot;page&quot; coordinate system<tr><td><a id="l2823"></a><a href="#l2823">2823</a><td>    if (context == &quot;page&quot;) {<tr><td><a id="l2824"></a><a href="#l2824">2824</a><td>      left -= pageScrollX();<tr><td><a id="l2825"></a><a href="#l2825">2825</a><td>      top -= pageScrollY();<tr><td><a id="l2826"></a><a href="#l2826">2826</a><td>    } else if (context == &quot;local&quot; || !context) {<tr><td><a id="l2827"></a><a href="#l2827">2827</a><td>      var localBox = cm.display.sizer.getBoundingClientRect();<tr><td><a id="l2828"></a><a href="#l2828">2828</a><td>      left += localBox.left;<tr><td><a id="l2829"></a><a href="#l2829">2829</a><td>      top += localBox.top;<tr><td><a id="l2830"></a><a href="#l2830">2830</a><td>    }<tr><td><a id="l2831"></a><a href="#l2831">2831</a><td><tr><td><a id="l2832"></a><a href="#l2832">2832</a><td>    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();<tr><td><a id="l2833"></a><a href="#l2833">2833</a><td>    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};<tr><td><a id="l2834"></a><a href="#l2834">2834</a><td>  }<tr><td><a id="l2835"></a><a href="#l2835">2835</a><td><tr><td><a id="l2836"></a><a href="#l2836">2836</a><td>  function charCoords(cm, pos, context, lineObj, bias) {<tr><td><a id="l2837"></a><a href="#l2837">2837</a><td>    if (!lineObj) lineObj = getLine(cm.doc, pos.line);<tr><td><a id="l2838"></a><a href="#l2838">2838</a><td>    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);<tr><td><a id="l2839"></a><a href="#l2839">2839</a><td>  }<tr><td><a id="l2840"></a><a href="#l2840">2840</a><td><tr><td><a id="l2841"></a><a href="#l2841">2841</a><td>  // Returns a box for a given cursor position, which may have an<tr><td><a id="l2842"></a><a href="#l2842">2842</a><td>  // &#39;other&#39; property containing the position of the secondary cursor<tr><td><a id="l2843"></a><a href="#l2843">2843</a><td>  // on a bidi boundary.<tr><td><a id="l2844"></a><a href="#l2844">2844</a><td>  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {<tr><td><a id="l2845"></a><a href="#l2845">2845</a><td>    lineObj = lineObj || getLine(cm.doc, pos.line);<tr><td><a id="l2846"></a><a href="#l2846">2846</a><td>    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);<tr><td><a id="l2847"></a><a href="#l2847">2847</a><td>    function get(ch, right) {<tr><td><a id="l2848"></a><a href="#l2848">2848</a><td>      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? &quot;right&quot; : &quot;left&quot;, varHeight);<tr><td><a id="l2849"></a><a href="#l2849">2849</a><td>      if (right) m.left = m.right; else m.right = m.left;<tr><td><a id="l2850"></a><a href="#l2850">2850</a><td>      return intoCoordSystem(cm, lineObj, m, context);<tr><td><a id="l2851"></a><a href="#l2851">2851</a><td>    }<tr><td><a id="l2852"></a><a href="#l2852">2852</a><td>    function getBidi(ch, partPos) {<tr><td><a id="l2853"></a><a href="#l2853">2853</a><td>      var part = order[partPos], right = part.level % 2;<tr><td><a id="l2854"></a><a href="#l2854">2854</a><td>      if (ch == bidiLeft(part) &amp;&amp; partPos &amp;&amp; part.level &lt; order[partPos - 1].level) {<tr><td><a id="l2855"></a><a href="#l2855">2855</a><td>        part = order[--partPos];<tr><td><a id="l2856"></a><a href="#l2856">2856</a><td>        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);<tr><td><a id="l2857"></a><a href="#l2857">2857</a><td>        right = true;<tr><td><a id="l2858"></a><a href="#l2858">2858</a><td>      } else if (ch == bidiRight(part) &amp;&amp; partPos &lt; order.length - 1 &amp;&amp; part.level &lt; order[partPos + 1].level) {<tr><td><a id="l2859"></a><a href="#l2859">2859</a><td>        part = order[++partPos];<tr><td><a id="l2860"></a><a href="#l2860">2860</a><td>        ch = bidiLeft(part) - part.level % 2;<tr><td><a id="l2861"></a><a href="#l2861">2861</a><td>        right = false;<tr><td><a id="l2862"></a><a href="#l2862">2862</a><td>      }<tr><td><a id="l2863"></a><a href="#l2863">2863</a><td>      if (right &amp;&amp; ch == part.to &amp;&amp; ch &gt; part.from) return get(ch - 1);<tr><td><a id="l2864"></a><a href="#l2864">2864</a><td>      return get(ch, right);<tr><td><a id="l2865"></a><a href="#l2865">2865</a><td>    }<tr><td><a id="l2866"></a><a href="#l2866">2866</a><td>    var order = getOrder(lineObj), ch = pos.ch;<tr><td><a id="l2867"></a><a href="#l2867">2867</a><td>    if (!order) return get(ch);<tr><td><a id="l2868"></a><a href="#l2868">2868</a><td>    var partPos = getBidiPartAt(order, ch);<tr><td><a id="l2869"></a><a href="#l2869">2869</a><td>    var val = getBidi(ch, partPos);<tr><td><a id="l2870"></a><a href="#l2870">2870</a><td>    if (bidiOther != null) val.other = getBidi(ch, bidiOther);<tr><td><a id="l2871"></a><a href="#l2871">2871</a><td>    return val;<tr><td><a id="l2872"></a><a href="#l2872">2872</a><td>  }<tr><td><a id="l2873"></a><a href="#l2873">2873</a><td><tr><td><a id="l2874"></a><a href="#l2874">2874</a><td>  // Used to cheaply estimate the coordinates for a position. Used for<tr><td><a id="l2875"></a><a href="#l2875">2875</a><td>  // intermediate scroll updates.<tr><td><a id="l2876"></a><a href="#l2876">2876</a><td>  function estimateCoords(cm, pos) {<tr><td><a id="l2877"></a><a href="#l2877">2877</a><td>    var left = 0, pos = clipPos(cm.doc, pos);<tr><td><a id="l2878"></a><a href="#l2878">2878</a><td>    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;<tr><td><a id="l2879"></a><a href="#l2879">2879</a><td>    var lineObj = getLine(cm.doc, pos.line);<tr><td><a id="l2880"></a><a href="#l2880">2880</a><td>    var top = heightAtLine(lineObj) + paddingTop(cm.display);<tr><td><a id="l2881"></a><a href="#l2881">2881</a><td>    return {left: left, right: left, top: top, bottom: top + lineObj.height};<tr><td><a id="l2882"></a><a href="#l2882">2882</a><td>  }<tr><td><a id="l2883"></a><a href="#l2883">2883</a><td><tr><td><a id="l2884"></a><a href="#l2884">2884</a><td>  // Positions returned by coordsChar contain some extra information.<tr><td><a id="l2885"></a><a href="#l2885">2885</a><td>  // xRel is the relative x position of the input coordinates compared<tr><td><a id="l2886"></a><a href="#l2886">2886</a><td>  // to the found position (so xRel &gt; 0 means the coordinates are to<tr><td><a id="l2887"></a><a href="#l2887">2887</a><td>  // the right of the character position, for example). When outside<tr><td><a id="l2888"></a><a href="#l2888">2888</a><td>  // is true, that means the coordinates lie outside the line&#39;s<tr><td><a id="l2889"></a><a href="#l2889">2889</a><td>  // vertical range.<tr><td><a id="l2890"></a><a href="#l2890">2890</a><td>  function PosWithInfo(line, ch, outside, xRel) {<tr><td><a id="l2891"></a><a href="#l2891">2891</a><td>    var pos = Pos(line, ch);<tr><td><a id="l2892"></a><a href="#l2892">2892</a><td>    pos.xRel = xRel;<tr><td><a id="l2893"></a><a href="#l2893">2893</a><td>    if (outside) pos.outside = true;<tr><td><a id="l2894"></a><a href="#l2894">2894</a><td>    return pos;<tr><td><a id="l2895"></a><a href="#l2895">2895</a><td>  }<tr><td><a id="l2896"></a><a href="#l2896">2896</a><td><tr><td><a id="l2897"></a><a href="#l2897">2897</a><td>  // Compute the character position closest to the given coordinates.<tr><td><a id="l2898"></a><a href="#l2898">2898</a><td>  // Input must be lineSpace-local (&quot;div&quot; coordinate system).<tr><td><a id="l2899"></a><a href="#l2899">2899</a><td>  function coordsChar(cm, x, y) {<tr><td><a id="l2900"></a><a href="#l2900">2900</a><td>    var doc = cm.doc;<tr><td><a id="l2901"></a><a href="#l2901">2901</a><td>    y += cm.display.viewOffset;<tr><td><a id="l2902"></a><a href="#l2902">2902</a><td>    if (y &lt; 0) return PosWithInfo(doc.first, 0, true, -1);<tr><td><a id="l2903"></a><a href="#l2903">2903</a><td>    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;<tr><td><a id="l2904"></a><a href="#l2904">2904</a><td>    if (lineN &gt; last)<tr><td><a id="l2905"></a><a href="#l2905">2905</a><td>      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);<tr><td><a id="l2906"></a><a href="#l2906">2906</a><td>    if (x &lt; 0) x = 0;<tr><td><a id="l2907"></a><a href="#l2907">2907</a><td><tr><td><a id="l2908"></a><a href="#l2908">2908</a><td>    var lineObj = getLine(doc, lineN);<tr><td><a id="l2909"></a><a href="#l2909">2909</a><td>    for (;;) {<tr><td><a id="l2910"></a><a href="#l2910">2910</a><td>      var found = coordsCharInner(cm, lineObj, lineN, x, y);<tr><td><a id="l2911"></a><a href="#l2911">2911</a><td>      var merged = collapsedSpanAtEnd(lineObj);<tr><td><a id="l2912"></a><a href="#l2912">2912</a><td>      var mergedPos = merged &amp;&amp; merged.find(0, true);<tr><td><a id="l2913"></a><a href="#l2913">2913</a><td>      if (merged &amp;&amp; (found.ch &gt; mergedPos.from.ch || found.ch == mergedPos.from.ch &amp;&amp; found.xRel &gt; 0))<tr><td><a id="l2914"></a><a href="#l2914">2914</a><td>        lineN = lineNo(lineObj = mergedPos.to.line);<tr><td><a id="l2915"></a><a href="#l2915">2915</a><td>      else<tr><td><a id="l2916"></a><a href="#l2916">2916</a><td>        return found;<tr><td><a id="l2917"></a><a href="#l2917">2917</a><td>    }<tr><td><a id="l2918"></a><a href="#l2918">2918</a><td>  }<tr><td><a id="l2919"></a><a href="#l2919">2919</a><td><tr><td><a id="l2920"></a><a href="#l2920">2920</a><td>  function coordsCharInner(cm, lineObj, lineNo, x, y) {<tr><td><a id="l2921"></a><a href="#l2921">2921</a><td>    var innerOff = y - heightAtLine(lineObj);<tr><td><a id="l2922"></a><a href="#l2922">2922</a><td>    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;<tr><td><a id="l2923"></a><a href="#l2923">2923</a><td>    var preparedMeasure = prepareMeasureForLine(cm, lineObj);<tr><td><a id="l2924"></a><a href="#l2924">2924</a><td><tr><td><a id="l2925"></a><a href="#l2925">2925</a><td>    function getX(ch) {<tr><td><a id="l2926"></a><a href="#l2926">2926</a><td>      var sp = cursorCoords(cm, Pos(lineNo, ch), &quot;line&quot;, lineObj, preparedMeasure);<tr><td><a id="l2927"></a><a href="#l2927">2927</a><td>      wrongLine = true;<tr><td><a id="l2928"></a><a href="#l2928">2928</a><td>      if (innerOff &gt; sp.bottom) return sp.left - adjust;<tr><td><a id="l2929"></a><a href="#l2929">2929</a><td>      else if (innerOff &lt; sp.top) return sp.left + adjust;<tr><td><a id="l2930"></a><a href="#l2930">2930</a><td>      else wrongLine = false;<tr><td><a id="l2931"></a><a href="#l2931">2931</a><td>      return sp.left;<tr><td><a id="l2932"></a><a href="#l2932">2932</a><td>    }<tr><td><a id="l2933"></a><a href="#l2933">2933</a><td><tr><td><a id="l2934"></a><a href="#l2934">2934</a><td>    var bidi = getOrder(lineObj), dist = lineObj.text.length;<tr><td><a id="l2935"></a><a href="#l2935">2935</a><td>    var from = lineLeft(lineObj), to = lineRight(lineObj);<tr><td><a id="l2936"></a><a href="#l2936">2936</a><td>    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;<tr><td><a id="l2937"></a><a href="#l2937">2937</a><td><tr><td><a id="l2938"></a><a href="#l2938">2938</a><td>    if (x &gt; toX) return PosWithInfo(lineNo, to, toOutside, 1);<tr><td><a id="l2939"></a><a href="#l2939">2939</a><td>    // Do a binary search between these bounds.<tr><td><a id="l2940"></a><a href="#l2940">2940</a><td>    for (;;) {<tr><td><a id="l2941"></a><a href="#l2941">2941</a><td>      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from &lt;= 1) {<tr><td><a id="l2942"></a><a href="#l2942">2942</a><td>        var ch = x &lt; fromX || x - fromX &lt;= toX - x ? from : to;<tr><td><a id="l2943"></a><a href="#l2943">2943</a><td>        var outside = ch == from ? fromOutside : toOutside<tr><td><a id="l2944"></a><a href="#l2944">2944</a><td>        var xDiff = x - (ch == from ? fromX : toX);<tr><td><a id="l2945"></a><a href="#l2945">2945</a><td>        // This is a kludge to handle the case where the coordinates<tr><td><a id="l2946"></a><a href="#l2946">2946</a><td>        // are after a line-wrapped line. We should replace it with a<tr><td><a id="l2947"></a><a href="#l2947">2947</a><td>        // more general handling of cursor positions around line<tr><td><a id="l2948"></a><a href="#l2948">2948</a><td>        // breaks. (Issue #4078)<tr><td><a id="l2949"></a><a href="#l2949">2949</a><td>        if (toOutside &amp;&amp; !bidi &amp;&amp; !/\s/.test(lineObj.text.charAt(ch)) &amp;&amp; xDiff &gt; 0 &amp;&amp;<tr><td><a id="l2950"></a><a href="#l2950">2950</a><td>            ch &lt; lineObj.text.length &amp;&amp; preparedMeasure.view.measure.heights.length &gt; 1) {<tr><td><a id="l2951"></a><a href="#l2951">2951</a><td>          var charSize = measureCharPrepared(cm, preparedMeasure, ch, &quot;right&quot;);<tr><td><a id="l2952"></a><a href="#l2952">2952</a><td>          if (innerOff &lt;= charSize.bottom &amp;&amp; innerOff &gt;= charSize.top &amp;&amp; Math.abs(x - charSize.right) &lt; xDiff) {<tr><td><a id="l2953"></a><a href="#l2953">2953</a><td>            outside = false<tr><td><a id="l2954"></a><a href="#l2954">2954</a><td>            ch++<tr><td><a id="l2955"></a><a href="#l2955">2955</a><td>            xDiff = x - charSize.right<tr><td><a id="l2956"></a><a href="#l2956">2956</a><td>          }<tr><td><a id="l2957"></a><a href="#l2957">2957</a><td>        }<tr><td><a id="l2958"></a><a href="#l2958">2958</a><td>        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;<tr><td><a id="l2959"></a><a href="#l2959">2959</a><td>        var pos = PosWithInfo(lineNo, ch, outside, xDiff &lt; -1 ? -1 : xDiff &gt; 1 ? 1 : 0);<tr><td><a id="l2960"></a><a href="#l2960">2960</a><td>        return pos;<tr><td><a id="l2961"></a><a href="#l2961">2961</a><td>      }<tr><td><a id="l2962"></a><a href="#l2962">2962</a><td>      var step = Math.ceil(dist / 2), middle = from + step;<tr><td><a id="l2963"></a><a href="#l2963">2963</a><td>      if (bidi) {<tr><td><a id="l2964"></a><a href="#l2964">2964</a><td>        middle = from;<tr><td><a id="l2965"></a><a href="#l2965">2965</a><td>        for (var i = 0; i &lt; step; ++i) middle = moveVisually(lineObj, middle, 1);<tr><td><a id="l2966"></a><a href="#l2966">2966</a><td>      }<tr><td><a id="l2967"></a><a href="#l2967">2967</a><td>      var middleX = getX(middle);<tr><td><a id="l2968"></a><a href="#l2968">2968</a><td>      if (middleX &gt; x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}<tr><td><a id="l2969"></a><a href="#l2969">2969</a><td>      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}<tr><td><a id="l2970"></a><a href="#l2970">2970</a><td>    }<tr><td><a id="l2971"></a><a href="#l2971">2971</a><td>  }<tr><td><a id="l2972"></a><a href="#l2972">2972</a><td><tr><td><a id="l2973"></a><a href="#l2973">2973</a><td>  var measureText;<tr><td><a id="l2974"></a><a href="#l2974">2974</a><td>  // Compute the default text height.<tr><td><a id="l2975"></a><a href="#l2975">2975</a><td>  function textHeight(display) {<tr><td><a id="l2976"></a><a href="#l2976">2976</a><td>    if (display.cachedTextHeight != null) return display.cachedTextHeight;<tr><td><a id="l2977"></a><a href="#l2977">2977</a><td>    if (measureText == null) {<tr><td><a id="l2978"></a><a href="#l2978">2978</a><td>      measureText = elt(&quot;pre&quot;);<tr><td><a id="l2979"></a><a href="#l2979">2979</a><td>      // Measure a bunch of lines, for browsers that compute<tr><td><a id="l2980"></a><a href="#l2980">2980</a><td>      // fractional heights.<tr><td><a id="l2981"></a><a href="#l2981">2981</a><td>      for (var i = 0; i &lt; 49; ++i) {<tr><td><a id="l2982"></a><a href="#l2982">2982</a><td>        measureText.appendChild(document.createTextNode(&quot;x&quot;));<tr><td><a id="l2983"></a><a href="#l2983">2983</a><td>        measureText.appendChild(elt(&quot;br&quot;));<tr><td><a id="l2984"></a><a href="#l2984">2984</a><td>      }<tr><td><a id="l2985"></a><a href="#l2985">2985</a><td>      measureText.appendChild(document.createTextNode(&quot;x&quot;));<tr><td><a id="l2986"></a><a href="#l2986">2986</a><td>    }<tr><td><a id="l2987"></a><a href="#l2987">2987</a><td>    removeChildrenAndAdd(display.measure, measureText);<tr><td><a id="l2988"></a><a href="#l2988">2988</a><td>    var height = measureText.offsetHeight / 50;<tr><td><a id="l2989"></a><a href="#l2989">2989</a><td>    if (height &gt; 3) display.cachedTextHeight = height;<tr><td><a id="l2990"></a><a href="#l2990">2990</a><td>    removeChildren(display.measure);<tr><td><a id="l2991"></a><a href="#l2991">2991</a><td>    return height || 1;<tr><td><a id="l2992"></a><a href="#l2992">2992</a><td>  }<tr><td><a id="l2993"></a><a href="#l2993">2993</a><td><tr><td><a id="l2994"></a><a href="#l2994">2994</a><td>  // Compute the default character width.<tr><td><a id="l2995"></a><a href="#l2995">2995</a><td>  function charWidth(display) {<tr><td><a id="l2996"></a><a href="#l2996">2996</a><td>    if (display.cachedCharWidth != null) return display.cachedCharWidth;<tr><td><a id="l2997"></a><a href="#l2997">2997</a><td>    var anchor = elt(&quot;span&quot;, &quot;xxxxxxxxxx&quot;);<tr><td><a id="l2998"></a><a href="#l2998">2998</a><td>    var pre = elt(&quot;pre&quot;, [anchor]);<tr><td><a id="l2999"></a><a href="#l2999">2999</a><td>    removeChildrenAndAdd(display.measure, pre);<tr><td><a id="l3000"></a><a href="#l3000">3000</a><td>    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;<tr><td><a id="l3001"></a><a href="#l3001">3001</a><td>    if (width &gt; 2) display.cachedCharWidth = width;<tr><td><a id="l3002"></a><a href="#l3002">3002</a><td>    return width || 10;<tr><td><a id="l3003"></a><a href="#l3003">3003</a><td>  }<tr><td><a id="l3004"></a><a href="#l3004">3004</a><td><tr><td><a id="l3005"></a><a href="#l3005">3005</a><td>  // OPERATIONS<tr><td><a id="l3006"></a><a href="#l3006">3006</a><td><tr><td><a id="l3007"></a><a href="#l3007">3007</a><td>  // Operations are used to wrap a series of changes to the editor<tr><td><a id="l3008"></a><a href="#l3008">3008</a><td>  // state in such a way that each change won&#39;t have to update the<tr><td><a id="l3009"></a><a href="#l3009">3009</a><td>  // cursor and display (which would be awkward, slow, and<tr><td><a id="l3010"></a><a href="#l3010">3010</a><td>  // error-prone). Instead, display updates are batched and then all<tr><td><a id="l3011"></a><a href="#l3011">3011</a><td>  // combined and executed at once.<tr><td><a id="l3012"></a><a href="#l3012">3012</a><td><tr><td><a id="l3013"></a><a href="#l3013">3013</a><td>  var operationGroup = null;<tr><td><a id="l3014"></a><a href="#l3014">3014</a><td><tr><td><a id="l3015"></a><a href="#l3015">3015</a><td>  var nextOpId = 0;<tr><td><a id="l3016"></a><a href="#l3016">3016</a><td>  // Start a new operation.<tr><td><a id="l3017"></a><a href="#l3017">3017</a><td>  function startOperation(cm) {<tr><td><a id="l3018"></a><a href="#l3018">3018</a><td>    cm.curOp = {<tr><td><a id="l3019"></a><a href="#l3019">3019</a><td>      cm: cm,<tr><td><a id="l3020"></a><a href="#l3020">3020</a><td>      viewChanged: false,      // Flag that indicates that lines might need to be redrawn<tr><td><a id="l3021"></a><a href="#l3021">3021</a><td>      startHeight: cm.doc.height, // Used to detect need to update scrollbar<tr><td><a id="l3022"></a><a href="#l3022">3022</a><td>      forceUpdate: false,      // Used to force a redraw<tr><td><a id="l3023"></a><a href="#l3023">3023</a><td>      updateInput: null,       // Whether to reset the input textarea<tr><td><a id="l3024"></a><a href="#l3024">3024</a><td>      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)<tr><td><a id="l3025"></a><a href="#l3025">3025</a><td>      changeObjs: null,        // Accumulated changes, for firing change events<tr><td><a id="l3026"></a><a href="#l3026">3026</a><td>      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on<tr><td><a id="l3027"></a><a href="#l3027">3027</a><td>      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already<tr><td><a id="l3028"></a><a href="#l3028">3028</a><td>      selectionChanged: false, // Whether the selection needs to be redrawn<tr><td><a id="l3029"></a><a href="#l3029">3029</a><td>      updateMaxLine: false,    // Set when the widest line needs to be determined anew<tr><td><a id="l3030"></a><a href="#l3030">3030</a><td>      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet<tr><td><a id="l3031"></a><a href="#l3031">3031</a><td>      scrollToPos: null,       // Used to scroll to a specific position<tr><td><a id="l3032"></a><a href="#l3032">3032</a><td>      focus: false,<tr><td><a id="l3033"></a><a href="#l3033">3033</a><td>      id: ++nextOpId           // Unique ID<tr><td><a id="l3034"></a><a href="#l3034">3034</a><td>    };<tr><td><a id="l3035"></a><a href="#l3035">3035</a><td>    if (operationGroup) {<tr><td><a id="l3036"></a><a href="#l3036">3036</a><td>      operationGroup.ops.push(cm.curOp);<tr><td><a id="l3037"></a><a href="#l3037">3037</a><td>    } else {<tr><td><a id="l3038"></a><a href="#l3038">3038</a><td>      cm.curOp.ownsGroup = operationGroup = {<tr><td><a id="l3039"></a><a href="#l3039">3039</a><td>        ops: [cm.curOp],<tr><td><a id="l3040"></a><a href="#l3040">3040</a><td>        delayedCallbacks: []<tr><td><a id="l3041"></a><a href="#l3041">3041</a><td>      };<tr><td><a id="l3042"></a><a href="#l3042">3042</a><td>    }<tr><td><a id="l3043"></a><a href="#l3043">3043</a><td>  }<tr><td><a id="l3044"></a><a href="#l3044">3044</a><td><tr><td><a id="l3045"></a><a href="#l3045">3045</a><td>  function fireCallbacksForOps(group) {<tr><td><a id="l3046"></a><a href="#l3046">3046</a><td>    // Calls delayed callbacks and cursorActivity handlers until no<tr><td><a id="l3047"></a><a href="#l3047">3047</a><td>    // new ones appear<tr><td><a id="l3048"></a><a href="#l3048">3048</a><td>    var callbacks = group.delayedCallbacks, i = 0;<tr><td><a id="l3049"></a><a href="#l3049">3049</a><td>    do {<tr><td><a id="l3050"></a><a href="#l3050">3050</a><td>      for (; i &lt; callbacks.length; i++)<tr><td><a id="l3051"></a><a href="#l3051">3051</a><td>        callbacks[i].call(null);<tr><td><a id="l3052"></a><a href="#l3052">3052</a><td>      for (var j = 0; j &lt; group.ops.length; j++) {<tr><td><a id="l3053"></a><a href="#l3053">3053</a><td>        var op = group.ops[j];<tr><td><a id="l3054"></a><a href="#l3054">3054</a><td>        if (op.cursorActivityHandlers)<tr><td><a id="l3055"></a><a href="#l3055">3055</a><td>          while (op.cursorActivityCalled &lt; op.cursorActivityHandlers.length)<tr><td><a id="l3056"></a><a href="#l3056">3056</a><td>            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);<tr><td><a id="l3057"></a><a href="#l3057">3057</a><td>      }<tr><td><a id="l3058"></a><a href="#l3058">3058</a><td>    } while (i &lt; callbacks.length);<tr><td><a id="l3059"></a><a href="#l3059">3059</a><td>  }<tr><td><a id="l3060"></a><a href="#l3060">3060</a><td><tr><td><a id="l3061"></a><a href="#l3061">3061</a><td>  // Finish an operation, updating the display and signalling delayed events<tr><td><a id="l3062"></a><a href="#l3062">3062</a><td>  function endOperation(cm) {<tr><td><a id="l3063"></a><a href="#l3063">3063</a><td>    var op = cm.curOp, group = op.ownsGroup;<tr><td><a id="l3064"></a><a href="#l3064">3064</a><td>    if (!group) return;<tr><td><a id="l3065"></a><a href="#l3065">3065</a><td><tr><td><a id="l3066"></a><a href="#l3066">3066</a><td>    try { fireCallbacksForOps(group); }<tr><td><a id="l3067"></a><a href="#l3067">3067</a><td>    finally {<tr><td><a id="l3068"></a><a href="#l3068">3068</a><td>      operationGroup = null;<tr><td><a id="l3069"></a><a href="#l3069">3069</a><td>      for (var i = 0; i &lt; group.ops.length; i++)<tr><td><a id="l3070"></a><a href="#l3070">3070</a><td>        group.ops[i].cm.curOp = null;<tr><td><a id="l3071"></a><a href="#l3071">3071</a><td>      endOperations(group);<tr><td><a id="l3072"></a><a href="#l3072">3072</a><td>    }<tr><td><a id="l3073"></a><a href="#l3073">3073</a><td>  }<tr><td><a id="l3074"></a><a href="#l3074">3074</a><td><tr><td><a id="l3075"></a><a href="#l3075">3075</a><td>  // The DOM updates done when an operation finishes are batched so<tr><td><a id="l3076"></a><a href="#l3076">3076</a><td>  // that the minimum number of relayouts are required.<tr><td><a id="l3077"></a><a href="#l3077">3077</a><td>  function endOperations(group) {<tr><td><a id="l3078"></a><a href="#l3078">3078</a><td>    var ops = group.ops;<tr><td><a id="l3079"></a><a href="#l3079">3079</a><td>    for (var i = 0; i &lt; ops.length; i++) // Read DOM<tr><td><a id="l3080"></a><a href="#l3080">3080</a><td>      endOperation_R1(ops[i]);<tr><td><a id="l3081"></a><a href="#l3081">3081</a><td>    for (var i = 0; i &lt; ops.length; i++) // Write DOM (maybe)<tr><td><a id="l3082"></a><a href="#l3082">3082</a><td>      endOperation_W1(ops[i]);<tr><td><a id="l3083"></a><a href="#l3083">3083</a><td>    for (var i = 0; i &lt; ops.length; i++) // Read DOM<tr><td><a id="l3084"></a><a href="#l3084">3084</a><td>      endOperation_R2(ops[i]);<tr><td><a id="l3085"></a><a href="#l3085">3085</a><td>    for (var i = 0; i &lt; ops.length; i++) // Write DOM (maybe)<tr><td><a id="l3086"></a><a href="#l3086">3086</a><td>      endOperation_W2(ops[i]);<tr><td><a id="l3087"></a><a href="#l3087">3087</a><td>    for (var i = 0; i &lt; ops.length; i++) // Read DOM<tr><td><a id="l3088"></a><a href="#l3088">3088</a><td>      endOperation_finish(ops[i]);<tr><td><a id="l3089"></a><a href="#l3089">3089</a><td>  }<tr><td><a id="l3090"></a><a href="#l3090">3090</a><td><tr><td><a id="l3091"></a><a href="#l3091">3091</a><td>  function endOperation_R1(op) {<tr><td><a id="l3092"></a><a href="#l3092">3092</a><td>    var cm = op.cm, display = cm.display;<tr><td><a id="l3093"></a><a href="#l3093">3093</a><td>    maybeClipScrollbars(cm);<tr><td><a id="l3094"></a><a href="#l3094">3094</a><td>    if (op.updateMaxLine) findMaxLine(cm);<tr><td><a id="l3095"></a><a href="#l3095">3095</a><td><tr><td><a id="l3096"></a><a href="#l3096">3096</a><td>    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||<tr><td><a id="l3097"></a><a href="#l3097">3097</a><td>      op.scrollToPos &amp;&amp; (op.scrollToPos.from.line &lt; display.viewFrom ||<tr><td><a id="l3098"></a><a href="#l3098">3098</a><td>                         op.scrollToPos.to.line &gt;= display.viewTo) ||<tr><td><a id="l3099"></a><a href="#l3099">3099</a><td>      display.maxLineChanged &amp;&amp; cm.options.lineWrapping;<tr><td><a id="l3100"></a><a href="#l3100">3100</a><td>    op.update = op.mustUpdate &amp;&amp;<tr><td><a id="l3101"></a><a href="#l3101">3101</a><td>      new DisplayUpdate(cm, op.mustUpdate &amp;&amp; {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);<tr><td><a id="l3102"></a><a href="#l3102">3102</a><td>  }<tr><td><a id="l3103"></a><a href="#l3103">3103</a><td><tr><td><a id="l3104"></a><a href="#l3104">3104</a><td>  function endOperation_W1(op) {<tr><td><a id="l3105"></a><a href="#l3105">3105</a><td>    op.updatedDisplay = op.mustUpdate &amp;&amp; updateDisplayIfNeeded(op.cm, op.update);<tr><td><a id="l3106"></a><a href="#l3106">3106</a><td>  }<tr><td><a id="l3107"></a><a href="#l3107">3107</a><td><tr><td><a id="l3108"></a><a href="#l3108">3108</a><td>  function endOperation_R2(op) {<tr><td><a id="l3109"></a><a href="#l3109">3109</a><td>    var cm = op.cm, display = cm.display;<tr><td><a id="l3110"></a><a href="#l3110">3110</a><td>    if (op.updatedDisplay) updateHeightsInViewport(cm);<tr><td><a id="l3111"></a><a href="#l3111">3111</a><td><tr><td><a id="l3112"></a><a href="#l3112">3112</a><td>    op.barMeasure = measureForScrollbars(cm);<tr><td><a id="l3113"></a><a href="#l3113">3113</a><td><tr><td><a id="l3114"></a><a href="#l3114">3114</a><td>    // If the max line changed since it was last measured, measure it,<tr><td><a id="l3115"></a><a href="#l3115">3115</a><td>    // and ensure the document&#39;s width matches it.<tr><td><a id="l3116"></a><a href="#l3116">3116</a><td>    // updateDisplay_W2 will use these properties to do the actual resizing<tr><td><a id="l3117"></a><a href="#l3117">3117</a><td>    if (display.maxLineChanged &amp;&amp; !cm.options.lineWrapping) {<tr><td><a id="l3118"></a><a href="#l3118">3118</a><td>      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;<tr><td><a id="l3119"></a><a href="#l3119">3119</a><td>      cm.display.sizerWidth = op.adjustWidthTo;<tr><td><a id="l3120"></a><a href="#l3120">3120</a><td>      op.barMeasure.scrollWidth =<tr><td><a id="l3121"></a><a href="#l3121">3121</a><td>        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);<tr><td><a id="l3122"></a><a href="#l3122">3122</a><td>      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));<tr><td><a id="l3123"></a><a href="#l3123">3123</a><td>    }<tr><td><a id="l3124"></a><a href="#l3124">3124</a><td><tr><td><a id="l3125"></a><a href="#l3125">3125</a><td>    if (op.updatedDisplay || op.selectionChanged)<tr><td><a id="l3126"></a><a href="#l3126">3126</a><td>      op.preparedSelection = display.input.prepareSelection(op.focus);<tr><td><a id="l3127"></a><a href="#l3127">3127</a><td>  }<tr><td><a id="l3128"></a><a href="#l3128">3128</a><td><tr><td><a id="l3129"></a><a href="#l3129">3129</a><td>  function endOperation_W2(op) {<tr><td><a id="l3130"></a><a href="#l3130">3130</a><td>    var cm = op.cm;<tr><td><a id="l3131"></a><a href="#l3131">3131</a><td><tr><td><a id="l3132"></a><a href="#l3132">3132</a><td>    if (op.adjustWidthTo != null) {<tr><td><a id="l3133"></a><a href="#l3133">3133</a><td>      cm.display.sizer.style.minWidth = op.adjustWidthTo + &quot;px&quot;;<tr><td><a id="l3134"></a><a href="#l3134">3134</a><td>      if (op.maxScrollLeft &lt; cm.doc.scrollLeft)<tr><td><a id="l3135"></a><a href="#l3135">3135</a><td>        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);<tr><td><a id="l3136"></a><a href="#l3136">3136</a><td>      cm.display.maxLineChanged = false;<tr><td><a id="l3137"></a><a href="#l3137">3137</a><td>    }<tr><td><a id="l3138"></a><a href="#l3138">3138</a><td><tr><td><a id="l3139"></a><a href="#l3139">3139</a><td>    var takeFocus = op.focus &amp;&amp; op.focus == activeElt() &amp;&amp; (!document.hasFocus || document.hasFocus())<tr><td><a id="l3140"></a><a href="#l3140">3140</a><td>    if (op.preparedSelection)<tr><td><a id="l3141"></a><a href="#l3141">3141</a><td>      cm.display.input.showSelection(op.preparedSelection, takeFocus);<tr><td><a id="l3142"></a><a href="#l3142">3142</a><td>    if (op.updatedDisplay || op.startHeight != cm.doc.height)<tr><td><a id="l3143"></a><a href="#l3143">3143</a><td>      updateScrollbars(cm, op.barMeasure);<tr><td><a id="l3144"></a><a href="#l3144">3144</a><td>    if (op.updatedDisplay)<tr><td><a id="l3145"></a><a href="#l3145">3145</a><td>      setDocumentHeight(cm, op.barMeasure);<tr><td><a id="l3146"></a><a href="#l3146">3146</a><td><tr><td><a id="l3147"></a><a href="#l3147">3147</a><td>    if (op.selectionChanged) restartBlink(cm);<tr><td><a id="l3148"></a><a href="#l3148">3148</a><td><tr><td><a id="l3149"></a><a href="#l3149">3149</a><td>    if (cm.state.focused &amp;&amp; op.updateInput)<tr><td><a id="l3150"></a><a href="#l3150">3150</a><td>      cm.display.input.reset(op.typing);<tr><td><a id="l3151"></a><a href="#l3151">3151</a><td>    if (takeFocus) ensureFocus(op.cm);<tr><td><a id="l3152"></a><a href="#l3152">3152</a><td>  }<tr><td><a id="l3153"></a><a href="#l3153">3153</a><td><tr><td><a id="l3154"></a><a href="#l3154">3154</a><td>  function endOperation_finish(op) {<tr><td><a id="l3155"></a><a href="#l3155">3155</a><td>    var cm = op.cm, display = cm.display, doc = cm.doc;<tr><td><a id="l3156"></a><a href="#l3156">3156</a><td><tr><td><a id="l3157"></a><a href="#l3157">3157</a><td>    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);<tr><td><a id="l3158"></a><a href="#l3158">3158</a><td><tr><td><a id="l3159"></a><a href="#l3159">3159</a><td>    // Abort mouse wheel delta measurement, when scrolling explicitly<tr><td><a id="l3160"></a><a href="#l3160">3160</a><td>    if (display.wheelStartX != null &amp;&amp; (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))<tr><td><a id="l3161"></a><a href="#l3161">3161</a><td>      display.wheelStartX = display.wheelStartY = null;<tr><td><a id="l3162"></a><a href="#l3162">3162</a><td><tr><td><a id="l3163"></a><a href="#l3163">3163</a><td>    // Propagate the scroll position to the actual DOM scroller<tr><td><a id="l3164"></a><a href="#l3164">3164</a><td>    if (op.scrollTop != null &amp;&amp; (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {<tr><td><a id="l3165"></a><a href="#l3165">3165</a><td>      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));<tr><td><a id="l3166"></a><a href="#l3166">3166</a><td>      display.scrollbars.setScrollTop(doc.scrollTop);<tr><td><a id="l3167"></a><a href="#l3167">3167</a><td>      display.scroller.scrollTop = doc.scrollTop;<tr><td><a id="l3168"></a><a href="#l3168">3168</a><td>    }<tr><td><a id="l3169"></a><a href="#l3169">3169</a><td>    if (op.scrollLeft != null &amp;&amp; (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {<tr><td><a id="l3170"></a><a href="#l3170">3170</a><td>      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));<tr><td><a id="l3171"></a><a href="#l3171">3171</a><td>      display.scrollbars.setScrollLeft(doc.scrollLeft);<tr><td><a id="l3172"></a><a href="#l3172">3172</a><td>      display.scroller.scrollLeft = doc.scrollLeft;<tr><td><a id="l3173"></a><a href="#l3173">3173</a><td>      alignHorizontally(cm);<tr><td><a id="l3174"></a><a href="#l3174">3174</a><td>    }<tr><td><a id="l3175"></a><a href="#l3175">3175</a><td>    // If we need to scroll a specific position into view, do so.<tr><td><a id="l3176"></a><a href="#l3176">3176</a><td>    if (op.scrollToPos) {<tr><td><a id="l3177"></a><a href="#l3177">3177</a><td>      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),<tr><td><a id="l3178"></a><a href="#l3178">3178</a><td>                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);<tr><td><a id="l3179"></a><a href="#l3179">3179</a><td>      if (op.scrollToPos.isCursor &amp;&amp; cm.state.focused) maybeScrollWindow(cm, coords);<tr><td><a id="l3180"></a><a href="#l3180">3180</a><td>    }<tr><td><a id="l3181"></a><a href="#l3181">3181</a><td><tr><td><a id="l3182"></a><a href="#l3182">3182</a><td>    // Fire events for markers that are hidden/unidden by editing or<tr><td><a id="l3183"></a><a href="#l3183">3183</a><td>    // undoing<tr><td><a id="l3184"></a><a href="#l3184">3184</a><td>    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;<tr><td><a id="l3185"></a><a href="#l3185">3185</a><td>    if (hidden) for (var i = 0; i &lt; hidden.length; ++i)<tr><td><a id="l3186"></a><a href="#l3186">3186</a><td>      if (!hidden[i].lines.length) signal(hidden[i], &quot;hide&quot;);<tr><td><a id="l3187"></a><a href="#l3187">3187</a><td>    if (unhidden) for (var i = 0; i &lt; unhidden.length; ++i)<tr><td><a id="l3188"></a><a href="#l3188">3188</a><td>      if (unhidden[i].lines.length) signal(unhidden[i], &quot;unhide&quot;);<tr><td><a id="l3189"></a><a href="#l3189">3189</a><td><tr><td><a id="l3190"></a><a href="#l3190">3190</a><td>    if (display.wrapper.offsetHeight)<tr><td><a id="l3191"></a><a href="#l3191">3191</a><td>      doc.scrollTop = cm.display.scroller.scrollTop;<tr><td><a id="l3192"></a><a href="#l3192">3192</a><td><tr><td><a id="l3193"></a><a href="#l3193">3193</a><td>    // Fire change events, and delayed event handlers<tr><td><a id="l3194"></a><a href="#l3194">3194</a><td>    if (op.changeObjs)<tr><td><a id="l3195"></a><a href="#l3195">3195</a><td>      signal(cm, &quot;changes&quot;, cm, op.changeObjs);<tr><td><a id="l3196"></a><a href="#l3196">3196</a><td>    if (op.update)<tr><td><a id="l3197"></a><a href="#l3197">3197</a><td>      op.update.finish();<tr><td><a id="l3198"></a><a href="#l3198">3198</a><td>  }<tr><td><a id="l3199"></a><a href="#l3199">3199</a><td><tr><td><a id="l3200"></a><a href="#l3200">3200</a><td>  // Run the given function in an operation<tr><td><a id="l3201"></a><a href="#l3201">3201</a><td>  function runInOp(cm, f) {<tr><td><a id="l3202"></a><a href="#l3202">3202</a><td>    if (cm.curOp) return f();<tr><td><a id="l3203"></a><a href="#l3203">3203</a><td>    startOperation(cm);<tr><td><a id="l3204"></a><a href="#l3204">3204</a><td>    try { return f(); }<tr><td><a id="l3205"></a><a href="#l3205">3205</a><td>    finally { endOperation(cm); }<tr><td><a id="l3206"></a><a href="#l3206">3206</a><td>  }<tr><td><a id="l3207"></a><a href="#l3207">3207</a><td>  // Wraps a function in an operation. Returns the wrapped function.<tr><td><a id="l3208"></a><a href="#l3208">3208</a><td>  function operation(cm, f) {<tr><td><a id="l3209"></a><a href="#l3209">3209</a><td>    return function() {<tr><td><a id="l3210"></a><a href="#l3210">3210</a><td>      if (cm.curOp) return f.apply(cm, arguments);<tr><td><a id="l3211"></a><a href="#l3211">3211</a><td>      startOperation(cm);<tr><td><a id="l3212"></a><a href="#l3212">3212</a><td>      try { return f.apply(cm, arguments); }<tr><td><a id="l3213"></a><a href="#l3213">3213</a><td>      finally { endOperation(cm); }<tr><td><a id="l3214"></a><a href="#l3214">3214</a><td>    };<tr><td><a id="l3215"></a><a href="#l3215">3215</a><td>  }<tr><td><a id="l3216"></a><a href="#l3216">3216</a><td>  // Used to add methods to editor and doc instances, wrapping them in<tr><td><a id="l3217"></a><a href="#l3217">3217</a><td>  // operations.<tr><td><a id="l3218"></a><a href="#l3218">3218</a><td>  function methodOp(f) {<tr><td><a id="l3219"></a><a href="#l3219">3219</a><td>    return function() {<tr><td><a id="l3220"></a><a href="#l3220">3220</a><td>      if (this.curOp) return f.apply(this, arguments);<tr><td><a id="l3221"></a><a href="#l3221">3221</a><td>      startOperation(this);<tr><td><a id="l3222"></a><a href="#l3222">3222</a><td>      try { return f.apply(this, arguments); }<tr><td><a id="l3223"></a><a href="#l3223">3223</a><td>      finally { endOperation(this); }<tr><td><a id="l3224"></a><a href="#l3224">3224</a><td>    };<tr><td><a id="l3225"></a><a href="#l3225">3225</a><td>  }<tr><td><a id="l3226"></a><a href="#l3226">3226</a><td>  function docMethodOp(f) {<tr><td><a id="l3227"></a><a href="#l3227">3227</a><td>    return function() {<tr><td><a id="l3228"></a><a href="#l3228">3228</a><td>      var cm = this.cm;<tr><td><a id="l3229"></a><a href="#l3229">3229</a><td>      if (!cm || cm.curOp) return f.apply(this, arguments);<tr><td><a id="l3230"></a><a href="#l3230">3230</a><td>      startOperation(cm);<tr><td><a id="l3231"></a><a href="#l3231">3231</a><td>      try { return f.apply(this, arguments); }<tr><td><a id="l3232"></a><a href="#l3232">3232</a><td>      finally { endOperation(cm); }<tr><td><a id="l3233"></a><a href="#l3233">3233</a><td>    };<tr><td><a id="l3234"></a><a href="#l3234">3234</a><td>  }<tr><td><a id="l3235"></a><a href="#l3235">3235</a><td><tr><td><a id="l3236"></a><a href="#l3236">3236</a><td>  // VIEW TRACKING<tr><td><a id="l3237"></a><a href="#l3237">3237</a><td><tr><td><a id="l3238"></a><a href="#l3238">3238</a><td>  // These objects are used to represent the visible (currently drawn)<tr><td><a id="l3239"></a><a href="#l3239">3239</a><td>  // part of the document. A LineView may correspond to multiple<tr><td><a id="l3240"></a><a href="#l3240">3240</a><td>  // logical lines, if those are connected by collapsed ranges.<tr><td><a id="l3241"></a><a href="#l3241">3241</a><td>  function LineView(doc, line, lineN) {<tr><td><a id="l3242"></a><a href="#l3242">3242</a><td>    // The starting line<tr><td><a id="l3243"></a><a href="#l3243">3243</a><td>    this.line = line;<tr><td><a id="l3244"></a><a href="#l3244">3244</a><td>    // Continuing lines, if any<tr><td><a id="l3245"></a><a href="#l3245">3245</a><td>    this.rest = visualLineContinued(line);<tr><td><a id="l3246"></a><a href="#l3246">3246</a><td>    // Number of logical lines in this visual line<tr><td><a id="l3247"></a><a href="#l3247">3247</a><td>    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;<tr><td><a id="l3248"></a><a href="#l3248">3248</a><td>    this.node = this.text = null;<tr><td><a id="l3249"></a><a href="#l3249">3249</a><td>    this.hidden = lineIsHidden(doc, line);<tr><td><a id="l3250"></a><a href="#l3250">3250</a><td>  }<tr><td><a id="l3251"></a><a href="#l3251">3251</a><td><tr><td><a id="l3252"></a><a href="#l3252">3252</a><td>  // Create a range of LineView objects for the given lines.<tr><td><a id="l3253"></a><a href="#l3253">3253</a><td>  function buildViewArray(cm, from, to) {<tr><td><a id="l3254"></a><a href="#l3254">3254</a><td>    var array = [], nextPos;<tr><td><a id="l3255"></a><a href="#l3255">3255</a><td>    for (var pos = from; pos &lt; to; pos = nextPos) {<tr><td><a id="l3256"></a><a href="#l3256">3256</a><td>      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);<tr><td><a id="l3257"></a><a href="#l3257">3257</a><td>      nextPos = pos + view.size;<tr><td><a id="l3258"></a><a href="#l3258">3258</a><td>      array.push(view);<tr><td><a id="l3259"></a><a href="#l3259">3259</a><td>    }<tr><td><a id="l3260"></a><a href="#l3260">3260</a><td>    return array;<tr><td><a id="l3261"></a><a href="#l3261">3261</a><td>  }<tr><td><a id="l3262"></a><a href="#l3262">3262</a><td><tr><td><a id="l3263"></a><a href="#l3263">3263</a><td>  // Updates the display.view data structure for a given change to the<tr><td><a id="l3264"></a><a href="#l3264">3264</a><td>  // document. From and to are in pre-change coordinates. Lendiff is<tr><td><a id="l3265"></a><a href="#l3265">3265</a><td>  // the amount of lines added or subtracted by the change. This is<tr><td><a id="l3266"></a><a href="#l3266">3266</a><td>  // used for changes that span multiple lines, or change the way<tr><td><a id="l3267"></a><a href="#l3267">3267</a><td>  // lines are divided into visual lines. regLineChange (below)<tr><td><a id="l3268"></a><a href="#l3268">3268</a><td>  // registers single-line changes.<tr><td><a id="l3269"></a><a href="#l3269">3269</a><td>  function regChange(cm, from, to, lendiff) {<tr><td><a id="l3270"></a><a href="#l3270">3270</a><td>    if (from == null) from = cm.doc.first;<tr><td><a id="l3271"></a><a href="#l3271">3271</a><td>    if (to == null) to = cm.doc.first + cm.doc.size;<tr><td><a id="l3272"></a><a href="#l3272">3272</a><td>    if (!lendiff) lendiff = 0;<tr><td><a id="l3273"></a><a href="#l3273">3273</a><td><tr><td><a id="l3274"></a><a href="#l3274">3274</a><td>    var display = cm.display;<tr><td><a id="l3275"></a><a href="#l3275">3275</a><td>    if (lendiff &amp;&amp; to &lt; display.viewTo &amp;&amp;<tr><td><a id="l3276"></a><a href="#l3276">3276</a><td>        (display.updateLineNumbers == null || display.updateLineNumbers &gt; from))<tr><td><a id="l3277"></a><a href="#l3277">3277</a><td>      display.updateLineNumbers = from;<tr><td><a id="l3278"></a><a href="#l3278">3278</a><td><tr><td><a id="l3279"></a><a href="#l3279">3279</a><td>    cm.curOp.viewChanged = true;<tr><td><a id="l3280"></a><a href="#l3280">3280</a><td><tr><td><a id="l3281"></a><a href="#l3281">3281</a><td>    if (from &gt;= display.viewTo) { // Change after<tr><td><a id="l3282"></a><a href="#l3282">3282</a><td>      if (sawCollapsedSpans &amp;&amp; visualLineNo(cm.doc, from) &lt; display.viewTo)<tr><td><a id="l3283"></a><a href="#l3283">3283</a><td>        resetView(cm);<tr><td><a id="l3284"></a><a href="#l3284">3284</a><td>    } else if (to &lt;= display.viewFrom) { // Change before<tr><td><a id="l3285"></a><a href="#l3285">3285</a><td>      if (sawCollapsedSpans &amp;&amp; visualLineEndNo(cm.doc, to + lendiff) &gt; display.viewFrom) {<tr><td><a id="l3286"></a><a href="#l3286">3286</a><td>        resetView(cm);<tr><td><a id="l3287"></a><a href="#l3287">3287</a><td>      } else {<tr><td><a id="l3288"></a><a href="#l3288">3288</a><td>        display.viewFrom += lendiff;<tr><td><a id="l3289"></a><a href="#l3289">3289</a><td>        display.viewTo += lendiff;<tr><td><a id="l3290"></a><a href="#l3290">3290</a><td>      }<tr><td><a id="l3291"></a><a href="#l3291">3291</a><td>    } else if (from &lt;= display.viewFrom &amp;&amp; to &gt;= display.viewTo) { // Full overlap<tr><td><a id="l3292"></a><a href="#l3292">3292</a><td>      resetView(cm);<tr><td><a id="l3293"></a><a href="#l3293">3293</a><td>    } else if (from &lt;= display.viewFrom) { // Top overlap<tr><td><a id="l3294"></a><a href="#l3294">3294</a><td>      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);<tr><td><a id="l3295"></a><a href="#l3295">3295</a><td>      if (cut) {<tr><td><a id="l3296"></a><a href="#l3296">3296</a><td>        display.view = display.view.slice(cut.index);<tr><td><a id="l3297"></a><a href="#l3297">3297</a><td>        display.viewFrom = cut.lineN;<tr><td><a id="l3298"></a><a href="#l3298">3298</a><td>        display.viewTo += lendiff;<tr><td><a id="l3299"></a><a href="#l3299">3299</a><td>      } else {<tr><td><a id="l3300"></a><a href="#l3300">3300</a><td>        resetView(cm);<tr><td><a id="l3301"></a><a href="#l3301">3301</a><td>      }<tr><td><a id="l3302"></a><a href="#l3302">3302</a><td>    } else if (to &gt;= display.viewTo) { // Bottom overlap<tr><td><a id="l3303"></a><a href="#l3303">3303</a><td>      var cut = viewCuttingPoint(cm, from, from, -1);<tr><td><a id="l3304"></a><a href="#l3304">3304</a><td>      if (cut) {<tr><td><a id="l3305"></a><a href="#l3305">3305</a><td>        display.view = display.view.slice(0, cut.index);<tr><td><a id="l3306"></a><a href="#l3306">3306</a><td>        display.viewTo = cut.lineN;<tr><td><a id="l3307"></a><a href="#l3307">3307</a><td>      } else {<tr><td><a id="l3308"></a><a href="#l3308">3308</a><td>        resetView(cm);<tr><td><a id="l3309"></a><a href="#l3309">3309</a><td>      }<tr><td><a id="l3310"></a><a href="#l3310">3310</a><td>    } else { // Gap in the middle<tr><td><a id="l3311"></a><a href="#l3311">3311</a><td>      var cutTop = viewCuttingPoint(cm, from, from, -1);<tr><td><a id="l3312"></a><a href="#l3312">3312</a><td>      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);<tr><td><a id="l3313"></a><a href="#l3313">3313</a><td>      if (cutTop &amp;&amp; cutBot) {<tr><td><a id="l3314"></a><a href="#l3314">3314</a><td>        display.view = display.view.slice(0, cutTop.index)<tr><td><a id="l3315"></a><a href="#l3315">3315</a><td>          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))<tr><td><a id="l3316"></a><a href="#l3316">3316</a><td>          .concat(display.view.slice(cutBot.index));<tr><td><a id="l3317"></a><a href="#l3317">3317</a><td>        display.viewTo += lendiff;<tr><td><a id="l3318"></a><a href="#l3318">3318</a><td>      } else {<tr><td><a id="l3319"></a><a href="#l3319">3319</a><td>        resetView(cm);<tr><td><a id="l3320"></a><a href="#l3320">3320</a><td>      }<tr><td><a id="l3321"></a><a href="#l3321">3321</a><td>    }<tr><td><a id="l3322"></a><a href="#l3322">3322</a><td><tr><td><a id="l3323"></a><a href="#l3323">3323</a><td>    var ext = display.externalMeasured;<tr><td><a id="l3324"></a><a href="#l3324">3324</a><td>    if (ext) {<tr><td><a id="l3325"></a><a href="#l3325">3325</a><td>      if (to &lt; ext.lineN)<tr><td><a id="l3326"></a><a href="#l3326">3326</a><td>        ext.lineN += lendiff;<tr><td><a id="l3327"></a><a href="#l3327">3327</a><td>      else if (from &lt; ext.lineN + ext.size)<tr><td><a id="l3328"></a><a href="#l3328">3328</a><td>        display.externalMeasured = null;<tr><td><a id="l3329"></a><a href="#l3329">3329</a><td>    }<tr><td><a id="l3330"></a><a href="#l3330">3330</a><td>  }<tr><td><a id="l3331"></a><a href="#l3331">3331</a><td><tr><td><a id="l3332"></a><a href="#l3332">3332</a><td>  // Register a change to a single line. Type must be one of &quot;text&quot;,<tr><td><a id="l3333"></a><a href="#l3333">3333</a><td>  // &quot;gutter&quot;, &quot;class&quot;, &quot;widget&quot;<tr><td><a id="l3334"></a><a href="#l3334">3334</a><td>  function regLineChange(cm, line, type) {<tr><td><a id="l3335"></a><a href="#l3335">3335</a><td>    cm.curOp.viewChanged = true;<tr><td><a id="l3336"></a><a href="#l3336">3336</a><td>    var display = cm.display, ext = cm.display.externalMeasured;<tr><td><a id="l3337"></a><a href="#l3337">3337</a><td>    if (ext &amp;&amp; line &gt;= ext.lineN &amp;&amp; line &lt; ext.lineN + ext.size)<tr><td><a id="l3338"></a><a href="#l3338">3338</a><td>      display.externalMeasured = null;<tr><td><a id="l3339"></a><a href="#l3339">3339</a><td><tr><td><a id="l3340"></a><a href="#l3340">3340</a><td>    if (line &lt; display.viewFrom || line &gt;= display.viewTo) return;<tr><td><a id="l3341"></a><a href="#l3341">3341</a><td>    var lineView = display.view[findViewIndex(cm, line)];<tr><td><a id="l3342"></a><a href="#l3342">3342</a><td>    if (lineView.node == null) return;<tr><td><a id="l3343"></a><a href="#l3343">3343</a><td>    var arr = lineView.changes || (lineView.changes = []);<tr><td><a id="l3344"></a><a href="#l3344">3344</a><td>    if (indexOf(arr, type) == -1) arr.push(type);<tr><td><a id="l3345"></a><a href="#l3345">3345</a><td>  }<tr><td><a id="l3346"></a><a href="#l3346">3346</a><td><tr><td><a id="l3347"></a><a href="#l3347">3347</a><td>  // Clear the view.<tr><td><a id="l3348"></a><a href="#l3348">3348</a><td>  function resetView(cm) {<tr><td><a id="l3349"></a><a href="#l3349">3349</a><td>    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;<tr><td><a id="l3350"></a><a href="#l3350">3350</a><td>    cm.display.view = [];<tr><td><a id="l3351"></a><a href="#l3351">3351</a><td>    cm.display.viewOffset = 0;<tr><td><a id="l3352"></a><a href="#l3352">3352</a><td>  }<tr><td><a id="l3353"></a><a href="#l3353">3353</a><td><tr><td><a id="l3354"></a><a href="#l3354">3354</a><td>  // Find the view element corresponding to a given line. Return null<tr><td><a id="l3355"></a><a href="#l3355">3355</a><td>  // when the line isn&#39;t visible.<tr><td><a id="l3356"></a><a href="#l3356">3356</a><td>  function findViewIndex(cm, n) {<tr><td><a id="l3357"></a><a href="#l3357">3357</a><td>    if (n &gt;= cm.display.viewTo) return null;<tr><td><a id="l3358"></a><a href="#l3358">3358</a><td>    n -= cm.display.viewFrom;<tr><td><a id="l3359"></a><a href="#l3359">3359</a><td>    if (n &lt; 0) return null;<tr><td><a id="l3360"></a><a href="#l3360">3360</a><td>    var view = cm.display.view;<tr><td><a id="l3361"></a><a href="#l3361">3361</a><td>    for (var i = 0; i &lt; view.length; i++) {<tr><td><a id="l3362"></a><a href="#l3362">3362</a><td>      n -= view[i].size;<tr><td><a id="l3363"></a><a href="#l3363">3363</a><td>      if (n &lt; 0) return i;<tr><td><a id="l3364"></a><a href="#l3364">3364</a><td>    }<tr><td><a id="l3365"></a><a href="#l3365">3365</a><td>  }<tr><td><a id="l3366"></a><a href="#l3366">3366</a><td><tr><td><a id="l3367"></a><a href="#l3367">3367</a><td>  function viewCuttingPoint(cm, oldN, newN, dir) {<tr><td><a id="l3368"></a><a href="#l3368">3368</a><td>    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;<tr><td><a id="l3369"></a><a href="#l3369">3369</a><td>    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)<tr><td><a id="l3370"></a><a href="#l3370">3370</a><td>      return {index: index, lineN: newN};<tr><td><a id="l3371"></a><a href="#l3371">3371</a><td>    for (var i = 0, n = cm.display.viewFrom; i &lt; index; i++)<tr><td><a id="l3372"></a><a href="#l3372">3372</a><td>      n += view[i].size;<tr><td><a id="l3373"></a><a href="#l3373">3373</a><td>    if (n != oldN) {<tr><td><a id="l3374"></a><a href="#l3374">3374</a><td>      if (dir &gt; 0) {<tr><td><a id="l3375"></a><a href="#l3375">3375</a><td>        if (index == view.length - 1) return null;<tr><td><a id="l3376"></a><a href="#l3376">3376</a><td>        diff = (n + view[index].size) - oldN;<tr><td><a id="l3377"></a><a href="#l3377">3377</a><td>        index++;<tr><td><a id="l3378"></a><a href="#l3378">3378</a><td>      } else {<tr><td><a id="l3379"></a><a href="#l3379">3379</a><td>        diff = n - oldN;<tr><td><a id="l3380"></a><a href="#l3380">3380</a><td>      }<tr><td><a id="l3381"></a><a href="#l3381">3381</a><td>      oldN += diff; newN += diff;<tr><td><a id="l3382"></a><a href="#l3382">3382</a><td>    }<tr><td><a id="l3383"></a><a href="#l3383">3383</a><td>    while (visualLineNo(cm.doc, newN) != newN) {<tr><td><a id="l3384"></a><a href="#l3384">3384</a><td>      if (index == (dir &lt; 0 ? 0 : view.length - 1)) return null;<tr><td><a id="l3385"></a><a href="#l3385">3385</a><td>      newN += dir * view[index - (dir &lt; 0 ? 1 : 0)].size;<tr><td><a id="l3386"></a><a href="#l3386">3386</a><td>      index += dir;<tr><td><a id="l3387"></a><a href="#l3387">3387</a><td>    }<tr><td><a id="l3388"></a><a href="#l3388">3388</a><td>    return {index: index, lineN: newN};<tr><td><a id="l3389"></a><a href="#l3389">3389</a><td>  }<tr><td><a id="l3390"></a><a href="#l3390">3390</a><td><tr><td><a id="l3391"></a><a href="#l3391">3391</a><td>  // Force the view to cover a given range, adding empty view element<tr><td><a id="l3392"></a><a href="#l3392">3392</a><td>  // or clipping off existing ones as needed.<tr><td><a id="l3393"></a><a href="#l3393">3393</a><td>  function adjustView(cm, from, to) {<tr><td><a id="l3394"></a><a href="#l3394">3394</a><td>    var display = cm.display, view = display.view;<tr><td><a id="l3395"></a><a href="#l3395">3395</a><td>    if (view.length == 0 || from &gt;= display.viewTo || to &lt;= display.viewFrom) {<tr><td><a id="l3396"></a><a href="#l3396">3396</a><td>      display.view = buildViewArray(cm, from, to);<tr><td><a id="l3397"></a><a href="#l3397">3397</a><td>      display.viewFrom = from;<tr><td><a id="l3398"></a><a href="#l3398">3398</a><td>    } else {<tr><td><a id="l3399"></a><a href="#l3399">3399</a><td>      if (display.viewFrom &gt; from)<tr><td><a id="l3400"></a><a href="#l3400">3400</a><td>        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);<tr><td><a id="l3401"></a><a href="#l3401">3401</a><td>      else if (display.viewFrom &lt; from)<tr><td><a id="l3402"></a><a href="#l3402">3402</a><td>        display.view = display.view.slice(findViewIndex(cm, from));<tr><td><a id="l3403"></a><a href="#l3403">3403</a><td>      display.viewFrom = from;<tr><td><a id="l3404"></a><a href="#l3404">3404</a><td>      if (display.viewTo &lt; to)<tr><td><a id="l3405"></a><a href="#l3405">3405</a><td>        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));<tr><td><a id="l3406"></a><a href="#l3406">3406</a><td>      else if (display.viewTo &gt; to)<tr><td><a id="l3407"></a><a href="#l3407">3407</a><td>        display.view = display.view.slice(0, findViewIndex(cm, to));<tr><td><a id="l3408"></a><a href="#l3408">3408</a><td>    }<tr><td><a id="l3409"></a><a href="#l3409">3409</a><td>    display.viewTo = to;<tr><td><a id="l3410"></a><a href="#l3410">3410</a><td>  }<tr><td><a id="l3411"></a><a href="#l3411">3411</a><td><tr><td><a id="l3412"></a><a href="#l3412">3412</a><td>  // Count the number of lines in the view whose DOM representation is<tr><td><a id="l3413"></a><a href="#l3413">3413</a><td>  // out of date (or nonexistent).<tr><td><a id="l3414"></a><a href="#l3414">3414</a><td>  function countDirtyView(cm) {<tr><td><a id="l3415"></a><a href="#l3415">3415</a><td>    var view = cm.display.view, dirty = 0;<tr><td><a id="l3416"></a><a href="#l3416">3416</a><td>    for (var i = 0; i &lt; view.length; i++) {<tr><td><a id="l3417"></a><a href="#l3417">3417</a><td>      var lineView = view[i];<tr><td><a id="l3418"></a><a href="#l3418">3418</a><td>      if (!lineView.hidden &amp;&amp; (!lineView.node || lineView.changes)) ++dirty;<tr><td><a id="l3419"></a><a href="#l3419">3419</a><td>    }<tr><td><a id="l3420"></a><a href="#l3420">3420</a><td>    return dirty;<tr><td><a id="l3421"></a><a href="#l3421">3421</a><td>  }<tr><td><a id="l3422"></a><a href="#l3422">3422</a><td><tr><td><a id="l3423"></a><a href="#l3423">3423</a><td>  // EVENT HANDLERS<tr><td><a id="l3424"></a><a href="#l3424">3424</a><td><tr><td><a id="l3425"></a><a href="#l3425">3425</a><td>  // Attach the necessary event handlers when initializing the editor<tr><td><a id="l3426"></a><a href="#l3426">3426</a><td>  function registerEventHandlers(cm) {<tr><td><a id="l3427"></a><a href="#l3427">3427</a><td>    var d = cm.display;<tr><td><a id="l3428"></a><a href="#l3428">3428</a><td>    on(d.scroller, &quot;mousedown&quot;, operation(cm, onMouseDown));<tr><td><a id="l3429"></a><a href="#l3429">3429</a><td>    // Older IE&#39;s will not fire a second mousedown for a double click<tr><td><a id="l3430"></a><a href="#l3430">3430</a><td>    if (ie &amp;&amp; ie_version &lt; 11)<tr><td><a id="l3431"></a><a href="#l3431">3431</a><td>      on(d.scroller, &quot;dblclick&quot;, operation(cm, function(e) {<tr><td><a id="l3432"></a><a href="#l3432">3432</a><td>        if (signalDOMEvent(cm, e)) return;<tr><td><a id="l3433"></a><a href="#l3433">3433</a><td>        var pos = posFromMouse(cm, e);<tr><td><a id="l3434"></a><a href="#l3434">3434</a><td>        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;<tr><td><a id="l3435"></a><a href="#l3435">3435</a><td>        e_preventDefault(e);<tr><td><a id="l3436"></a><a href="#l3436">3436</a><td>        var word = cm.findWordAt(pos);<tr><td><a id="l3437"></a><a href="#l3437">3437</a><td>        extendSelection(cm.doc, word.anchor, word.head);<tr><td><a id="l3438"></a><a href="#l3438">3438</a><td>      }));<tr><td><a id="l3439"></a><a href="#l3439">3439</a><td>    else<tr><td><a id="l3440"></a><a href="#l3440">3440</a><td>      on(d.scroller, &quot;dblclick&quot;, function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });<tr><td><a id="l3441"></a><a href="#l3441">3441</a><td>    // Some browsers fire contextmenu *after* opening the menu, at<tr><td><a id="l3442"></a><a href="#l3442">3442</a><td>    // which point we can&#39;t mess with it anymore. Context menu is<tr><td><a id="l3443"></a><a href="#l3443">3443</a><td>    // handled in onMouseDown for these browsers.<tr><td><a id="l3444"></a><a href="#l3444">3444</a><td>    if (!captureRightClick) on(d.scroller, &quot;contextmenu&quot;, function(e) {onContextMenu(cm, e);});<tr><td><a id="l3445"></a><a href="#l3445">3445</a><td><tr><td><a id="l3446"></a><a href="#l3446">3446</a><td>    // Used to suppress mouse event handling when a touch happens<tr><td><a id="l3447"></a><a href="#l3447">3447</a><td>    var touchFinished, prevTouch = {end: 0};<tr><td><a id="l3448"></a><a href="#l3448">3448</a><td>    function finishTouch() {<tr><td><a id="l3449"></a><a href="#l3449">3449</a><td>      if (d.activeTouch) {<tr><td><a id="l3450"></a><a href="#l3450">3450</a><td>        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);<tr><td><a id="l3451"></a><a href="#l3451">3451</a><td>        prevTouch = d.activeTouch;<tr><td><a id="l3452"></a><a href="#l3452">3452</a><td>        prevTouch.end = +new Date;<tr><td><a id="l3453"></a><a href="#l3453">3453</a><td>      }<tr><td><a id="l3454"></a><a href="#l3454">3454</a><td>    };<tr><td><a id="l3455"></a><a href="#l3455">3455</a><td>    function isMouseLikeTouchEvent(e) {<tr><td><a id="l3456"></a><a href="#l3456">3456</a><td>      if (e.touches.length != 1) return false;<tr><td><a id="l3457"></a><a href="#l3457">3457</a><td>      var touch = e.touches[0];<tr><td><a id="l3458"></a><a href="#l3458">3458</a><td>      return touch.radiusX &lt;= 1 &amp;&amp; touch.radiusY &lt;= 1;<tr><td><a id="l3459"></a><a href="#l3459">3459</a><td>    }<tr><td><a id="l3460"></a><a href="#l3460">3460</a><td>    function farAway(touch, other) {<tr><td><a id="l3461"></a><a href="#l3461">3461</a><td>      if (other.left == null) return true;<tr><td><a id="l3462"></a><a href="#l3462">3462</a><td>      var dx = other.left - touch.left, dy = other.top - touch.top;<tr><td><a id="l3463"></a><a href="#l3463">3463</a><td>      return dx * dx + dy * dy &gt; 20 * 20;<tr><td><a id="l3464"></a><a href="#l3464">3464</a><td>    }<tr><td><a id="l3465"></a><a href="#l3465">3465</a><td>    on(d.scroller, &quot;touchstart&quot;, function(e) {<tr><td><a id="l3466"></a><a href="#l3466">3466</a><td>      if (!signalDOMEvent(cm, e) &amp;&amp; !isMouseLikeTouchEvent(e)) {<tr><td><a id="l3467"></a><a href="#l3467">3467</a><td>        clearTimeout(touchFinished);<tr><td><a id="l3468"></a><a href="#l3468">3468</a><td>        var now = +new Date;<tr><td><a id="l3469"></a><a href="#l3469">3469</a><td>        d.activeTouch = {start: now, moved: false,<tr><td><a id="l3470"></a><a href="#l3470">3470</a><td>                         prev: now - prevTouch.end &lt;= 300 ? prevTouch : null};<tr><td><a id="l3471"></a><a href="#l3471">3471</a><td>        if (e.touches.length == 1) {<tr><td><a id="l3472"></a><a href="#l3472">3472</a><td>          d.activeTouch.left = e.touches[0].pageX;<tr><td><a id="l3473"></a><a href="#l3473">3473</a><td>          d.activeTouch.top = e.touches[0].pageY;<tr><td><a id="l3474"></a><a href="#l3474">3474</a><td>        }<tr><td><a id="l3475"></a><a href="#l3475">3475</a><td>      }<tr><td><a id="l3476"></a><a href="#l3476">3476</a><td>    });<tr><td><a id="l3477"></a><a href="#l3477">3477</a><td>    on(d.scroller, &quot;touchmove&quot;, function() {<tr><td><a id="l3478"></a><a href="#l3478">3478</a><td>      if (d.activeTouch) d.activeTouch.moved = true;<tr><td><a id="l3479"></a><a href="#l3479">3479</a><td>    });<tr><td><a id="l3480"></a><a href="#l3480">3480</a><td>    on(d.scroller, &quot;touchend&quot;, function(e) {<tr><td><a id="l3481"></a><a href="#l3481">3481</a><td>      var touch = d.activeTouch;<tr><td><a id="l3482"></a><a href="#l3482">3482</a><td>      if (touch &amp;&amp; !eventInWidget(d, e) &amp;&amp; touch.left != null &amp;&amp;<tr><td><a id="l3483"></a><a href="#l3483">3483</a><td>          !touch.moved &amp;&amp; new Date - touch.start &lt; 300) {<tr><td><a id="l3484"></a><a href="#l3484">3484</a><td>        var pos = cm.coordsChar(d.activeTouch, &quot;page&quot;), range;<tr><td><a id="l3485"></a><a href="#l3485">3485</a><td>        if (!touch.prev || farAway(touch, touch.prev)) // Single tap<tr><td><a id="l3486"></a><a href="#l3486">3486</a><td>          range = new Range(pos, pos);<tr><td><a id="l3487"></a><a href="#l3487">3487</a><td>        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap<tr><td><a id="l3488"></a><a href="#l3488">3488</a><td>          range = cm.findWordAt(pos);<tr><td><a id="l3489"></a><a href="#l3489">3489</a><td>        else // Triple tap<tr><td><a id="l3490"></a><a href="#l3490">3490</a><td>          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));<tr><td><a id="l3491"></a><a href="#l3491">3491</a><td>        cm.setSelection(range.anchor, range.head);<tr><td><a id="l3492"></a><a href="#l3492">3492</a><td>        cm.focus();<tr><td><a id="l3493"></a><a href="#l3493">3493</a><td>        e_preventDefault(e);<tr><td><a id="l3494"></a><a href="#l3494">3494</a><td>      }<tr><td><a id="l3495"></a><a href="#l3495">3495</a><td>      finishTouch();<tr><td><a id="l3496"></a><a href="#l3496">3496</a><td>    });<tr><td><a id="l3497"></a><a href="#l3497">3497</a><td>    on(d.scroller, &quot;touchcancel&quot;, finishTouch);<tr><td><a id="l3498"></a><a href="#l3498">3498</a><td><tr><td><a id="l3499"></a><a href="#l3499">3499</a><td>    // Sync scrolling between fake scrollbars and real scrollable<tr><td><a id="l3500"></a><a href="#l3500">3500</a><td>    // area, ensure viewport is updated when scrolling.<tr><td><a id="l3501"></a><a href="#l3501">3501</a><td>    on(d.scroller, &quot;scroll&quot;, function() {<tr><td><a id="l3502"></a><a href="#l3502">3502</a><td>      if (d.scroller.clientHeight) {<tr><td><a id="l3503"></a><a href="#l3503">3503</a><td>        setScrollTop(cm, d.scroller.scrollTop);<tr><td><a id="l3504"></a><a href="#l3504">3504</a><td>        setScrollLeft(cm, d.scroller.scrollLeft, true);<tr><td><a id="l3505"></a><a href="#l3505">3505</a><td>        signal(cm, &quot;scroll&quot;, cm);<tr><td><a id="l3506"></a><a href="#l3506">3506</a><td>      }<tr><td><a id="l3507"></a><a href="#l3507">3507</a><td>    });<tr><td><a id="l3508"></a><a href="#l3508">3508</a><td><tr><td><a id="l3509"></a><a href="#l3509">3509</a><td>    // Listen to wheel events in order to try and update the viewport on time.<tr><td><a id="l3510"></a><a href="#l3510">3510</a><td>    on(d.scroller, &quot;mousewheel&quot;, function(e){onScrollWheel(cm, e);});<tr><td><a id="l3511"></a><a href="#l3511">3511</a><td>    on(d.scroller, &quot;DOMMouseScroll&quot;, function(e){onScrollWheel(cm, e);});<tr><td><a id="l3512"></a><a href="#l3512">3512</a><td><tr><td><a id="l3513"></a><a href="#l3513">3513</a><td>    // Prevent wrapper from ever scrolling<tr><td><a id="l3514"></a><a href="#l3514">3514</a><td>    on(d.wrapper, &quot;scroll&quot;, function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });<tr><td><a id="l3515"></a><a href="#l3515">3515</a><td><tr><td><a id="l3516"></a><a href="#l3516">3516</a><td>    d.dragFunctions = {<tr><td><a id="l3517"></a><a href="#l3517">3517</a><td>      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},<tr><td><a id="l3518"></a><a href="#l3518">3518</a><td>      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},<tr><td><a id="l3519"></a><a href="#l3519">3519</a><td>      start: function(e){onDragStart(cm, e);},<tr><td><a id="l3520"></a><a href="#l3520">3520</a><td>      drop: operation(cm, onDrop),<tr><td><a id="l3521"></a><a href="#l3521">3521</a><td>      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}<tr><td><a id="l3522"></a><a href="#l3522">3522</a><td>    };<tr><td><a id="l3523"></a><a href="#l3523">3523</a><td><tr><td><a id="l3524"></a><a href="#l3524">3524</a><td>    var inp = d.input.getField();<tr><td><a id="l3525"></a><a href="#l3525">3525</a><td>    on(inp, &quot;keyup&quot;, function(e) { onKeyUp.call(cm, e); });<tr><td><a id="l3526"></a><a href="#l3526">3526</a><td>    on(inp, &quot;keydown&quot;, operation(cm, onKeyDown));<tr><td><a id="l3527"></a><a href="#l3527">3527</a><td>    on(inp, &quot;keypress&quot;, operation(cm, onKeyPress));<tr><td><a id="l3528"></a><a href="#l3528">3528</a><td>    on(inp, &quot;focus&quot;, bind(onFocus, cm));<tr><td><a id="l3529"></a><a href="#l3529">3529</a><td>    on(inp, &quot;blur&quot;, bind(onBlur, cm));<tr><td><a id="l3530"></a><a href="#l3530">3530</a><td>  }<tr><td><a id="l3531"></a><a href="#l3531">3531</a><td><tr><td><a id="l3532"></a><a href="#l3532">3532</a><td>  function dragDropChanged(cm, value, old) {<tr><td><a id="l3533"></a><a href="#l3533">3533</a><td>    var wasOn = old &amp;&amp; old != CodeMirror.Init;<tr><td><a id="l3534"></a><a href="#l3534">3534</a><td>    if (!value != !wasOn) {<tr><td><a id="l3535"></a><a href="#l3535">3535</a><td>      var funcs = cm.display.dragFunctions;<tr><td><a id="l3536"></a><a href="#l3536">3536</a><td>      var toggle = value ? on : off;<tr><td><a id="l3537"></a><a href="#l3537">3537</a><td>      toggle(cm.display.scroller, &quot;dragstart&quot;, funcs.start);<tr><td><a id="l3538"></a><a href="#l3538">3538</a><td>      toggle(cm.display.scroller, &quot;dragenter&quot;, funcs.enter);<tr><td><a id="l3539"></a><a href="#l3539">3539</a><td>      toggle(cm.display.scroller, &quot;dragover&quot;, funcs.over);<tr><td><a id="l3540"></a><a href="#l3540">3540</a><td>      toggle(cm.display.scroller, &quot;dragleave&quot;, funcs.leave);<tr><td><a id="l3541"></a><a href="#l3541">3541</a><td>      toggle(cm.display.scroller, &quot;drop&quot;, funcs.drop);<tr><td><a id="l3542"></a><a href="#l3542">3542</a><td>    }<tr><td><a id="l3543"></a><a href="#l3543">3543</a><td>  }<tr><td><a id="l3544"></a><a href="#l3544">3544</a><td><tr><td><a id="l3545"></a><a href="#l3545">3545</a><td>  // Called when the window resizes<tr><td><a id="l3546"></a><a href="#l3546">3546</a><td>  function onResize(cm) {<tr><td><a id="l3547"></a><a href="#l3547">3547</a><td>    var d = cm.display;<tr><td><a id="l3548"></a><a href="#l3548">3548</a><td>    if (d.lastWrapHeight == d.wrapper.clientHeight &amp;&amp; d.lastWrapWidth == d.wrapper.clientWidth)<tr><td><a id="l3549"></a><a href="#l3549">3549</a><td>      return;<tr><td><a id="l3550"></a><a href="#l3550">3550</a><td>    // Might be a text scaling operation, clear size caches.<tr><td><a id="l3551"></a><a href="#l3551">3551</a><td>    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;<tr><td><a id="l3552"></a><a href="#l3552">3552</a><td>    d.scrollbarsClipped = false;<tr><td><a id="l3553"></a><a href="#l3553">3553</a><td>    cm.setSize();<tr><td><a id="l3554"></a><a href="#l3554">3554</a><td>  }<tr><td><a id="l3555"></a><a href="#l3555">3555</a><td><tr><td><a id="l3556"></a><a href="#l3556">3556</a><td>  // MOUSE EVENTS<tr><td><a id="l3557"></a><a href="#l3557">3557</a><td><tr><td><a id="l3558"></a><a href="#l3558">3558</a><td>  // Return true when the given mouse event happened in a widget<tr><td><a id="l3559"></a><a href="#l3559">3559</a><td>  function eventInWidget(display, e) {<tr><td><a id="l3560"></a><a href="#l3560">3560</a><td>    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {<tr><td><a id="l3561"></a><a href="#l3561">3561</a><td>      if (!n || (n.nodeType == 1 &amp;&amp; n.getAttribute(&quot;cm-ignore-events&quot;) == &quot;true&quot;) ||<tr><td><a id="l3562"></a><a href="#l3562">3562</a><td>          (n.parentNode == display.sizer &amp;&amp; n != display.mover))<tr><td><a id="l3563"></a><a href="#l3563">3563</a><td>        return true;<tr><td><a id="l3564"></a><a href="#l3564">3564</a><td>    }<tr><td><a id="l3565"></a><a href="#l3565">3565</a><td>  }<tr><td><a id="l3566"></a><a href="#l3566">3566</a><td><tr><td><a id="l3567"></a><a href="#l3567">3567</a><td>  // Given a mouse event, find the corresponding position. If liberal<tr><td><a id="l3568"></a><a href="#l3568">3568</a><td>  // is false, it checks whether a gutter or scrollbar was clicked,<tr><td><a id="l3569"></a><a href="#l3569">3569</a><td>  // and returns null if it was. forRect is used by rectangular<tr><td><a id="l3570"></a><a href="#l3570">3570</a><td>  // selections, and tries to estimate a character position even for<tr><td><a id="l3571"></a><a href="#l3571">3571</a><td>  // coordinates beyond the right of the text.<tr><td><a id="l3572"></a><a href="#l3572">3572</a><td>  function posFromMouse(cm, e, liberal, forRect) {<tr><td><a id="l3573"></a><a href="#l3573">3573</a><td>    var display = cm.display;<tr><td><a id="l3574"></a><a href="#l3574">3574</a><td>    if (!liberal &amp;&amp; e_target(e).getAttribute(&quot;cm-not-content&quot;) == &quot;true&quot;) return null;<tr><td><a id="l3575"></a><a href="#l3575">3575</a><td><tr><td><a id="l3576"></a><a href="#l3576">3576</a><td>    var x, y, space = display.lineSpace.getBoundingClientRect();<tr><td><a id="l3577"></a><a href="#l3577">3577</a><td>    // Fails unpredictably on IE[67] when mouse is dragged around quickly.<tr><td><a id="l3578"></a><a href="#l3578">3578</a><td>    try { x = e.clientX - space.left; y = e.clientY - space.top; }<tr><td><a id="l3579"></a><a href="#l3579">3579</a><td>    catch (e) { return null; }<tr><td><a id="l3580"></a><a href="#l3580">3580</a><td>    var coords = coordsChar(cm, x, y), line;<tr><td><a id="l3581"></a><a href="#l3581">3581</a><td>    if (forRect &amp;&amp; coords.xRel == 1 &amp;&amp; (line = getLine(cm.doc, coords.line).text).length == coords.ch) {<tr><td><a id="l3582"></a><a href="#l3582">3582</a><td>      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;<tr><td><a id="l3583"></a><a href="#l3583">3583</a><td>      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));<tr><td><a id="l3584"></a><a href="#l3584">3584</a><td>    }<tr><td><a id="l3585"></a><a href="#l3585">3585</a><td>    return coords;<tr><td><a id="l3586"></a><a href="#l3586">3586</a><td>  }<tr><td><a id="l3587"></a><a href="#l3587">3587</a><td><tr><td><a id="l3588"></a><a href="#l3588">3588</a><td>  // A mouse down can be a single click, double click, triple click,<tr><td><a id="l3589"></a><a href="#l3589">3589</a><td>  // start of selection drag, start of text drag, new cursor<tr><td><a id="l3590"></a><a href="#l3590">3590</a><td>  // (ctrl-click), rectangle drag (alt-drag), or xwin<tr><td><a id="l3591"></a><a href="#l3591">3591</a><td>  // middle-click-paste. Or it might be a click on something we should<tr><td><a id="l3592"></a><a href="#l3592">3592</a><td>  // not interfere with, such as a scrollbar or widget.<tr><td><a id="l3593"></a><a href="#l3593">3593</a><td>  function onMouseDown(e) {<tr><td><a id="l3594"></a><a href="#l3594">3594</a><td>    var cm = this, display = cm.display;<tr><td><a id="l3595"></a><a href="#l3595">3595</a><td>    if (signalDOMEvent(cm, e) || display.activeTouch &amp;&amp; display.input.supportsTouch()) return;<tr><td><a id="l3596"></a><a href="#l3596">3596</a><td>    display.shift = e.shiftKey;<tr><td><a id="l3597"></a><a href="#l3597">3597</a><td><tr><td><a id="l3598"></a><a href="#l3598">3598</a><td>    if (eventInWidget(display, e)) {<tr><td><a id="l3599"></a><a href="#l3599">3599</a><td>      if (!webkit) {<tr><td><a id="l3600"></a><a href="#l3600">3600</a><td>        // Briefly turn off draggability, to allow widgets to do<tr><td><a id="l3601"></a><a href="#l3601">3601</a><td>        // normal dragging things.<tr><td><a id="l3602"></a><a href="#l3602">3602</a><td>        display.scroller.draggable = false;<tr><td><a id="l3603"></a><a href="#l3603">3603</a><td>        setTimeout(function(){display.scroller.draggable = true;}, 100);<tr><td><a id="l3604"></a><a href="#l3604">3604</a><td>      }<tr><td><a id="l3605"></a><a href="#l3605">3605</a><td>      return;<tr><td><a id="l3606"></a><a href="#l3606">3606</a><td>    }<tr><td><a id="l3607"></a><a href="#l3607">3607</a><td>    if (clickInGutter(cm, e)) return;<tr><td><a id="l3608"></a><a href="#l3608">3608</a><td>    var start = posFromMouse(cm, e);<tr><td><a id="l3609"></a><a href="#l3609">3609</a><td>    window.focus();<tr><td><a id="l3610"></a><a href="#l3610">3610</a><td><tr><td><a id="l3611"></a><a href="#l3611">3611</a><td>    switch (e_button(e)) {<tr><td><a id="l3612"></a><a href="#l3612">3612</a><td>    case 1:<tr><td><a id="l3613"></a><a href="#l3613">3613</a><td>      // #3261: make sure, that we&#39;re not starting a second selection<tr><td><a id="l3614"></a><a href="#l3614">3614</a><td>      if (cm.state.selectingText)<tr><td><a id="l3615"></a><a href="#l3615">3615</a><td>        cm.state.selectingText(e);<tr><td><a id="l3616"></a><a href="#l3616">3616</a><td>      else if (start)<tr><td><a id="l3617"></a><a href="#l3617">3617</a><td>        leftButtonDown(cm, e, start);<tr><td><a id="l3618"></a><a href="#l3618">3618</a><td>      else if (e_target(e) == display.scroller)<tr><td><a id="l3619"></a><a href="#l3619">3619</a><td>        e_preventDefault(e);<tr><td><a id="l3620"></a><a href="#l3620">3620</a><td>      break;<tr><td><a id="l3621"></a><a href="#l3621">3621</a><td>    case 2:<tr><td><a id="l3622"></a><a href="#l3622">3622</a><td>      if (webkit) cm.state.lastMiddleDown = +new Date;<tr><td><a id="l3623"></a><a href="#l3623">3623</a><td>      if (start) extendSelection(cm.doc, start);<tr><td><a id="l3624"></a><a href="#l3624">3624</a><td>      setTimeout(function() {display.input.focus();}, 20);<tr><td><a id="l3625"></a><a href="#l3625">3625</a><td>      e_preventDefault(e);<tr><td><a id="l3626"></a><a href="#l3626">3626</a><td>      break;<tr><td><a id="l3627"></a><a href="#l3627">3627</a><td>    case 3:<tr><td><a id="l3628"></a><a href="#l3628">3628</a><td>      if (captureRightClick) onContextMenu(cm, e);<tr><td><a id="l3629"></a><a href="#l3629">3629</a><td>      else delayBlurEvent(cm);<tr><td><a id="l3630"></a><a href="#l3630">3630</a><td>      break;<tr><td><a id="l3631"></a><a href="#l3631">3631</a><td>    }<tr><td><a id="l3632"></a><a href="#l3632">3632</a><td>  }<tr><td><a id="l3633"></a><a href="#l3633">3633</a><td><tr><td><a id="l3634"></a><a href="#l3634">3634</a><td>  var lastClick, lastDoubleClick;<tr><td><a id="l3635"></a><a href="#l3635">3635</a><td>  function leftButtonDown(cm, e, start) {<tr><td><a id="l3636"></a><a href="#l3636">3636</a><td>    if (ie) setTimeout(bind(ensureFocus, cm), 0);<tr><td><a id="l3637"></a><a href="#l3637">3637</a><td>    else cm.curOp.focus = activeElt();<tr><td><a id="l3638"></a><a href="#l3638">3638</a><td><tr><td><a id="l3639"></a><a href="#l3639">3639</a><td>    var now = +new Date, type;<tr><td><a id="l3640"></a><a href="#l3640">3640</a><td>    if (lastDoubleClick &amp;&amp; lastDoubleClick.time &gt; now - 400 &amp;&amp; cmp(lastDoubleClick.pos, start) == 0) {<tr><td><a id="l3641"></a><a href="#l3641">3641</a><td>      type = &quot;triple&quot;;<tr><td><a id="l3642"></a><a href="#l3642">3642</a><td>    } else if (lastClick &amp;&amp; lastClick.time &gt; now - 400 &amp;&amp; cmp(lastClick.pos, start) == 0) {<tr><td><a id="l3643"></a><a href="#l3643">3643</a><td>      type = &quot;double&quot;;<tr><td><a id="l3644"></a><a href="#l3644">3644</a><td>      lastDoubleClick = {time: now, pos: start};<tr><td><a id="l3645"></a><a href="#l3645">3645</a><td>    } else {<tr><td><a id="l3646"></a><a href="#l3646">3646</a><td>      type = &quot;single&quot;;<tr><td><a id="l3647"></a><a href="#l3647">3647</a><td>      lastClick = {time: now, pos: start};<tr><td><a id="l3648"></a><a href="#l3648">3648</a><td>    }<tr><td><a id="l3649"></a><a href="#l3649">3649</a><td><tr><td><a id="l3650"></a><a href="#l3650">3650</a><td>    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;<tr><td><a id="l3651"></a><a href="#l3651">3651</a><td>    if (cm.options.dragDrop &amp;&amp; dragAndDrop &amp;&amp; !cm.isReadOnly() &amp;&amp;<tr><td><a id="l3652"></a><a href="#l3652">3652</a><td>        type == &quot;single&quot; &amp;&amp; (contained = sel.contains(start)) &gt; -1 &amp;&amp;<tr><td><a id="l3653"></a><a href="#l3653">3653</a><td>        (cmp((contained = sel.ranges[contained]).from(), start) &lt; 0 || start.xRel &gt; 0) &amp;&amp;<tr><td><a id="l3654"></a><a href="#l3654">3654</a><td>        (cmp(contained.to(), start) &gt; 0 || start.xRel &lt; 0))<tr><td><a id="l3655"></a><a href="#l3655">3655</a><td>      leftButtonStartDrag(cm, e, start, modifier);<tr><td><a id="l3656"></a><a href="#l3656">3656</a><td>    else<tr><td><a id="l3657"></a><a href="#l3657">3657</a><td>      leftButtonSelect(cm, e, start, type, modifier);<tr><td><a id="l3658"></a><a href="#l3658">3658</a><td>  }<tr><td><a id="l3659"></a><a href="#l3659">3659</a><td><tr><td><a id="l3660"></a><a href="#l3660">3660</a><td>  // Start a text drag. When it ends, see if any dragging actually<tr><td><a id="l3661"></a><a href="#l3661">3661</a><td>  // happen, and treat as a click if it didn&#39;t.<tr><td><a id="l3662"></a><a href="#l3662">3662</a><td>  function leftButtonStartDrag(cm, e, start, modifier) {<tr><td><a id="l3663"></a><a href="#l3663">3663</a><td>    var display = cm.display, startTime = +new Date;<tr><td><a id="l3664"></a><a href="#l3664">3664</a><td>    var dragEnd = operation(cm, function(e2) {<tr><td><a id="l3665"></a><a href="#l3665">3665</a><td>      if (webkit) display.scroller.draggable = false;<tr><td><a id="l3666"></a><a href="#l3666">3666</a><td>      cm.state.draggingText = false;<tr><td><a id="l3667"></a><a href="#l3667">3667</a><td>      off(document, &quot;mouseup&quot;, dragEnd);<tr><td><a id="l3668"></a><a href="#l3668">3668</a><td>      off(display.scroller, &quot;drop&quot;, dragEnd);<tr><td><a id="l3669"></a><a href="#l3669">3669</a><td>      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) &lt; 10) {<tr><td><a id="l3670"></a><a href="#l3670">3670</a><td>        e_preventDefault(e2);<tr><td><a id="l3671"></a><a href="#l3671">3671</a><td>        if (!modifier &amp;&amp; +new Date - 200 &lt; startTime)<tr><td><a id="l3672"></a><a href="#l3672">3672</a><td>          extendSelection(cm.doc, start);<tr><td><a id="l3673"></a><a href="#l3673">3673</a><td>        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)<tr><td><a id="l3674"></a><a href="#l3674">3674</a><td>        if (webkit || ie &amp;&amp; ie_version == 9)<tr><td><a id="l3675"></a><a href="#l3675">3675</a><td>          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);<tr><td><a id="l3676"></a><a href="#l3676">3676</a><td>        else<tr><td><a id="l3677"></a><a href="#l3677">3677</a><td>          display.input.focus();<tr><td><a id="l3678"></a><a href="#l3678">3678</a><td>      }<tr><td><a id="l3679"></a><a href="#l3679">3679</a><td>    });<tr><td><a id="l3680"></a><a href="#l3680">3680</a><td>    // Let the drag handler handle this.<tr><td><a id="l3681"></a><a href="#l3681">3681</a><td>    if (webkit) display.scroller.draggable = true;<tr><td><a id="l3682"></a><a href="#l3682">3682</a><td>    cm.state.draggingText = dragEnd;<tr><td><a id="l3683"></a><a href="#l3683">3683</a><td>    dragEnd.copy = mac ? e.altKey : e.ctrlKey<tr><td><a id="l3684"></a><a href="#l3684">3684</a><td>    // IE&#39;s approach to draggable<tr><td><a id="l3685"></a><a href="#l3685">3685</a><td>    if (display.scroller.dragDrop) display.scroller.dragDrop();<tr><td><a id="l3686"></a><a href="#l3686">3686</a><td>    on(document, &quot;mouseup&quot;, dragEnd);<tr><td><a id="l3687"></a><a href="#l3687">3687</a><td>    on(display.scroller, &quot;drop&quot;, dragEnd);<tr><td><a id="l3688"></a><a href="#l3688">3688</a><td>  }<tr><td><a id="l3689"></a><a href="#l3689">3689</a><td><tr><td><a id="l3690"></a><a href="#l3690">3690</a><td>  // Normal selection, as opposed to text dragging.<tr><td><a id="l3691"></a><a href="#l3691">3691</a><td>  function leftButtonSelect(cm, e, start, type, addNew) {<tr><td><a id="l3692"></a><a href="#l3692">3692</a><td>    var display = cm.display, doc = cm.doc;<tr><td><a id="l3693"></a><a href="#l3693">3693</a><td>    e_preventDefault(e);<tr><td><a id="l3694"></a><a href="#l3694">3694</a><td><tr><td><a id="l3695"></a><a href="#l3695">3695</a><td>    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;<tr><td><a id="l3696"></a><a href="#l3696">3696</a><td>    if (addNew &amp;&amp; !e.shiftKey) {<tr><td><a id="l3697"></a><a href="#l3697">3697</a><td>      ourIndex = doc.sel.contains(start);<tr><td><a id="l3698"></a><a href="#l3698">3698</a><td>      if (ourIndex &gt; -1)<tr><td><a id="l3699"></a><a href="#l3699">3699</a><td>        ourRange = ranges[ourIndex];<tr><td><a id="l3700"></a><a href="#l3700">3700</a><td>      else<tr><td><a id="l3701"></a><a href="#l3701">3701</a><td>        ourRange = new Range(start, start);<tr><td><a id="l3702"></a><a href="#l3702">3702</a><td>    } else {<tr><td><a id="l3703"></a><a href="#l3703">3703</a><td>      ourRange = doc.sel.primary();<tr><td><a id="l3704"></a><a href="#l3704">3704</a><td>      ourIndex = doc.sel.primIndex;<tr><td><a id="l3705"></a><a href="#l3705">3705</a><td>    }<tr><td><a id="l3706"></a><a href="#l3706">3706</a><td><tr><td><a id="l3707"></a><a href="#l3707">3707</a><td>    if (chromeOS ? e.shiftKey &amp;&amp; e.metaKey : e.altKey) {<tr><td><a id="l3708"></a><a href="#l3708">3708</a><td>      type = &quot;rect&quot;;<tr><td><a id="l3709"></a><a href="#l3709">3709</a><td>      if (!addNew) ourRange = new Range(start, start);<tr><td><a id="l3710"></a><a href="#l3710">3710</a><td>      start = posFromMouse(cm, e, true, true);<tr><td><a id="l3711"></a><a href="#l3711">3711</a><td>      ourIndex = -1;<tr><td><a id="l3712"></a><a href="#l3712">3712</a><td>    } else if (type == &quot;double&quot;) {<tr><td><a id="l3713"></a><a href="#l3713">3713</a><td>      var word = cm.findWordAt(start);<tr><td><a id="l3714"></a><a href="#l3714">3714</a><td>      if (cm.display.shift || doc.extend)<tr><td><a id="l3715"></a><a href="#l3715">3715</a><td>        ourRange = extendRange(doc, ourRange, word.anchor, word.head);<tr><td><a id="l3716"></a><a href="#l3716">3716</a><td>      else<tr><td><a id="l3717"></a><a href="#l3717">3717</a><td>        ourRange = word;<tr><td><a id="l3718"></a><a href="#l3718">3718</a><td>    } else if (type == &quot;triple&quot;) {<tr><td><a id="l3719"></a><a href="#l3719">3719</a><td>      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));<tr><td><a id="l3720"></a><a href="#l3720">3720</a><td>      if (cm.display.shift || doc.extend)<tr><td><a id="l3721"></a><a href="#l3721">3721</a><td>        ourRange = extendRange(doc, ourRange, line.anchor, line.head);<tr><td><a id="l3722"></a><a href="#l3722">3722</a><td>      else<tr><td><a id="l3723"></a><a href="#l3723">3723</a><td>        ourRange = line;<tr><td><a id="l3724"></a><a href="#l3724">3724</a><td>    } else {<tr><td><a id="l3725"></a><a href="#l3725">3725</a><td>      ourRange = extendRange(doc, ourRange, start);<tr><td><a id="l3726"></a><a href="#l3726">3726</a><td>    }<tr><td><a id="l3727"></a><a href="#l3727">3727</a><td><tr><td><a id="l3728"></a><a href="#l3728">3728</a><td>    if (!addNew) {<tr><td><a id="l3729"></a><a href="#l3729">3729</a><td>      ourIndex = 0;<tr><td><a id="l3730"></a><a href="#l3730">3730</a><td>      setSelection(doc, new Selection([ourRange], 0), sel_mouse);<tr><td><a id="l3731"></a><a href="#l3731">3731</a><td>      startSel = doc.sel;<tr><td><a id="l3732"></a><a href="#l3732">3732</a><td>    } else if (ourIndex == -1) {<tr><td><a id="l3733"></a><a href="#l3733">3733</a><td>      ourIndex = ranges.length;<tr><td><a id="l3734"></a><a href="#l3734">3734</a><td>      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),<tr><td><a id="l3735"></a><a href="#l3735">3735</a><td>                   {scroll: false, origin: &quot;*mouse&quot;});<tr><td><a id="l3736"></a><a href="#l3736">3736</a><td>    } else if (ranges.length &gt; 1 &amp;&amp; ranges[ourIndex].empty() &amp;&amp; type == &quot;single&quot; &amp;&amp; !e.shiftKey) {<tr><td><a id="l3737"></a><a href="#l3737">3737</a><td>      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),<tr><td><a id="l3738"></a><a href="#l3738">3738</a><td>                   {scroll: false, origin: &quot;*mouse&quot;});<tr><td><a id="l3739"></a><a href="#l3739">3739</a><td>      startSel = doc.sel;<tr><td><a id="l3740"></a><a href="#l3740">3740</a><td>    } else {<tr><td><a id="l3741"></a><a href="#l3741">3741</a><td>      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);<tr><td><a id="l3742"></a><a href="#l3742">3742</a><td>    }<tr><td><a id="l3743"></a><a href="#l3743">3743</a><td><tr><td><a id="l3744"></a><a href="#l3744">3744</a><td>    var lastPos = start;<tr><td><a id="l3745"></a><a href="#l3745">3745</a><td>    function extendTo(pos) {<tr><td><a id="l3746"></a><a href="#l3746">3746</a><td>      if (cmp(lastPos, pos) == 0) return;<tr><td><a id="l3747"></a><a href="#l3747">3747</a><td>      lastPos = pos;<tr><td><a id="l3748"></a><a href="#l3748">3748</a><td><tr><td><a id="l3749"></a><a href="#l3749">3749</a><td>      if (type == &quot;rect&quot;) {<tr><td><a id="l3750"></a><a href="#l3750">3750</a><td>        var ranges = [], tabSize = cm.options.tabSize;<tr><td><a id="l3751"></a><a href="#l3751">3751</a><td>        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);<tr><td><a id="l3752"></a><a href="#l3752">3752</a><td>        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);<tr><td><a id="l3753"></a><a href="#l3753">3753</a><td>        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);<tr><td><a id="l3754"></a><a href="#l3754">3754</a><td>        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));<tr><td><a id="l3755"></a><a href="#l3755">3755</a><td>             line &lt;= end; line++) {<tr><td><a id="l3756"></a><a href="#l3756">3756</a><td>          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);<tr><td><a id="l3757"></a><a href="#l3757">3757</a><td>          if (left == right)<tr><td><a id="l3758"></a><a href="#l3758">3758</a><td>            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));<tr><td><a id="l3759"></a><a href="#l3759">3759</a><td>          else if (text.length &gt; leftPos)<tr><td><a id="l3760"></a><a href="#l3760">3760</a><td>            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));<tr><td><a id="l3761"></a><a href="#l3761">3761</a><td>        }<tr><td><a id="l3762"></a><a href="#l3762">3762</a><td>        if (!ranges.length) ranges.push(new Range(start, start));<tr><td><a id="l3763"></a><a href="#l3763">3763</a><td>        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),<tr><td><a id="l3764"></a><a href="#l3764">3764</a><td>                     {origin: &quot;*mouse&quot;, scroll: false});<tr><td><a id="l3765"></a><a href="#l3765">3765</a><td>        cm.scrollIntoView(pos);<tr><td><a id="l3766"></a><a href="#l3766">3766</a><td>      } else {<tr><td><a id="l3767"></a><a href="#l3767">3767</a><td>        var oldRange = ourRange;<tr><td><a id="l3768"></a><a href="#l3768">3768</a><td>        var anchor = oldRange.anchor, head = pos;<tr><td><a id="l3769"></a><a href="#l3769">3769</a><td>        if (type != &quot;single&quot;) {<tr><td><a id="l3770"></a><a href="#l3770">3770</a><td>          if (type == &quot;double&quot;)<tr><td><a id="l3771"></a><a href="#l3771">3771</a><td>            var range = cm.findWordAt(pos);<tr><td><a id="l3772"></a><a href="#l3772">3772</a><td>          else<tr><td><a id="l3773"></a><a href="#l3773">3773</a><td>            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));<tr><td><a id="l3774"></a><a href="#l3774">3774</a><td>          if (cmp(range.anchor, anchor) &gt; 0) {<tr><td><a id="l3775"></a><a href="#l3775">3775</a><td>            head = range.head;<tr><td><a id="l3776"></a><a href="#l3776">3776</a><td>            anchor = minPos(oldRange.from(), range.anchor);<tr><td><a id="l3777"></a><a href="#l3777">3777</a><td>          } else {<tr><td><a id="l3778"></a><a href="#l3778">3778</a><td>            head = range.anchor;<tr><td><a id="l3779"></a><a href="#l3779">3779</a><td>            anchor = maxPos(oldRange.to(), range.head);<tr><td><a id="l3780"></a><a href="#l3780">3780</a><td>          }<tr><td><a id="l3781"></a><a href="#l3781">3781</a><td>        }<tr><td><a id="l3782"></a><a href="#l3782">3782</a><td>        var ranges = startSel.ranges.slice(0);<tr><td><a id="l3783"></a><a href="#l3783">3783</a><td>        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);<tr><td><a id="l3784"></a><a href="#l3784">3784</a><td>        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);<tr><td><a id="l3785"></a><a href="#l3785">3785</a><td>      }<tr><td><a id="l3786"></a><a href="#l3786">3786</a><td>    }<tr><td><a id="l3787"></a><a href="#l3787">3787</a><td><tr><td><a id="l3788"></a><a href="#l3788">3788</a><td>    var editorSize = display.wrapper.getBoundingClientRect();<tr><td><a id="l3789"></a><a href="#l3789">3789</a><td>    // Used to ensure timeout re-tries don&#39;t fire when another extend<tr><td><a id="l3790"></a><a href="#l3790">3790</a><td>    // happened in the meantime (clearTimeout isn&#39;t reliable -- at<tr><td><a id="l3791"></a><a href="#l3791">3791</a><td>    // least on Chrome, the timeouts still happen even when cleared,<tr><td><a id="l3792"></a><a href="#l3792">3792</a><td>    // if the clear happens after their scheduled firing time).<tr><td><a id="l3793"></a><a href="#l3793">3793</a><td>    var counter = 0;<tr><td><a id="l3794"></a><a href="#l3794">3794</a><td><tr><td><a id="l3795"></a><a href="#l3795">3795</a><td>    function extend(e) {<tr><td><a id="l3796"></a><a href="#l3796">3796</a><td>      var curCount = ++counter;<tr><td><a id="l3797"></a><a href="#l3797">3797</a><td>      var cur = posFromMouse(cm, e, true, type == &quot;rect&quot;);<tr><td><a id="l3798"></a><a href="#l3798">3798</a><td>      if (!cur) return;<tr><td><a id="l3799"></a><a href="#l3799">3799</a><td>      if (cmp(cur, lastPos) != 0) {<tr><td><a id="l3800"></a><a href="#l3800">3800</a><td>        cm.curOp.focus = activeElt();<tr><td><a id="l3801"></a><a href="#l3801">3801</a><td>        extendTo(cur);<tr><td><a id="l3802"></a><a href="#l3802">3802</a><td>        var visible = visibleLines(display, doc);<tr><td><a id="l3803"></a><a href="#l3803">3803</a><td>        if (cur.line &gt;= visible.to || cur.line &lt; visible.from)<tr><td><a id="l3804"></a><a href="#l3804">3804</a><td>          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);<tr><td><a id="l3805"></a><a href="#l3805">3805</a><td>      } else {<tr><td><a id="l3806"></a><a href="#l3806">3806</a><td>        var outside = e.clientY &lt; editorSize.top ? -20 : e.clientY &gt; editorSize.bottom ? 20 : 0;<tr><td><a id="l3807"></a><a href="#l3807">3807</a><td>        if (outside) setTimeout(operation(cm, function() {<tr><td><a id="l3808"></a><a href="#l3808">3808</a><td>          if (counter != curCount) return;<tr><td><a id="l3809"></a><a href="#l3809">3809</a><td>          display.scroller.scrollTop += outside;<tr><td><a id="l3810"></a><a href="#l3810">3810</a><td>          extend(e);<tr><td><a id="l3811"></a><a href="#l3811">3811</a><td>        }), 50);<tr><td><a id="l3812"></a><a href="#l3812">3812</a><td>      }<tr><td><a id="l3813"></a><a href="#l3813">3813</a><td>    }<tr><td><a id="l3814"></a><a href="#l3814">3814</a><td><tr><td><a id="l3815"></a><a href="#l3815">3815</a><td>    function done(e) {<tr><td><a id="l3816"></a><a href="#l3816">3816</a><td>      cm.state.selectingText = false;<tr><td><a id="l3817"></a><a href="#l3817">3817</a><td>      counter = Infinity;<tr><td><a id="l3818"></a><a href="#l3818">3818</a><td>      e_preventDefault(e);<tr><td><a id="l3819"></a><a href="#l3819">3819</a><td>      display.input.focus();<tr><td><a id="l3820"></a><a href="#l3820">3820</a><td>      off(document, &quot;mousemove&quot;, move);<tr><td><a id="l3821"></a><a href="#l3821">3821</a><td>      off(document, &quot;mouseup&quot;, up);<tr><td><a id="l3822"></a><a href="#l3822">3822</a><td>      doc.history.lastSelOrigin = null;<tr><td><a id="l3823"></a><a href="#l3823">3823</a><td>    }<tr><td><a id="l3824"></a><a href="#l3824">3824</a><td><tr><td><a id="l3825"></a><a href="#l3825">3825</a><td>    var move = operation(cm, function(e) {<tr><td><a id="l3826"></a><a href="#l3826">3826</a><td>      if (!e_button(e)) done(e);<tr><td><a id="l3827"></a><a href="#l3827">3827</a><td>      else extend(e);<tr><td><a id="l3828"></a><a href="#l3828">3828</a><td>    });<tr><td><a id="l3829"></a><a href="#l3829">3829</a><td>    var up = operation(cm, done);<tr><td><a id="l3830"></a><a href="#l3830">3830</a><td>    cm.state.selectingText = up;<tr><td><a id="l3831"></a><a href="#l3831">3831</a><td>    on(document, &quot;mousemove&quot;, move);<tr><td><a id="l3832"></a><a href="#l3832">3832</a><td>    on(document, &quot;mouseup&quot;, up);<tr><td><a id="l3833"></a><a href="#l3833">3833</a><td>  }<tr><td><a id="l3834"></a><a href="#l3834">3834</a><td><tr><td><a id="l3835"></a><a href="#l3835">3835</a><td>  // Determines whether an event happened in the gutter, and fires the<tr><td><a id="l3836"></a><a href="#l3836">3836</a><td>  // handlers for the corresponding event.<tr><td><a id="l3837"></a><a href="#l3837">3837</a><td>  function gutterEvent(cm, e, type, prevent) {<tr><td><a id="l3838"></a><a href="#l3838">3838</a><td>    try { var mX = e.clientX, mY = e.clientY; }<tr><td><a id="l3839"></a><a href="#l3839">3839</a><td>    catch(e) { return false; }<tr><td><a id="l3840"></a><a href="#l3840">3840</a><td>    if (mX &gt;= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;<tr><td><a id="l3841"></a><a href="#l3841">3841</a><td>    if (prevent) e_preventDefault(e);<tr><td><a id="l3842"></a><a href="#l3842">3842</a><td><tr><td><a id="l3843"></a><a href="#l3843">3843</a><td>    var display = cm.display;<tr><td><a id="l3844"></a><a href="#l3844">3844</a><td>    var lineBox = display.lineDiv.getBoundingClientRect();<tr><td><a id="l3845"></a><a href="#l3845">3845</a><td><tr><td><a id="l3846"></a><a href="#l3846">3846</a><td>    if (mY &gt; lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);<tr><td><a id="l3847"></a><a href="#l3847">3847</a><td>    mY -= lineBox.top - display.viewOffset;<tr><td><a id="l3848"></a><a href="#l3848">3848</a><td><tr><td><a id="l3849"></a><a href="#l3849">3849</a><td>    for (var i = 0; i &lt; cm.options.gutters.length; ++i) {<tr><td><a id="l3850"></a><a href="#l3850">3850</a><td>      var g = display.gutters.childNodes[i];<tr><td><a id="l3851"></a><a href="#l3851">3851</a><td>      if (g &amp;&amp; g.getBoundingClientRect().right &gt;= mX) {<tr><td><a id="l3852"></a><a href="#l3852">3852</a><td>        var line = lineAtHeight(cm.doc, mY);<tr><td><a id="l3853"></a><a href="#l3853">3853</a><td>        var gutter = cm.options.gutters[i];<tr><td><a id="l3854"></a><a href="#l3854">3854</a><td>        signal(cm, type, cm, line, gutter, e);<tr><td><a id="l3855"></a><a href="#l3855">3855</a><td>        return e_defaultPrevented(e);<tr><td><a id="l3856"></a><a href="#l3856">3856</a><td>      }<tr><td><a id="l3857"></a><a href="#l3857">3857</a><td>    }<tr><td><a id="l3858"></a><a href="#l3858">3858</a><td>  }<tr><td><a id="l3859"></a><a href="#l3859">3859</a><td><tr><td><a id="l3860"></a><a href="#l3860">3860</a><td>  function clickInGutter(cm, e) {<tr><td><a id="l3861"></a><a href="#l3861">3861</a><td>    return gutterEvent(cm, e, &quot;gutterClick&quot;, true);<tr><td><a id="l3862"></a><a href="#l3862">3862</a><td>  }<tr><td><a id="l3863"></a><a href="#l3863">3863</a><td><tr><td><a id="l3864"></a><a href="#l3864">3864</a><td>  // Kludge to work around strange IE behavior where it&#39;ll sometimes<tr><td><a id="l3865"></a><a href="#l3865">3865</a><td>  // re-fire a series of drag-related events right after the drop (#1551)<tr><td><a id="l3866"></a><a href="#l3866">3866</a><td>  var lastDrop = 0;<tr><td><a id="l3867"></a><a href="#l3867">3867</a><td><tr><td><a id="l3868"></a><a href="#l3868">3868</a><td>  function onDrop(e) {<tr><td><a id="l3869"></a><a href="#l3869">3869</a><td>    var cm = this;<tr><td><a id="l3870"></a><a href="#l3870">3870</a><td>    clearDragCursor(cm);<tr><td><a id="l3871"></a><a href="#l3871">3871</a><td>    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))<tr><td><a id="l3872"></a><a href="#l3872">3872</a><td>      return;<tr><td><a id="l3873"></a><a href="#l3873">3873</a><td>    e_preventDefault(e);<tr><td><a id="l3874"></a><a href="#l3874">3874</a><td>    if (ie) lastDrop = +new Date;<tr><td><a id="l3875"></a><a href="#l3875">3875</a><td>    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;<tr><td><a id="l3876"></a><a href="#l3876">3876</a><td>    if (!pos || cm.isReadOnly()) return;<tr><td><a id="l3877"></a><a href="#l3877">3877</a><td>    // Might be a file drop, in which case we simply extract the text<tr><td><a id="l3878"></a><a href="#l3878">3878</a><td>    // and insert it.<tr><td><a id="l3879"></a><a href="#l3879">3879</a><td>    if (files &amp;&amp; files.length &amp;&amp; window.FileReader &amp;&amp; window.File) {<tr><td><a id="l3880"></a><a href="#l3880">3880</a><td>      var n = files.length, text = Array(n), read = 0;<tr><td><a id="l3881"></a><a href="#l3881">3881</a><td>      var loadFile = function(file, i) {<tr><td><a id="l3882"></a><a href="#l3882">3882</a><td>        if (cm.options.allowDropFileTypes &amp;&amp;<tr><td><a id="l3883"></a><a href="#l3883">3883</a><td>            indexOf(cm.options.allowDropFileTypes, file.type) == -1)<tr><td><a id="l3884"></a><a href="#l3884">3884</a><td>          return;<tr><td><a id="l3885"></a><a href="#l3885">3885</a><td><tr><td><a id="l3886"></a><a href="#l3886">3886</a><td>        var reader = new FileReader;<tr><td><a id="l3887"></a><a href="#l3887">3887</a><td>        reader.onload = operation(cm, function() {<tr><td><a id="l3888"></a><a href="#l3888">3888</a><td>          var content = reader.result;<tr><td><a id="l3889"></a><a href="#l3889">3889</a><td>          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = &quot;&quot;;<tr><td><a id="l3890"></a><a href="#l3890">3890</a><td>          text[i] = content;<tr><td><a id="l3891"></a><a href="#l3891">3891</a><td>          if (++read == n) {<tr><td><a id="l3892"></a><a href="#l3892">3892</a><td>            pos = clipPos(cm.doc, pos);<tr><td><a id="l3893"></a><a href="#l3893">3893</a><td>            var change = {from: pos, to: pos,<tr><td><a id="l3894"></a><a href="#l3894">3894</a><td>                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),<tr><td><a id="l3895"></a><a href="#l3895">3895</a><td>                          origin: &quot;paste&quot;};<tr><td><a id="l3896"></a><a href="#l3896">3896</a><td>            makeChange(cm.doc, change);<tr><td><a id="l3897"></a><a href="#l3897">3897</a><td>            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));<tr><td><a id="l3898"></a><a href="#l3898">3898</a><td>          }<tr><td><a id="l3899"></a><a href="#l3899">3899</a><td>        });<tr><td><a id="l3900"></a><a href="#l3900">3900</a><td>        reader.readAsText(file);<tr><td><a id="l3901"></a><a href="#l3901">3901</a><td>      };<tr><td><a id="l3902"></a><a href="#l3902">3902</a><td>      for (var i = 0; i &lt; n; ++i) loadFile(files[i], i);<tr><td><a id="l3903"></a><a href="#l3903">3903</a><td>    } else { // Normal drop<tr><td><a id="l3904"></a><a href="#l3904">3904</a><td>      // Don&#39;t do a replace if the drop happened inside of the selected text.<tr><td><a id="l3905"></a><a href="#l3905">3905</a><td>      if (cm.state.draggingText &amp;&amp; cm.doc.sel.contains(pos) &gt; -1) {<tr><td><a id="l3906"></a><a href="#l3906">3906</a><td>        cm.state.draggingText(e);<tr><td><a id="l3907"></a><a href="#l3907">3907</a><td>        // Ensure the editor is re-focused<tr><td><a id="l3908"></a><a href="#l3908">3908</a><td>        setTimeout(function() {cm.display.input.focus();}, 20);<tr><td><a id="l3909"></a><a href="#l3909">3909</a><td>        return;<tr><td><a id="l3910"></a><a href="#l3910">3910</a><td>      }<tr><td><a id="l3911"></a><a href="#l3911">3911</a><td>      try {<tr><td><a id="l3912"></a><a href="#l3912">3912</a><td>        var text = e.dataTransfer.getData(&quot;Text&quot;);<tr><td><a id="l3913"></a><a href="#l3913">3913</a><td>        if (text) {<tr><td><a id="l3914"></a><a href="#l3914">3914</a><td>          if (cm.state.draggingText &amp;&amp; !cm.state.draggingText.copy)<tr><td><a id="l3915"></a><a href="#l3915">3915</a><td>            var selected = cm.listSelections();<tr><td><a id="l3916"></a><a href="#l3916">3916</a><td>          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));<tr><td><a id="l3917"></a><a href="#l3917">3917</a><td>          if (selected) for (var i = 0; i &lt; selected.length; ++i)<tr><td><a id="l3918"></a><a href="#l3918">3918</a><td>            replaceRange(cm.doc, &quot;&quot;, selected[i].anchor, selected[i].head, &quot;drag&quot;);<tr><td><a id="l3919"></a><a href="#l3919">3919</a><td>          cm.replaceSelection(text, &quot;around&quot;, &quot;paste&quot;);<tr><td><a id="l3920"></a><a href="#l3920">3920</a><td>          cm.display.input.focus();<tr><td><a id="l3921"></a><a href="#l3921">3921</a><td>        }<tr><td><a id="l3922"></a><a href="#l3922">3922</a><td>      }<tr><td><a id="l3923"></a><a href="#l3923">3923</a><td>      catch(e){}<tr><td><a id="l3924"></a><a href="#l3924">3924</a><td>    }<tr><td><a id="l3925"></a><a href="#l3925">3925</a><td>  }<tr><td><a id="l3926"></a><a href="#l3926">3926</a><td><tr><td><a id="l3927"></a><a href="#l3927">3927</a><td>  function onDragStart(cm, e) {<tr><td><a id="l3928"></a><a href="#l3928">3928</a><td>    if (ie &amp;&amp; (!cm.state.draggingText || +new Date - lastDrop &lt; 100)) { e_stop(e); return; }<tr><td><a id="l3929"></a><a href="#l3929">3929</a><td>    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;<tr><td><a id="l3930"></a><a href="#l3930">3930</a><td><tr><td><a id="l3931"></a><a href="#l3931">3931</a><td>    e.dataTransfer.setData(&quot;Text&quot;, cm.getSelection());<tr><td><a id="l3932"></a><a href="#l3932">3932</a><td>    e.dataTransfer.effectAllowed = &quot;copyMove&quot;<tr><td><a id="l3933"></a><a href="#l3933">3933</a><td><tr><td><a id="l3934"></a><a href="#l3934">3934</a><td>    // Use dummy image instead of default browsers image.<tr><td><a id="l3935"></a><a href="#l3935">3935</a><td>    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don&#39;t do it there.<tr><td><a id="l3936"></a><a href="#l3936">3936</a><td>    if (e.dataTransfer.setDragImage &amp;&amp; !safari) {<tr><td><a id="l3937"></a><a href="#l3937">3937</a><td>      var img = elt(&quot;img&quot;, null, null, &quot;position: fixed; left: 0; top: 0;&quot;);<tr><td><a id="l3938"></a><a href="#l3938">3938</a><td>      img.src = &quot;data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==&quot;;<tr><td><a id="l3939"></a><a href="#l3939">3939</a><td>      if (presto) {<tr><td><a id="l3940"></a><a href="#l3940">3940</a><td>        img.width = img.height = 1;<tr><td><a id="l3941"></a><a href="#l3941">3941</a><td>        cm.display.wrapper.appendChild(img);<tr><td><a id="l3942"></a><a href="#l3942">3942</a><td>        // Force a relayout, or Opera won&#39;t use our image for some obscure reason<tr><td><a id="l3943"></a><a href="#l3943">3943</a><td>        img._top = img.offsetTop;<tr><td><a id="l3944"></a><a href="#l3944">3944</a><td>      }<tr><td><a id="l3945"></a><a href="#l3945">3945</a><td>      e.dataTransfer.setDragImage(img, 0, 0);<tr><td><a id="l3946"></a><a href="#l3946">3946</a><td>      if (presto) img.parentNode.removeChild(img);<tr><td><a id="l3947"></a><a href="#l3947">3947</a><td>    }<tr><td><a id="l3948"></a><a href="#l3948">3948</a><td>  }<tr><td><a id="l3949"></a><a href="#l3949">3949</a><td><tr><td><a id="l3950"></a><a href="#l3950">3950</a><td>  function onDragOver(cm, e) {<tr><td><a id="l3951"></a><a href="#l3951">3951</a><td>    var pos = posFromMouse(cm, e);<tr><td><a id="l3952"></a><a href="#l3952">3952</a><td>    if (!pos) return;<tr><td><a id="l3953"></a><a href="#l3953">3953</a><td>    var frag = document.createDocumentFragment();<tr><td><a id="l3954"></a><a href="#l3954">3954</a><td>    drawSelectionCursor(cm, pos, frag);<tr><td><a id="l3955"></a><a href="#l3955">3955</a><td>    if (!cm.display.dragCursor) {<tr><td><a id="l3956"></a><a href="#l3956">3956</a><td>      cm.display.dragCursor = elt(&quot;div&quot;, null, &quot;CodeMirror-cursors CodeMirror-dragcursors&quot;);<tr><td><a id="l3957"></a><a href="#l3957">3957</a><td>      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);<tr><td><a id="l3958"></a><a href="#l3958">3958</a><td>    }<tr><td><a id="l3959"></a><a href="#l3959">3959</a><td>    removeChildrenAndAdd(cm.display.dragCursor, frag);<tr><td><a id="l3960"></a><a href="#l3960">3960</a><td>  }<tr><td><a id="l3961"></a><a href="#l3961">3961</a><td><tr><td><a id="l3962"></a><a href="#l3962">3962</a><td>  function clearDragCursor(cm) {<tr><td><a id="l3963"></a><a href="#l3963">3963</a><td>    if (cm.display.dragCursor) {<tr><td><a id="l3964"></a><a href="#l3964">3964</a><td>      cm.display.lineSpace.removeChild(cm.display.dragCursor);<tr><td><a id="l3965"></a><a href="#l3965">3965</a><td>      cm.display.dragCursor = null;<tr><td><a id="l3966"></a><a href="#l3966">3966</a><td>    }<tr><td><a id="l3967"></a><a href="#l3967">3967</a><td>  }<tr><td><a id="l3968"></a><a href="#l3968">3968</a><td><tr><td><a id="l3969"></a><a href="#l3969">3969</a><td>  // SCROLL EVENTS<tr><td><a id="l3970"></a><a href="#l3970">3970</a><td><tr><td><a id="l3971"></a><a href="#l3971">3971</a><td>  // Sync the scrollable area and scrollbars, ensure the viewport<tr><td><a id="l3972"></a><a href="#l3972">3972</a><td>  // covers the visible area.<tr><td><a id="l3973"></a><a href="#l3973">3973</a><td>  function setScrollTop(cm, val) {<tr><td><a id="l3974"></a><a href="#l3974">3974</a><td>    if (Math.abs(cm.doc.scrollTop - val) &lt; 2) return;<tr><td><a id="l3975"></a><a href="#l3975">3975</a><td>    cm.doc.scrollTop = val;<tr><td><a id="l3976"></a><a href="#l3976">3976</a><td>    if (!gecko) updateDisplaySimple(cm, {top: val});<tr><td><a id="l3977"></a><a href="#l3977">3977</a><td>    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;<tr><td><a id="l3978"></a><a href="#l3978">3978</a><td>    cm.display.scrollbars.setScrollTop(val);<tr><td><a id="l3979"></a><a href="#l3979">3979</a><td>    if (gecko) updateDisplaySimple(cm);<tr><td><a id="l3980"></a><a href="#l3980">3980</a><td>    startWorker(cm, 100);<tr><td><a id="l3981"></a><a href="#l3981">3981</a><td>  }<tr><td><a id="l3982"></a><a href="#l3982">3982</a><td>  // Sync scroller and scrollbar, ensure the gutter elements are<tr><td><a id="l3983"></a><a href="#l3983">3983</a><td>  // aligned.<tr><td><a id="l3984"></a><a href="#l3984">3984</a><td>  function setScrollLeft(cm, val, isScroller) {<tr><td><a id="l3985"></a><a href="#l3985">3985</a><td>    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) &lt; 2) return;<tr><td><a id="l3986"></a><a href="#l3986">3986</a><td>    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);<tr><td><a id="l3987"></a><a href="#l3987">3987</a><td>    cm.doc.scrollLeft = val;<tr><td><a id="l3988"></a><a href="#l3988">3988</a><td>    alignHorizontally(cm);<tr><td><a id="l3989"></a><a href="#l3989">3989</a><td>    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;<tr><td><a id="l3990"></a><a href="#l3990">3990</a><td>    cm.display.scrollbars.setScrollLeft(val);<tr><td><a id="l3991"></a><a href="#l3991">3991</a><td>  }<tr><td><a id="l3992"></a><a href="#l3992">3992</a><td><tr><td><a id="l3993"></a><a href="#l3993">3993</a><td>  // Since the delta values reported on mouse wheel events are<tr><td><a id="l3994"></a><a href="#l3994">3994</a><td>  // unstandardized between browsers and even browser versions, and<tr><td><a id="l3995"></a><a href="#l3995">3995</a><td>  // generally horribly unpredictable, this code starts by measuring<tr><td><a id="l3996"></a><a href="#l3996">3996</a><td>  // the scroll effect that the first few mouse wheel events have,<tr><td><a id="l3997"></a><a href="#l3997">3997</a><td>  // and, from that, detects the way it can convert deltas to pixel<tr><td><a id="l3998"></a><a href="#l3998">3998</a><td>  // offsets afterwards.<tr><td><a id="l3999"></a><a href="#l3999">3999</a><td>  //<tr><td><a id="l4000"></a><a href="#l4000">4000</a><td>  // The reason we want to know the amount a wheel event will scroll<tr><td><a id="l4001"></a><a href="#l4001">4001</a><td>  // is that it gives us a chance to update the display before the<tr><td><a id="l4002"></a><a href="#l4002">4002</a><td>  // actual scrolling happens, reducing flickering.<tr><td><a id="l4003"></a><a href="#l4003">4003</a><td><tr><td><a id="l4004"></a><a href="#l4004">4004</a><td>  var wheelSamples = 0, wheelPixelsPerUnit = null;<tr><td><a id="l4005"></a><a href="#l4005">4005</a><td>  // Fill in a browser-detected starting value on browsers where we<tr><td><a id="l4006"></a><a href="#l4006">4006</a><td>  // know one. These don&#39;t have to be accurate -- the result of them<tr><td><a id="l4007"></a><a href="#l4007">4007</a><td>  // being wrong would just be a slight flicker on the first wheel<tr><td><a id="l4008"></a><a href="#l4008">4008</a><td>  // scroll (if it is large enough).<tr><td><a id="l4009"></a><a href="#l4009">4009</a><td>  if (ie) wheelPixelsPerUnit = -.53;<tr><td><a id="l4010"></a><a href="#l4010">4010</a><td>  else if (gecko) wheelPixelsPerUnit = 15;<tr><td><a id="l4011"></a><a href="#l4011">4011</a><td>  else if (chrome) wheelPixelsPerUnit = -.7;<tr><td><a id="l4012"></a><a href="#l4012">4012</a><td>  else if (safari) wheelPixelsPerUnit = -1/3;<tr><td><a id="l4013"></a><a href="#l4013">4013</a><td><tr><td><a id="l4014"></a><a href="#l4014">4014</a><td>  var wheelEventDelta = function(e) {<tr><td><a id="l4015"></a><a href="#l4015">4015</a><td>    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;<tr><td><a id="l4016"></a><a href="#l4016">4016</a><td>    if (dx == null &amp;&amp; e.detail &amp;&amp; e.axis == e.HORIZONTAL_AXIS) dx = e.detail;<tr><td><a id="l4017"></a><a href="#l4017">4017</a><td>    if (dy == null &amp;&amp; e.detail &amp;&amp; e.axis == e.VERTICAL_AXIS) dy = e.detail;<tr><td><a id="l4018"></a><a href="#l4018">4018</a><td>    else if (dy == null) dy = e.wheelDelta;<tr><td><a id="l4019"></a><a href="#l4019">4019</a><td>    return {x: dx, y: dy};<tr><td><a id="l4020"></a><a href="#l4020">4020</a><td>  };<tr><td><a id="l4021"></a><a href="#l4021">4021</a><td>  CodeMirror.wheelEventPixels = function(e) {<tr><td><a id="l4022"></a><a href="#l4022">4022</a><td>    var delta = wheelEventDelta(e);<tr><td><a id="l4023"></a><a href="#l4023">4023</a><td>    delta.x *= wheelPixelsPerUnit;<tr><td><a id="l4024"></a><a href="#l4024">4024</a><td>    delta.y *= wheelPixelsPerUnit;<tr><td><a id="l4025"></a><a href="#l4025">4025</a><td>    return delta;<tr><td><a id="l4026"></a><a href="#l4026">4026</a><td>  };<tr><td><a id="l4027"></a><a href="#l4027">4027</a><td><tr><td><a id="l4028"></a><a href="#l4028">4028</a><td>  function onScrollWheel(cm, e) {<tr><td><a id="l4029"></a><a href="#l4029">4029</a><td>    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;<tr><td><a id="l4030"></a><a href="#l4030">4030</a><td><tr><td><a id="l4031"></a><a href="#l4031">4031</a><td>    var display = cm.display, scroll = display.scroller;<tr><td><a id="l4032"></a><a href="#l4032">4032</a><td>    // Quit if there&#39;s nothing to scroll here<tr><td><a id="l4033"></a><a href="#l4033">4033</a><td>    var canScrollX = scroll.scrollWidth &gt; scroll.clientWidth;<tr><td><a id="l4034"></a><a href="#l4034">4034</a><td>    var canScrollY = scroll.scrollHeight &gt; scroll.clientHeight;<tr><td><a id="l4035"></a><a href="#l4035">4035</a><td>    if (!(dx &amp;&amp; canScrollX || dy &amp;&amp; canScrollY)) return;<tr><td><a id="l4036"></a><a href="#l4036">4036</a><td><tr><td><a id="l4037"></a><a href="#l4037">4037</a><td>    // Webkit browsers on OS X abort momentum scrolls when the target<tr><td><a id="l4038"></a><a href="#l4038">4038</a><td>    // of the scroll event is removed from the scrollable element.<tr><td><a id="l4039"></a><a href="#l4039">4039</a><td>    // This hack (see related code in patchDisplay) makes sure the<tr><td><a id="l4040"></a><a href="#l4040">4040</a><td>    // element is kept around.<tr><td><a id="l4041"></a><a href="#l4041">4041</a><td>    if (dy &amp;&amp; mac &amp;&amp; webkit) {<tr><td><a id="l4042"></a><a href="#l4042">4042</a><td>      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {<tr><td><a id="l4043"></a><a href="#l4043">4043</a><td>        for (var i = 0; i &lt; view.length; i++) {<tr><td><a id="l4044"></a><a href="#l4044">4044</a><td>          if (view[i].node == cur) {<tr><td><a id="l4045"></a><a href="#l4045">4045</a><td>            cm.display.currentWheelTarget = cur;<tr><td><a id="l4046"></a><a href="#l4046">4046</a><td>            break outer;<tr><td><a id="l4047"></a><a href="#l4047">4047</a><td>          }<tr><td><a id="l4048"></a><a href="#l4048">4048</a><td>        }<tr><td><a id="l4049"></a><a href="#l4049">4049</a><td>      }<tr><td><a id="l4050"></a><a href="#l4050">4050</a><td>    }<tr><td><a id="l4051"></a><a href="#l4051">4051</a><td><tr><td><a id="l4052"></a><a href="#l4052">4052</a><td>    // On some browsers, horizontal scrolling will cause redraws to<tr><td><a id="l4053"></a><a href="#l4053">4053</a><td>    // happen before the gutter has been realigned, causing it to<tr><td><a id="l4054"></a><a href="#l4054">4054</a><td>    // wriggle around in a most unseemly way. When we have an<tr><td><a id="l4055"></a><a href="#l4055">4055</a><td>    // estimated pixels/delta value, we just handle horizontal<tr><td><a id="l4056"></a><a href="#l4056">4056</a><td>    // scrolling entirely here. It&#39;ll be slightly off from native, but<tr><td><a id="l4057"></a><a href="#l4057">4057</a><td>    // better than glitching out.<tr><td><a id="l4058"></a><a href="#l4058">4058</a><td>    if (dx &amp;&amp; !gecko &amp;&amp; !presto &amp;&amp; wheelPixelsPerUnit != null) {<tr><td><a id="l4059"></a><a href="#l4059">4059</a><td>      if (dy &amp;&amp; canScrollY)<tr><td><a id="l4060"></a><a href="#l4060">4060</a><td>        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));<tr><td><a id="l4061"></a><a href="#l4061">4061</a><td>      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));<tr><td><a id="l4062"></a><a href="#l4062">4062</a><td>      // Only prevent default scrolling if vertical scrolling is<tr><td><a id="l4063"></a><a href="#l4063">4063</a><td>      // actually possible. Otherwise, it causes vertical scroll<tr><td><a id="l4064"></a><a href="#l4064">4064</a><td>      // jitter on OSX trackpads when deltaX is small and deltaY<tr><td><a id="l4065"></a><a href="#l4065">4065</a><td>      // is large (issue #3579)<tr><td><a id="l4066"></a><a href="#l4066">4066</a><td>      if (!dy || (dy &amp;&amp; canScrollY))<tr><td><a id="l4067"></a><a href="#l4067">4067</a><td>        e_preventDefault(e);<tr><td><a id="l4068"></a><a href="#l4068">4068</a><td>      display.wheelStartX = null; // Abort measurement, if in progress<tr><td><a id="l4069"></a><a href="#l4069">4069</a><td>      return;<tr><td><a id="l4070"></a><a href="#l4070">4070</a><td>    }<tr><td><a id="l4071"></a><a href="#l4071">4071</a><td><tr><td><a id="l4072"></a><a href="#l4072">4072</a><td>    // &#39;Project&#39; the visible viewport to cover the area that is being<tr><td><a id="l4073"></a><a href="#l4073">4073</a><td>    // scrolled into view (if we know enough to estimate it).<tr><td><a id="l4074"></a><a href="#l4074">4074</a><td>    if (dy &amp;&amp; wheelPixelsPerUnit != null) {<tr><td><a id="l4075"></a><a href="#l4075">4075</a><td>      var pixels = dy * wheelPixelsPerUnit;<tr><td><a id="l4076"></a><a href="#l4076">4076</a><td>      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;<tr><td><a id="l4077"></a><a href="#l4077">4077</a><td>      if (pixels &lt; 0) top = Math.max(0, top + pixels - 50);<tr><td><a id="l4078"></a><a href="#l4078">4078</a><td>      else bot = Math.min(cm.doc.height, bot + pixels + 50);<tr><td><a id="l4079"></a><a href="#l4079">4079</a><td>      updateDisplaySimple(cm, {top: top, bottom: bot});<tr><td><a id="l4080"></a><a href="#l4080">4080</a><td>    }<tr><td><a id="l4081"></a><a href="#l4081">4081</a><td><tr><td><a id="l4082"></a><a href="#l4082">4082</a><td>    if (wheelSamples &lt; 20) {<tr><td><a id="l4083"></a><a href="#l4083">4083</a><td>      if (display.wheelStartX == null) {<tr><td><a id="l4084"></a><a href="#l4084">4084</a><td>        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;<tr><td><a id="l4085"></a><a href="#l4085">4085</a><td>        display.wheelDX = dx; display.wheelDY = dy;<tr><td><a id="l4086"></a><a href="#l4086">4086</a><td>        setTimeout(function() {<tr><td><a id="l4087"></a><a href="#l4087">4087</a><td>          if (display.wheelStartX == null) return;<tr><td><a id="l4088"></a><a href="#l4088">4088</a><td>          var movedX = scroll.scrollLeft - display.wheelStartX;<tr><td><a id="l4089"></a><a href="#l4089">4089</a><td>          var movedY = scroll.scrollTop - display.wheelStartY;<tr><td><a id="l4090"></a><a href="#l4090">4090</a><td>          var sample = (movedY &amp;&amp; display.wheelDY &amp;&amp; movedY / display.wheelDY) ||<tr><td><a id="l4091"></a><a href="#l4091">4091</a><td>            (movedX &amp;&amp; display.wheelDX &amp;&amp; movedX / display.wheelDX);<tr><td><a id="l4092"></a><a href="#l4092">4092</a><td>          display.wheelStartX = display.wheelStartY = null;<tr><td><a id="l4093"></a><a href="#l4093">4093</a><td>          if (!sample) return;<tr><td><a id="l4094"></a><a href="#l4094">4094</a><td>          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);<tr><td><a id="l4095"></a><a href="#l4095">4095</a><td>          ++wheelSamples;<tr><td><a id="l4096"></a><a href="#l4096">4096</a><td>        }, 200);<tr><td><a id="l4097"></a><a href="#l4097">4097</a><td>      } else {<tr><td><a id="l4098"></a><a href="#l4098">4098</a><td>        display.wheelDX += dx; display.wheelDY += dy;<tr><td><a id="l4099"></a><a href="#l4099">4099</a><td>      }<tr><td><a id="l4100"></a><a href="#l4100">4100</a><td>    }<tr><td><a id="l4101"></a><a href="#l4101">4101</a><td>  }<tr><td><a id="l4102"></a><a href="#l4102">4102</a><td><tr><td><a id="l4103"></a><a href="#l4103">4103</a><td>  // KEY EVENTS<tr><td><a id="l4104"></a><a href="#l4104">4104</a><td><tr><td><a id="l4105"></a><a href="#l4105">4105</a><td>  // Run a handler that was bound to a key.<tr><td><a id="l4106"></a><a href="#l4106">4106</a><td>  function doHandleBinding(cm, bound, dropShift) {<tr><td><a id="l4107"></a><a href="#l4107">4107</a><td>    if (typeof bound == &quot;string&quot;) {<tr><td><a id="l4108"></a><a href="#l4108">4108</a><td>      bound = commands[bound];<tr><td><a id="l4109"></a><a href="#l4109">4109</a><td>      if (!bound) return false;<tr><td><a id="l4110"></a><a href="#l4110">4110</a><td>    }<tr><td><a id="l4111"></a><a href="#l4111">4111</a><td>    // Ensure previous input has been read, so that the handler sees a<tr><td><a id="l4112"></a><a href="#l4112">4112</a><td>    // consistent view of the document<tr><td><a id="l4113"></a><a href="#l4113">4113</a><td>    cm.display.input.ensurePolled();<tr><td><a id="l4114"></a><a href="#l4114">4114</a><td>    var prevShift = cm.display.shift, done = false;<tr><td><a id="l4115"></a><a href="#l4115">4115</a><td>    try {<tr><td><a id="l4116"></a><a href="#l4116">4116</a><td>      if (cm.isReadOnly()) cm.state.suppressEdits = true;<tr><td><a id="l4117"></a><a href="#l4117">4117</a><td>      if (dropShift) cm.display.shift = false;<tr><td><a id="l4118"></a><a href="#l4118">4118</a><td>      done = bound(cm) != Pass;<tr><td><a id="l4119"></a><a href="#l4119">4119</a><td>    } finally {<tr><td><a id="l4120"></a><a href="#l4120">4120</a><td>      cm.display.shift = prevShift;<tr><td><a id="l4121"></a><a href="#l4121">4121</a><td>      cm.state.suppressEdits = false;<tr><td><a id="l4122"></a><a href="#l4122">4122</a><td>    }<tr><td><a id="l4123"></a><a href="#l4123">4123</a><td>    return done;<tr><td><a id="l4124"></a><a href="#l4124">4124</a><td>  }<tr><td><a id="l4125"></a><a href="#l4125">4125</a><td><tr><td><a id="l4126"></a><a href="#l4126">4126</a><td>  function lookupKeyForEditor(cm, name, handle) {<tr><td><a id="l4127"></a><a href="#l4127">4127</a><td>    for (var i = 0; i &lt; cm.state.keyMaps.length; i++) {<tr><td><a id="l4128"></a><a href="#l4128">4128</a><td>      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);<tr><td><a id="l4129"></a><a href="#l4129">4129</a><td>      if (result) return result;<tr><td><a id="l4130"></a><a href="#l4130">4130</a><td>    }<tr><td><a id="l4131"></a><a href="#l4131">4131</a><td>    return (cm.options.extraKeys &amp;&amp; lookupKey(name, cm.options.extraKeys, handle, cm))<tr><td><a id="l4132"></a><a href="#l4132">4132</a><td>      || lookupKey(name, cm.options.keyMap, handle, cm);<tr><td><a id="l4133"></a><a href="#l4133">4133</a><td>  }<tr><td><a id="l4134"></a><a href="#l4134">4134</a><td><tr><td><a id="l4135"></a><a href="#l4135">4135</a><td>  var stopSeq = new Delayed;<tr><td><a id="l4136"></a><a href="#l4136">4136</a><td>  function dispatchKey(cm, name, e, handle) {<tr><td><a id="l4137"></a><a href="#l4137">4137</a><td>    var seq = cm.state.keySeq;<tr><td><a id="l4138"></a><a href="#l4138">4138</a><td>    if (seq) {<tr><td><a id="l4139"></a><a href="#l4139">4139</a><td>      if (isModifierKey(name)) return &quot;handled&quot;;<tr><td><a id="l4140"></a><a href="#l4140">4140</a><td>      stopSeq.set(50, function() {<tr><td><a id="l4141"></a><a href="#l4141">4141</a><td>        if (cm.state.keySeq == seq) {<tr><td><a id="l4142"></a><a href="#l4142">4142</a><td>          cm.state.keySeq = null;<tr><td><a id="l4143"></a><a href="#l4143">4143</a><td>          cm.display.input.reset();<tr><td><a id="l4144"></a><a href="#l4144">4144</a><td>        }<tr><td><a id="l4145"></a><a href="#l4145">4145</a><td>      });<tr><td><a id="l4146"></a><a href="#l4146">4146</a><td>      name = seq + &quot; &quot; + name;<tr><td><a id="l4147"></a><a href="#l4147">4147</a><td>    }<tr><td><a id="l4148"></a><a href="#l4148">4148</a><td>    var result = lookupKeyForEditor(cm, name, handle);<tr><td><a id="l4149"></a><a href="#l4149">4149</a><td><tr><td><a id="l4150"></a><a href="#l4150">4150</a><td>    if (result == &quot;multi&quot;)<tr><td><a id="l4151"></a><a href="#l4151">4151</a><td>      cm.state.keySeq = name;<tr><td><a id="l4152"></a><a href="#l4152">4152</a><td>    if (result == &quot;handled&quot;)<tr><td><a id="l4153"></a><a href="#l4153">4153</a><td>      signalLater(cm, &quot;keyHandled&quot;, cm, name, e);<tr><td><a id="l4154"></a><a href="#l4154">4154</a><td><tr><td><a id="l4155"></a><a href="#l4155">4155</a><td>    if (result == &quot;handled&quot; || result == &quot;multi&quot;) {<tr><td><a id="l4156"></a><a href="#l4156">4156</a><td>      e_preventDefault(e);<tr><td><a id="l4157"></a><a href="#l4157">4157</a><td>      restartBlink(cm);<tr><td><a id="l4158"></a><a href="#l4158">4158</a><td>    }<tr><td><a id="l4159"></a><a href="#l4159">4159</a><td><tr><td><a id="l4160"></a><a href="#l4160">4160</a><td>    if (seq &amp;&amp; !result &amp;&amp; /\&#39;$/.test(name)) {<tr><td><a id="l4161"></a><a href="#l4161">4161</a><td>      e_preventDefault(e);<tr><td><a id="l4162"></a><a href="#l4162">4162</a><td>      return true;<tr><td><a id="l4163"></a><a href="#l4163">4163</a><td>    }<tr><td><a id="l4164"></a><a href="#l4164">4164</a><td>    return !!result;<tr><td><a id="l4165"></a><a href="#l4165">4165</a><td>  }<tr><td><a id="l4166"></a><a href="#l4166">4166</a><td><tr><td><a id="l4167"></a><a href="#l4167">4167</a><td>  // Handle a key from the keydown event.<tr><td><a id="l4168"></a><a href="#l4168">4168</a><td>  function handleKeyBinding(cm, e) {<tr><td><a id="l4169"></a><a href="#l4169">4169</a><td>    var name = keyName(e, true);<tr><td><a id="l4170"></a><a href="#l4170">4170</a><td>    if (!name) return false;<tr><td><a id="l4171"></a><a href="#l4171">4171</a><td><tr><td><a id="l4172"></a><a href="#l4172">4172</a><td>    if (e.shiftKey &amp;&amp; !cm.state.keySeq) {<tr><td><a id="l4173"></a><a href="#l4173">4173</a><td>      // First try to resolve full name (including &#39;Shift-&#39;). Failing<tr><td><a id="l4174"></a><a href="#l4174">4174</a><td>      // that, see if there is a cursor-motion command (starting with<tr><td><a id="l4175"></a><a href="#l4175">4175</a><td>      // &#39;go&#39;) bound to the keyname without &#39;Shift-&#39;.<tr><td><a id="l4176"></a><a href="#l4176">4176</a><td>      return dispatchKey(cm, &quot;Shift-&quot; + name, e, function(b) {return doHandleBinding(cm, b, true);})<tr><td><a id="l4177"></a><a href="#l4177">4177</a><td>          || dispatchKey(cm, name, e, function(b) {<tr><td><a id="l4178"></a><a href="#l4178">4178</a><td>               if (typeof b == &quot;string&quot; ? /^go[A-Z]/.test(b) : b.motion)<tr><td><a id="l4179"></a><a href="#l4179">4179</a><td>                 return doHandleBinding(cm, b);<tr><td><a id="l4180"></a><a href="#l4180">4180</a><td>             });<tr><td><a id="l4181"></a><a href="#l4181">4181</a><td>    } else {<tr><td><a id="l4182"></a><a href="#l4182">4182</a><td>      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });<tr><td><a id="l4183"></a><a href="#l4183">4183</a><td>    }<tr><td><a id="l4184"></a><a href="#l4184">4184</a><td>  }<tr><td><a id="l4185"></a><a href="#l4185">4185</a><td><tr><td><a id="l4186"></a><a href="#l4186">4186</a><td>  // Handle a key from the keypress event<tr><td><a id="l4187"></a><a href="#l4187">4187</a><td>  function handleCharBinding(cm, e, ch) {<tr><td><a id="l4188"></a><a href="#l4188">4188</a><td>    return dispatchKey(cm, &quot;&#39;&quot; + ch + &quot;&#39;&quot;, e,<tr><td><a id="l4189"></a><a href="#l4189">4189</a><td>                       function(b) { return doHandleBinding(cm, b, true); });<tr><td><a id="l4190"></a><a href="#l4190">4190</a><td>  }<tr><td><a id="l4191"></a><a href="#l4191">4191</a><td><tr><td><a id="l4192"></a><a href="#l4192">4192</a><td>  var lastStoppedKey = null;<tr><td><a id="l4193"></a><a href="#l4193">4193</a><td>  function onKeyDown(e) {<tr><td><a id="l4194"></a><a href="#l4194">4194</a><td>    var cm = this;<tr><td><a id="l4195"></a><a href="#l4195">4195</a><td>    cm.curOp.focus = activeElt();<tr><td><a id="l4196"></a><a href="#l4196">4196</a><td>    if (signalDOMEvent(cm, e)) return;<tr><td><a id="l4197"></a><a href="#l4197">4197</a><td>    // IE does strange things with escape.<tr><td><a id="l4198"></a><a href="#l4198">4198</a><td>    if (ie &amp;&amp; ie_version &lt; 11 &amp;&amp; e.keyCode == 27) e.returnValue = false;<tr><td><a id="l4199"></a><a href="#l4199">4199</a><td>    var code = e.keyCode;<tr><td><a id="l4200"></a><a href="#l4200">4200</a><td>    cm.display.shift = code == 16 || e.shiftKey;<tr><td><a id="l4201"></a><a href="#l4201">4201</a><td>    var handled = handleKeyBinding(cm, e);<tr><td><a id="l4202"></a><a href="#l4202">4202</a><td>    if (presto) {<tr><td><a id="l4203"></a><a href="#l4203">4203</a><td>      lastStoppedKey = handled ? code : null;<tr><td><a id="l4204"></a><a href="#l4204">4204</a><td>      // Opera has no cut event... we try to at least catch the key combo<tr><td><a id="l4205"></a><a href="#l4205">4205</a><td>      if (!handled &amp;&amp; code == 88 &amp;&amp; !hasCopyEvent &amp;&amp; (mac ? e.metaKey : e.ctrlKey))<tr><td><a id="l4206"></a><a href="#l4206">4206</a><td>        cm.replaceSelection(&quot;&quot;, null, &quot;cut&quot;);<tr><td><a id="l4207"></a><a href="#l4207">4207</a><td>    }<tr><td><a id="l4208"></a><a href="#l4208">4208</a><td><tr><td><a id="l4209"></a><a href="#l4209">4209</a><td>    // Turn mouse into crosshair when Alt is held on Mac.<tr><td><a id="l4210"></a><a href="#l4210">4210</a><td>    if (code == 18 &amp;&amp; !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))<tr><td><a id="l4211"></a><a href="#l4211">4211</a><td>      showCrossHair(cm);<tr><td><a id="l4212"></a><a href="#l4212">4212</a><td>  }<tr><td><a id="l4213"></a><a href="#l4213">4213</a><td><tr><td><a id="l4214"></a><a href="#l4214">4214</a><td>  function showCrossHair(cm) {<tr><td><a id="l4215"></a><a href="#l4215">4215</a><td>    var lineDiv = cm.display.lineDiv;<tr><td><a id="l4216"></a><a href="#l4216">4216</a><td>    addClass(lineDiv, &quot;CodeMirror-crosshair&quot;);<tr><td><a id="l4217"></a><a href="#l4217">4217</a><td><tr><td><a id="l4218"></a><a href="#l4218">4218</a><td>    function up(e) {<tr><td><a id="l4219"></a><a href="#l4219">4219</a><td>      if (e.keyCode == 18 || !e.altKey) {<tr><td><a id="l4220"></a><a href="#l4220">4220</a><td>        rmClass(lineDiv, &quot;CodeMirror-crosshair&quot;);<tr><td><a id="l4221"></a><a href="#l4221">4221</a><td>        off(document, &quot;keyup&quot;, up);<tr><td><a id="l4222"></a><a href="#l4222">4222</a><td>        off(document, &quot;mouseover&quot;, up);<tr><td><a id="l4223"></a><a href="#l4223">4223</a><td>      }<tr><td><a id="l4224"></a><a href="#l4224">4224</a><td>    }<tr><td><a id="l4225"></a><a href="#l4225">4225</a><td>    on(document, &quot;keyup&quot;, up);<tr><td><a id="l4226"></a><a href="#l4226">4226</a><td>    on(document, &quot;mouseover&quot;, up);<tr><td><a id="l4227"></a><a href="#l4227">4227</a><td>  }<tr><td><a id="l4228"></a><a href="#l4228">4228</a><td><tr><td><a id="l4229"></a><a href="#l4229">4229</a><td>  function onKeyUp(e) {<tr><td><a id="l4230"></a><a href="#l4230">4230</a><td>    if (e.keyCode == 16) this.doc.sel.shift = false;<tr><td><a id="l4231"></a><a href="#l4231">4231</a><td>    signalDOMEvent(this, e);<tr><td><a id="l4232"></a><a href="#l4232">4232</a><td>  }<tr><td><a id="l4233"></a><a href="#l4233">4233</a><td><tr><td><a id="l4234"></a><a href="#l4234">4234</a><td>  function onKeyPress(e) {<tr><td><a id="l4235"></a><a href="#l4235">4235</a><td>    var cm = this;<tr><td><a id="l4236"></a><a href="#l4236">4236</a><td>    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey &amp;&amp; !e.altKey || mac &amp;&amp; e.metaKey) return;<tr><td><a id="l4237"></a><a href="#l4237">4237</a><td>    var keyCode = e.keyCode, charCode = e.charCode;<tr><td><a id="l4238"></a><a href="#l4238">4238</a><td>    if (presto &amp;&amp; keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}<tr><td><a id="l4239"></a><a href="#l4239">4239</a><td>    if ((presto &amp;&amp; (!e.which || e.which &lt; 10)) &amp;&amp; handleKeyBinding(cm, e)) return;<tr><td><a id="l4240"></a><a href="#l4240">4240</a><td>    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);<tr><td><a id="l4241"></a><a href="#l4241">4241</a><td>    if (handleCharBinding(cm, e, ch)) return;<tr><td><a id="l4242"></a><a href="#l4242">4242</a><td>    cm.display.input.onKeyPress(e);<tr><td><a id="l4243"></a><a href="#l4243">4243</a><td>  }<tr><td><a id="l4244"></a><a href="#l4244">4244</a><td><tr><td><a id="l4245"></a><a href="#l4245">4245</a><td>  // FOCUS/BLUR EVENTS<tr><td><a id="l4246"></a><a href="#l4246">4246</a><td><tr><td><a id="l4247"></a><a href="#l4247">4247</a><td>  function delayBlurEvent(cm) {<tr><td><a id="l4248"></a><a href="#l4248">4248</a><td>    cm.state.delayingBlurEvent = true;<tr><td><a id="l4249"></a><a href="#l4249">4249</a><td>    setTimeout(function() {<tr><td><a id="l4250"></a><a href="#l4250">4250</a><td>      if (cm.state.delayingBlurEvent) {<tr><td><a id="l4251"></a><a href="#l4251">4251</a><td>        cm.state.delayingBlurEvent = false;<tr><td><a id="l4252"></a><a href="#l4252">4252</a><td>        onBlur(cm);<tr><td><a id="l4253"></a><a href="#l4253">4253</a><td>      }<tr><td><a id="l4254"></a><a href="#l4254">4254</a><td>    }, 100);<tr><td><a id="l4255"></a><a href="#l4255">4255</a><td>  }<tr><td><a id="l4256"></a><a href="#l4256">4256</a><td><tr><td><a id="l4257"></a><a href="#l4257">4257</a><td>  function onFocus(cm) {<tr><td><a id="l4258"></a><a href="#l4258">4258</a><td>    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;<tr><td><a id="l4259"></a><a href="#l4259">4259</a><td><tr><td><a id="l4260"></a><a href="#l4260">4260</a><td>    if (cm.options.readOnly == &quot;nocursor&quot;) return;<tr><td><a id="l4261"></a><a href="#l4261">4261</a><td>    if (!cm.state.focused) {<tr><td><a id="l4262"></a><a href="#l4262">4262</a><td>      signal(cm, &quot;focus&quot;, cm);<tr><td><a id="l4263"></a><a href="#l4263">4263</a><td>      cm.state.focused = true;<tr><td><a id="l4264"></a><a href="#l4264">4264</a><td>      addClass(cm.display.wrapper, &quot;CodeMirror-focused&quot;);<tr><td><a id="l4265"></a><a href="#l4265">4265</a><td>      // This test prevents this from firing when a context<tr><td><a id="l4266"></a><a href="#l4266">4266</a><td>      // menu is closed (since the input reset would kill the<tr><td><a id="l4267"></a><a href="#l4267">4267</a><td>      // select-all detection hack)<tr><td><a id="l4268"></a><a href="#l4268">4268</a><td>      if (!cm.curOp &amp;&amp; cm.display.selForContextMenu != cm.doc.sel) {<tr><td><a id="l4269"></a><a href="#l4269">4269</a><td>        cm.display.input.reset();<tr><td><a id="l4270"></a><a href="#l4270">4270</a><td>        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730<tr><td><a id="l4271"></a><a href="#l4271">4271</a><td>      }<tr><td><a id="l4272"></a><a href="#l4272">4272</a><td>      cm.display.input.receivedFocus();<tr><td><a id="l4273"></a><a href="#l4273">4273</a><td>    }<tr><td><a id="l4274"></a><a href="#l4274">4274</a><td>    restartBlink(cm);<tr><td><a id="l4275"></a><a href="#l4275">4275</a><td>  }<tr><td><a id="l4276"></a><a href="#l4276">4276</a><td>  function onBlur(cm) {<tr><td><a id="l4277"></a><a href="#l4277">4277</a><td>    if (cm.state.delayingBlurEvent) return;<tr><td><a id="l4278"></a><a href="#l4278">4278</a><td><tr><td><a id="l4279"></a><a href="#l4279">4279</a><td>    if (cm.state.focused) {<tr><td><a id="l4280"></a><a href="#l4280">4280</a><td>      signal(cm, &quot;blur&quot;, cm);<tr><td><a id="l4281"></a><a href="#l4281">4281</a><td>      cm.state.focused = false;<tr><td><a id="l4282"></a><a href="#l4282">4282</a><td>      rmClass(cm.display.wrapper, &quot;CodeMirror-focused&quot;);<tr><td><a id="l4283"></a><a href="#l4283">4283</a><td>    }<tr><td><a id="l4284"></a><a href="#l4284">4284</a><td>    clearInterval(cm.display.blinker);<tr><td><a id="l4285"></a><a href="#l4285">4285</a><td>    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);<tr><td><a id="l4286"></a><a href="#l4286">4286</a><td>  }<tr><td><a id="l4287"></a><a href="#l4287">4287</a><td><tr><td><a id="l4288"></a><a href="#l4288">4288</a><td>  // CONTEXT MENU HANDLING<tr><td><a id="l4289"></a><a href="#l4289">4289</a><td><tr><td><a id="l4290"></a><a href="#l4290">4290</a><td>  // To make the context menu work, we need to briefly unhide the<tr><td><a id="l4291"></a><a href="#l4291">4291</a><td>  // textarea (making it as unobtrusive as possible) to let the<tr><td><a id="l4292"></a><a href="#l4292">4292</a><td>  // right-click take effect on it.<tr><td><a id="l4293"></a><a href="#l4293">4293</a><td>  function onContextMenu(cm, e) {<tr><td><a id="l4294"></a><a href="#l4294">4294</a><td>    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;<tr><td><a id="l4295"></a><a href="#l4295">4295</a><td>    if (signalDOMEvent(cm, e, &quot;contextmenu&quot;)) return;<tr><td><a id="l4296"></a><a href="#l4296">4296</a><td>    cm.display.input.onContextMenu(e);<tr><td><a id="l4297"></a><a href="#l4297">4297</a><td>  }<tr><td><a id="l4298"></a><a href="#l4298">4298</a><td><tr><td><a id="l4299"></a><a href="#l4299">4299</a><td>  function contextMenuInGutter(cm, e) {<tr><td><a id="l4300"></a><a href="#l4300">4300</a><td>    if (!hasHandler(cm, &quot;gutterContextMenu&quot;)) return false;<tr><td><a id="l4301"></a><a href="#l4301">4301</a><td>    return gutterEvent(cm, e, &quot;gutterContextMenu&quot;, false);<tr><td><a id="l4302"></a><a href="#l4302">4302</a><td>  }<tr><td><a id="l4303"></a><a href="#l4303">4303</a><td><tr><td><a id="l4304"></a><a href="#l4304">4304</a><td>  // UPDATING<tr><td><a id="l4305"></a><a href="#l4305">4305</a><td><tr><td><a id="l4306"></a><a href="#l4306">4306</a><td>  // Compute the position of the end of a change (its &#39;to&#39; property<tr><td><a id="l4307"></a><a href="#l4307">4307</a><td>  // refers to the pre-change end).<tr><td><a id="l4308"></a><a href="#l4308">4308</a><td>  var changeEnd = CodeMirror.changeEnd = function(change) {<tr><td><a id="l4309"></a><a href="#l4309">4309</a><td>    if (!change.text) return change.to;<tr><td><a id="l4310"></a><a href="#l4310">4310</a><td>    return Pos(change.from.line + change.text.length - 1,<tr><td><a id="l4311"></a><a href="#l4311">4311</a><td>               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));<tr><td><a id="l4312"></a><a href="#l4312">4312</a><td>  };<tr><td><a id="l4313"></a><a href="#l4313">4313</a><td><tr><td><a id="l4314"></a><a href="#l4314">4314</a><td>  // Adjust a position to refer to the post-change position of the<tr><td><a id="l4315"></a><a href="#l4315">4315</a><td>  // same text, or the end of the change if the change covers it.<tr><td><a id="l4316"></a><a href="#l4316">4316</a><td>  function adjustForChange(pos, change) {<tr><td><a id="l4317"></a><a href="#l4317">4317</a><td>    if (cmp(pos, change.from) &lt; 0) return pos;<tr><td><a id="l4318"></a><a href="#l4318">4318</a><td>    if (cmp(pos, change.to) &lt;= 0) return changeEnd(change);<tr><td><a id="l4319"></a><a href="#l4319">4319</a><td><tr><td><a id="l4320"></a><a href="#l4320">4320</a><td>    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;<tr><td><a id="l4321"></a><a href="#l4321">4321</a><td>    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;<tr><td><a id="l4322"></a><a href="#l4322">4322</a><td>    return Pos(line, ch);<tr><td><a id="l4323"></a><a href="#l4323">4323</a><td>  }<tr><td><a id="l4324"></a><a href="#l4324">4324</a><td><tr><td><a id="l4325"></a><a href="#l4325">4325</a><td>  function computeSelAfterChange(doc, change) {<tr><td><a id="l4326"></a><a href="#l4326">4326</a><td>    var out = [];<tr><td><a id="l4327"></a><a href="#l4327">4327</a><td>    for (var i = 0; i &lt; doc.sel.ranges.length; i++) {<tr><td><a id="l4328"></a><a href="#l4328">4328</a><td>      var range = doc.sel.ranges[i];<tr><td><a id="l4329"></a><a href="#l4329">4329</a><td>      out.push(new Range(adjustForChange(range.anchor, change),<tr><td><a id="l4330"></a><a href="#l4330">4330</a><td>                         adjustForChange(range.head, change)));<tr><td><a id="l4331"></a><a href="#l4331">4331</a><td>    }<tr><td><a id="l4332"></a><a href="#l4332">4332</a><td>    return normalizeSelection(out, doc.sel.primIndex);<tr><td><a id="l4333"></a><a href="#l4333">4333</a><td>  }<tr><td><a id="l4334"></a><a href="#l4334">4334</a><td><tr><td><a id="l4335"></a><a href="#l4335">4335</a><td>  function offsetPos(pos, old, nw) {<tr><td><a id="l4336"></a><a href="#l4336">4336</a><td>    if (pos.line == old.line)<tr><td><a id="l4337"></a><a href="#l4337">4337</a><td>      return Pos(nw.line, pos.ch - old.ch + nw.ch);<tr><td><a id="l4338"></a><a href="#l4338">4338</a><td>    else<tr><td><a id="l4339"></a><a href="#l4339">4339</a><td>      return Pos(nw.line + (pos.line - old.line), pos.ch);<tr><td><a id="l4340"></a><a href="#l4340">4340</a><td>  }<tr><td><a id="l4341"></a><a href="#l4341">4341</a><td><tr><td><a id="l4342"></a><a href="#l4342">4342</a><td>  // Used by replaceSelections to allow moving the selection to the<tr><td><a id="l4343"></a><a href="#l4343">4343</a><td>  // start or around the replaced test. Hint may be &quot;start&quot; or &quot;around&quot;.<tr><td><a id="l4344"></a><a href="#l4344">4344</a><td>  function computeReplacedSel(doc, changes, hint) {<tr><td><a id="l4345"></a><a href="#l4345">4345</a><td>    var out = [];<tr><td><a id="l4346"></a><a href="#l4346">4346</a><td>    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;<tr><td><a id="l4347"></a><a href="#l4347">4347</a><td>    for (var i = 0; i &lt; changes.length; i++) {<tr><td><a id="l4348"></a><a href="#l4348">4348</a><td>      var change = changes[i];<tr><td><a id="l4349"></a><a href="#l4349">4349</a><td>      var from = offsetPos(change.from, oldPrev, newPrev);<tr><td><a id="l4350"></a><a href="#l4350">4350</a><td>      var to = offsetPos(changeEnd(change), oldPrev, newPrev);<tr><td><a id="l4351"></a><a href="#l4351">4351</a><td>      oldPrev = change.to;<tr><td><a id="l4352"></a><a href="#l4352">4352</a><td>      newPrev = to;<tr><td><a id="l4353"></a><a href="#l4353">4353</a><td>      if (hint == &quot;around&quot;) {<tr><td><a id="l4354"></a><a href="#l4354">4354</a><td>        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) &lt; 0;<tr><td><a id="l4355"></a><a href="#l4355">4355</a><td>        out[i] = new Range(inv ? to : from, inv ? from : to);<tr><td><a id="l4356"></a><a href="#l4356">4356</a><td>      } else {<tr><td><a id="l4357"></a><a href="#l4357">4357</a><td>        out[i] = new Range(from, from);<tr><td><a id="l4358"></a><a href="#l4358">4358</a><td>      }<tr><td><a id="l4359"></a><a href="#l4359">4359</a><td>    }<tr><td><a id="l4360"></a><a href="#l4360">4360</a><td>    return new Selection(out, doc.sel.primIndex);<tr><td><a id="l4361"></a><a href="#l4361">4361</a><td>  }<tr><td><a id="l4362"></a><a href="#l4362">4362</a><td><tr><td><a id="l4363"></a><a href="#l4363">4363</a><td>  // Allow &quot;beforeChange&quot; event handlers to influence a change<tr><td><a id="l4364"></a><a href="#l4364">4364</a><td>  function filterChange(doc, change, update) {<tr><td><a id="l4365"></a><a href="#l4365">4365</a><td>    var obj = {<tr><td><a id="l4366"></a><a href="#l4366">4366</a><td>      canceled: false,<tr><td><a id="l4367"></a><a href="#l4367">4367</a><td>      from: change.from,<tr><td><a id="l4368"></a><a href="#l4368">4368</a><td>      to: change.to,<tr><td><a id="l4369"></a><a href="#l4369">4369</a><td>      text: change.text,<tr><td><a id="l4370"></a><a href="#l4370">4370</a><td>      origin: change.origin,<tr><td><a id="l4371"></a><a href="#l4371">4371</a><td>      cancel: function() { this.canceled = true; }<tr><td><a id="l4372"></a><a href="#l4372">4372</a><td>    };<tr><td><a id="l4373"></a><a href="#l4373">4373</a><td>    if (update) obj.update = function(from, to, text, origin) {<tr><td><a id="l4374"></a><a href="#l4374">4374</a><td>      if (from) this.from = clipPos(doc, from);<tr><td><a id="l4375"></a><a href="#l4375">4375</a><td>      if (to) this.to = clipPos(doc, to);<tr><td><a id="l4376"></a><a href="#l4376">4376</a><td>      if (text) this.text = text;<tr><td><a id="l4377"></a><a href="#l4377">4377</a><td>      if (origin !== undefined) this.origin = origin;<tr><td><a id="l4378"></a><a href="#l4378">4378</a><td>    };<tr><td><a id="l4379"></a><a href="#l4379">4379</a><td>    signal(doc, &quot;beforeChange&quot;, doc, obj);<tr><td><a id="l4380"></a><a href="#l4380">4380</a><td>    if (doc.cm) signal(doc.cm, &quot;beforeChange&quot;, doc.cm, obj);<tr><td><a id="l4381"></a><a href="#l4381">4381</a><td><tr><td><a id="l4382"></a><a href="#l4382">4382</a><td>    if (obj.canceled) return null;<tr><td><a id="l4383"></a><a href="#l4383">4383</a><td>    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};<tr><td><a id="l4384"></a><a href="#l4384">4384</a><td>  }<tr><td><a id="l4385"></a><a href="#l4385">4385</a><td><tr><td><a id="l4386"></a><a href="#l4386">4386</a><td>  // Apply a change to a document, and add it to the document&#39;s<tr><td><a id="l4387"></a><a href="#l4387">4387</a><td>  // history, and propagating it to all linked documents.<tr><td><a id="l4388"></a><a href="#l4388">4388</a><td>  function makeChange(doc, change, ignoreReadOnly) {<tr><td><a id="l4389"></a><a href="#l4389">4389</a><td>    if (doc.cm) {<tr><td><a id="l4390"></a><a href="#l4390">4390</a><td>      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);<tr><td><a id="l4391"></a><a href="#l4391">4391</a><td>      if (doc.cm.state.suppressEdits) return;<tr><td><a id="l4392"></a><a href="#l4392">4392</a><td>    }<tr><td><a id="l4393"></a><a href="#l4393">4393</a><td><tr><td><a id="l4394"></a><a href="#l4394">4394</a><td>    if (hasHandler(doc, &quot;beforeChange&quot;) || doc.cm &amp;&amp; hasHandler(doc.cm, &quot;beforeChange&quot;)) {<tr><td><a id="l4395"></a><a href="#l4395">4395</a><td>      change = filterChange(doc, change, true);<tr><td><a id="l4396"></a><a href="#l4396">4396</a><td>      if (!change) return;<tr><td><a id="l4397"></a><a href="#l4397">4397</a><td>    }<tr><td><a id="l4398"></a><a href="#l4398">4398</a><td><tr><td><a id="l4399"></a><a href="#l4399">4399</a><td>    // Possibly split or suppress the update based on the presence<tr><td><a id="l4400"></a><a href="#l4400">4400</a><td>    // of read-only spans in its range.<tr><td><a id="l4401"></a><a href="#l4401">4401</a><td>    var split = sawReadOnlySpans &amp;&amp; !ignoreReadOnly &amp;&amp; removeReadOnlyRanges(doc, change.from, change.to);<tr><td><a id="l4402"></a><a href="#l4402">4402</a><td>    if (split) {<tr><td><a id="l4403"></a><a href="#l4403">4403</a><td>      for (var i = split.length - 1; i &gt;= 0; --i)<tr><td><a id="l4404"></a><a href="#l4404">4404</a><td>        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [&quot;&quot;] : change.text});<tr><td><a id="l4405"></a><a href="#l4405">4405</a><td>    } else {<tr><td><a id="l4406"></a><a href="#l4406">4406</a><td>      makeChangeInner(doc, change);<tr><td><a id="l4407"></a><a href="#l4407">4407</a><td>    }<tr><td><a id="l4408"></a><a href="#l4408">4408</a><td>  }<tr><td><a id="l4409"></a><a href="#l4409">4409</a><td><tr><td><a id="l4410"></a><a href="#l4410">4410</a><td>  function makeChangeInner(doc, change) {<tr><td><a id="l4411"></a><a href="#l4411">4411</a><td>    if (change.text.length == 1 &amp;&amp; change.text[0] == &quot;&quot; &amp;&amp; cmp(change.from, change.to) == 0) return;<tr><td><a id="l4412"></a><a href="#l4412">4412</a><td>    var selAfter = computeSelAfterChange(doc, change);<tr><td><a id="l4413"></a><a href="#l4413">4413</a><td>    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);<tr><td><a id="l4414"></a><a href="#l4414">4414</a><td><tr><td><a id="l4415"></a><a href="#l4415">4415</a><td>    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));<tr><td><a id="l4416"></a><a href="#l4416">4416</a><td>    var rebased = [];<tr><td><a id="l4417"></a><a href="#l4417">4417</a><td><tr><td><a id="l4418"></a><a href="#l4418">4418</a><td>    linkedDocs(doc, function(doc, sharedHist) {<tr><td><a id="l4419"></a><a href="#l4419">4419</a><td>      if (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -1) {<tr><td><a id="l4420"></a><a href="#l4420">4420</a><td>        rebaseHist(doc.history, change);<tr><td><a id="l4421"></a><a href="#l4421">4421</a><td>        rebased.push(doc.history);<tr><td><a id="l4422"></a><a href="#l4422">4422</a><td>      }<tr><td><a id="l4423"></a><a href="#l4423">4423</a><td>      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));<tr><td><a id="l4424"></a><a href="#l4424">4424</a><td>    });<tr><td><a id="l4425"></a><a href="#l4425">4425</a><td>  }<tr><td><a id="l4426"></a><a href="#l4426">4426</a><td><tr><td><a id="l4427"></a><a href="#l4427">4427</a><td>  // Revert a change stored in a document&#39;s history.<tr><td><a id="l4428"></a><a href="#l4428">4428</a><td>  function makeChangeFromHistory(doc, type, allowSelectionOnly) {<tr><td><a id="l4429"></a><a href="#l4429">4429</a><td>    if (doc.cm &amp;&amp; doc.cm.state.suppressEdits &amp;&amp; !allowSelectionOnly) return;<tr><td><a id="l4430"></a><a href="#l4430">4430</a><td><tr><td><a id="l4431"></a><a href="#l4431">4431</a><td>    var hist = doc.history, event, selAfter = doc.sel;<tr><td><a id="l4432"></a><a href="#l4432">4432</a><td>    var source = type == &quot;undo&quot; ? hist.done : hist.undone, dest = type == &quot;undo&quot; ? hist.undone : hist.done;<tr><td><a id="l4433"></a><a href="#l4433">4433</a><td><tr><td><a id="l4434"></a><a href="#l4434">4434</a><td>    // Verify that there is a useable event (so that ctrl-z won&#39;t<tr><td><a id="l4435"></a><a href="#l4435">4435</a><td>    // needlessly clear selection events)<tr><td><a id="l4436"></a><a href="#l4436">4436</a><td>    for (var i = 0; i &lt; source.length; i++) {<tr><td><a id="l4437"></a><a href="#l4437">4437</a><td>      event = source[i];<tr><td><a id="l4438"></a><a href="#l4438">4438</a><td>      if (allowSelectionOnly ? event.ranges &amp;&amp; !event.equals(doc.sel) : !event.ranges)<tr><td><a id="l4439"></a><a href="#l4439">4439</a><td>        break;<tr><td><a id="l4440"></a><a href="#l4440">4440</a><td>    }<tr><td><a id="l4441"></a><a href="#l4441">4441</a><td>    if (i == source.length) return;<tr><td><a id="l4442"></a><a href="#l4442">4442</a><td>    hist.lastOrigin = hist.lastSelOrigin = null;<tr><td><a id="l4443"></a><a href="#l4443">4443</a><td><tr><td><a id="l4444"></a><a href="#l4444">4444</a><td>    for (;;) {<tr><td><a id="l4445"></a><a href="#l4445">4445</a><td>      event = source.pop();<tr><td><a id="l4446"></a><a href="#l4446">4446</a><td>      if (event.ranges) {<tr><td><a id="l4447"></a><a href="#l4447">4447</a><td>        pushSelectionToHistory(event, dest);<tr><td><a id="l4448"></a><a href="#l4448">4448</a><td>        if (allowSelectionOnly &amp;&amp; !event.equals(doc.sel)) {<tr><td><a id="l4449"></a><a href="#l4449">4449</a><td>          setSelection(doc, event, {clearRedo: false});<tr><td><a id="l4450"></a><a href="#l4450">4450</a><td>          return;<tr><td><a id="l4451"></a><a href="#l4451">4451</a><td>        }<tr><td><a id="l4452"></a><a href="#l4452">4452</a><td>        selAfter = event;<tr><td><a id="l4453"></a><a href="#l4453">4453</a><td>      }<tr><td><a id="l4454"></a><a href="#l4454">4454</a><td>      else break;<tr><td><a id="l4455"></a><a href="#l4455">4455</a><td>    }<tr><td><a id="l4456"></a><a href="#l4456">4456</a><td><tr><td><a id="l4457"></a><a href="#l4457">4457</a><td>    // Build up a reverse change object to add to the opposite history<tr><td><a id="l4458"></a><a href="#l4458">4458</a><td>    // stack (redo when undoing, and vice versa).<tr><td><a id="l4459"></a><a href="#l4459">4459</a><td>    var antiChanges = [];<tr><td><a id="l4460"></a><a href="#l4460">4460</a><td>    pushSelectionToHistory(selAfter, dest);<tr><td><a id="l4461"></a><a href="#l4461">4461</a><td>    dest.push({changes: antiChanges, generation: hist.generation});<tr><td><a id="l4462"></a><a href="#l4462">4462</a><td>    hist.generation = event.generation || ++hist.maxGeneration;<tr><td><a id="l4463"></a><a href="#l4463">4463</a><td><tr><td><a id="l4464"></a><a href="#l4464">4464</a><td>    var filter = hasHandler(doc, &quot;beforeChange&quot;) || doc.cm &amp;&amp; hasHandler(doc.cm, &quot;beforeChange&quot;);<tr><td><a id="l4465"></a><a href="#l4465">4465</a><td><tr><td><a id="l4466"></a><a href="#l4466">4466</a><td>    for (var i = event.changes.length - 1; i &gt;= 0; --i) {<tr><td><a id="l4467"></a><a href="#l4467">4467</a><td>      var change = event.changes[i];<tr><td><a id="l4468"></a><a href="#l4468">4468</a><td>      change.origin = type;<tr><td><a id="l4469"></a><a href="#l4469">4469</a><td>      if (filter &amp;&amp; !filterChange(doc, change, false)) {<tr><td><a id="l4470"></a><a href="#l4470">4470</a><td>        source.length = 0;<tr><td><a id="l4471"></a><a href="#l4471">4471</a><td>        return;<tr><td><a id="l4472"></a><a href="#l4472">4472</a><td>      }<tr><td><a id="l4473"></a><a href="#l4473">4473</a><td><tr><td><a id="l4474"></a><a href="#l4474">4474</a><td>      antiChanges.push(historyChangeFromChange(doc, change));<tr><td><a id="l4475"></a><a href="#l4475">4475</a><td><tr><td><a id="l4476"></a><a href="#l4476">4476</a><td>      var after = i ? computeSelAfterChange(doc, change) : lst(source);<tr><td><a id="l4477"></a><a href="#l4477">4477</a><td>      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));<tr><td><a id="l4478"></a><a href="#l4478">4478</a><td>      if (!i &amp;&amp; doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});<tr><td><a id="l4479"></a><a href="#l4479">4479</a><td>      var rebased = [];<tr><td><a id="l4480"></a><a href="#l4480">4480</a><td><tr><td><a id="l4481"></a><a href="#l4481">4481</a><td>      // Propagate to the linked documents<tr><td><a id="l4482"></a><a href="#l4482">4482</a><td>      linkedDocs(doc, function(doc, sharedHist) {<tr><td><a id="l4483"></a><a href="#l4483">4483</a><td>        if (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -1) {<tr><td><a id="l4484"></a><a href="#l4484">4484</a><td>          rebaseHist(doc.history, change);<tr><td><a id="l4485"></a><a href="#l4485">4485</a><td>          rebased.push(doc.history);<tr><td><a id="l4486"></a><a href="#l4486">4486</a><td>        }<tr><td><a id="l4487"></a><a href="#l4487">4487</a><td>        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));<tr><td><a id="l4488"></a><a href="#l4488">4488</a><td>      });<tr><td><a id="l4489"></a><a href="#l4489">4489</a><td>    }<tr><td><a id="l4490"></a><a href="#l4490">4490</a><td>  }<tr><td><a id="l4491"></a><a href="#l4491">4491</a><td><tr><td><a id="l4492"></a><a href="#l4492">4492</a><td>  // Sub-views need their line numbers shifted when text is added<tr><td><a id="l4493"></a><a href="#l4493">4493</a><td>  // above or below them in the parent document.<tr><td><a id="l4494"></a><a href="#l4494">4494</a><td>  function shiftDoc(doc, distance) {<tr><td><a id="l4495"></a><a href="#l4495">4495</a><td>    if (distance == 0) return;<tr><td><a id="l4496"></a><a href="#l4496">4496</a><td>    doc.first += distance;<tr><td><a id="l4497"></a><a href="#l4497">4497</a><td>    doc.sel = new Selection(map(doc.sel.ranges, function(range) {<tr><td><a id="l4498"></a><a href="#l4498">4498</a><td>      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),<tr><td><a id="l4499"></a><a href="#l4499">4499</a><td>                       Pos(range.head.line + distance, range.head.ch));<tr><td><a id="l4500"></a><a href="#l4500">4500</a><td>    }), doc.sel.primIndex);<tr><td><a id="l4501"></a><a href="#l4501">4501</a><td>    if (doc.cm) {<tr><td><a id="l4502"></a><a href="#l4502">4502</a><td>      regChange(doc.cm, doc.first, doc.first - distance, distance);<tr><td><a id="l4503"></a><a href="#l4503">4503</a><td>      for (var d = doc.cm.display, l = d.viewFrom; l &lt; d.viewTo; l++)<tr><td><a id="l4504"></a><a href="#l4504">4504</a><td>        regLineChange(doc.cm, l, &quot;gutter&quot;);<tr><td><a id="l4505"></a><a href="#l4505">4505</a><td>    }<tr><td><a id="l4506"></a><a href="#l4506">4506</a><td>  }<tr><td><a id="l4507"></a><a href="#l4507">4507</a><td><tr><td><a id="l4508"></a><a href="#l4508">4508</a><td>  // More lower-level change function, handling only a single document<tr><td><a id="l4509"></a><a href="#l4509">4509</a><td>  // (not linked ones).<tr><td><a id="l4510"></a><a href="#l4510">4510</a><td>  function makeChangeSingleDoc(doc, change, selAfter, spans) {<tr><td><a id="l4511"></a><a href="#l4511">4511</a><td>    if (doc.cm &amp;&amp; !doc.cm.curOp)<tr><td><a id="l4512"></a><a href="#l4512">4512</a><td>      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);<tr><td><a id="l4513"></a><a href="#l4513">4513</a><td><tr><td><a id="l4514"></a><a href="#l4514">4514</a><td>    if (change.to.line &lt; doc.first) {<tr><td><a id="l4515"></a><a href="#l4515">4515</a><td>      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));<tr><td><a id="l4516"></a><a href="#l4516">4516</a><td>      return;<tr><td><a id="l4517"></a><a href="#l4517">4517</a><td>    }<tr><td><a id="l4518"></a><a href="#l4518">4518</a><td>    if (change.from.line &gt; doc.lastLine()) return;<tr><td><a id="l4519"></a><a href="#l4519">4519</a><td><tr><td><a id="l4520"></a><a href="#l4520">4520</a><td>    // Clip the change to the size of this doc<tr><td><a id="l4521"></a><a href="#l4521">4521</a><td>    if (change.from.line &lt; doc.first) {<tr><td><a id="l4522"></a><a href="#l4522">4522</a><td>      var shift = change.text.length - 1 - (doc.first - change.from.line);<tr><td><a id="l4523"></a><a href="#l4523">4523</a><td>      shiftDoc(doc, shift);<tr><td><a id="l4524"></a><a href="#l4524">4524</a><td>      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),<tr><td><a id="l4525"></a><a href="#l4525">4525</a><td>                text: [lst(change.text)], origin: change.origin};<tr><td><a id="l4526"></a><a href="#l4526">4526</a><td>    }<tr><td><a id="l4527"></a><a href="#l4527">4527</a><td>    var last = doc.lastLine();<tr><td><a id="l4528"></a><a href="#l4528">4528</a><td>    if (change.to.line &gt; last) {<tr><td><a id="l4529"></a><a href="#l4529">4529</a><td>      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),<tr><td><a id="l4530"></a><a href="#l4530">4530</a><td>                text: [change.text[0]], origin: change.origin};<tr><td><a id="l4531"></a><a href="#l4531">4531</a><td>    }<tr><td><a id="l4532"></a><a href="#l4532">4532</a><td><tr><td><a id="l4533"></a><a href="#l4533">4533</a><td>    change.removed = getBetween(doc, change.from, change.to);<tr><td><a id="l4534"></a><a href="#l4534">4534</a><td><tr><td><a id="l4535"></a><a href="#l4535">4535</a><td>    if (!selAfter) selAfter = computeSelAfterChange(doc, change);<tr><td><a id="l4536"></a><a href="#l4536">4536</a><td>    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);<tr><td><a id="l4537"></a><a href="#l4537">4537</a><td>    else updateDoc(doc, change, spans);<tr><td><a id="l4538"></a><a href="#l4538">4538</a><td>    setSelectionNoUndo(doc, selAfter, sel_dontScroll);<tr><td><a id="l4539"></a><a href="#l4539">4539</a><td>  }<tr><td><a id="l4540"></a><a href="#l4540">4540</a><td><tr><td><a id="l4541"></a><a href="#l4541">4541</a><td>  // Handle the interaction of a change to a document with the editor<tr><td><a id="l4542"></a><a href="#l4542">4542</a><td>  // that this document is part of.<tr><td><a id="l4543"></a><a href="#l4543">4543</a><td>  function makeChangeSingleDocInEditor(cm, change, spans) {<tr><td><a id="l4544"></a><a href="#l4544">4544</a><td>    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;<tr><td><a id="l4545"></a><a href="#l4545">4545</a><td><tr><td><a id="l4546"></a><a href="#l4546">4546</a><td>    var recomputeMaxLength = false, checkWidthStart = from.line;<tr><td><a id="l4547"></a><a href="#l4547">4547</a><td>    if (!cm.options.lineWrapping) {<tr><td><a id="l4548"></a><a href="#l4548">4548</a><td>      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));<tr><td><a id="l4549"></a><a href="#l4549">4549</a><td>      doc.iter(checkWidthStart, to.line + 1, function(line) {<tr><td><a id="l4550"></a><a href="#l4550">4550</a><td>        if (line == display.maxLine) {<tr><td><a id="l4551"></a><a href="#l4551">4551</a><td>          recomputeMaxLength = true;<tr><td><a id="l4552"></a><a href="#l4552">4552</a><td>          return true;<tr><td><a id="l4553"></a><a href="#l4553">4553</a><td>        }<tr><td><a id="l4554"></a><a href="#l4554">4554</a><td>      });<tr><td><a id="l4555"></a><a href="#l4555">4555</a><td>    }<tr><td><a id="l4556"></a><a href="#l4556">4556</a><td><tr><td><a id="l4557"></a><a href="#l4557">4557</a><td>    if (doc.sel.contains(change.from, change.to) &gt; -1)<tr><td><a id="l4558"></a><a href="#l4558">4558</a><td>      signalCursorActivity(cm);<tr><td><a id="l4559"></a><a href="#l4559">4559</a><td><tr><td><a id="l4560"></a><a href="#l4560">4560</a><td>    updateDoc(doc, change, spans, estimateHeight(cm));<tr><td><a id="l4561"></a><a href="#l4561">4561</a><td><tr><td><a id="l4562"></a><a href="#l4562">4562</a><td>    if (!cm.options.lineWrapping) {<tr><td><a id="l4563"></a><a href="#l4563">4563</a><td>      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {<tr><td><a id="l4564"></a><a href="#l4564">4564</a><td>        var len = lineLength(line);<tr><td><a id="l4565"></a><a href="#l4565">4565</a><td>        if (len &gt; display.maxLineLength) {<tr><td><a id="l4566"></a><a href="#l4566">4566</a><td>          display.maxLine = line;<tr><td><a id="l4567"></a><a href="#l4567">4567</a><td>          display.maxLineLength = len;<tr><td><a id="l4568"></a><a href="#l4568">4568</a><td>          display.maxLineChanged = true;<tr><td><a id="l4569"></a><a href="#l4569">4569</a><td>          recomputeMaxLength = false;<tr><td><a id="l4570"></a><a href="#l4570">4570</a><td>        }<tr><td><a id="l4571"></a><a href="#l4571">4571</a><td>      });<tr><td><a id="l4572"></a><a href="#l4572">4572</a><td>      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;<tr><td><a id="l4573"></a><a href="#l4573">4573</a><td>    }<tr><td><a id="l4574"></a><a href="#l4574">4574</a><td><tr><td><a id="l4575"></a><a href="#l4575">4575</a><td>    // Adjust frontier, schedule worker<tr><td><a id="l4576"></a><a href="#l4576">4576</a><td>    doc.frontier = Math.min(doc.frontier, from.line);<tr><td><a id="l4577"></a><a href="#l4577">4577</a><td>    startWorker(cm, 400);<tr><td><a id="l4578"></a><a href="#l4578">4578</a><td><tr><td><a id="l4579"></a><a href="#l4579">4579</a><td>    var lendiff = change.text.length - (to.line - from.line) - 1;<tr><td><a id="l4580"></a><a href="#l4580">4580</a><td>    // Remember that these lines changed, for updating the display<tr><td><a id="l4581"></a><a href="#l4581">4581</a><td>    if (change.full)<tr><td><a id="l4582"></a><a href="#l4582">4582</a><td>      regChange(cm);<tr><td><a id="l4583"></a><a href="#l4583">4583</a><td>    else if (from.line == to.line &amp;&amp; change.text.length == 1 &amp;&amp; !isWholeLineUpdate(cm.doc, change))<tr><td><a id="l4584"></a><a href="#l4584">4584</a><td>      regLineChange(cm, from.line, &quot;text&quot;);<tr><td><a id="l4585"></a><a href="#l4585">4585</a><td>    else<tr><td><a id="l4586"></a><a href="#l4586">4586</a><td>      regChange(cm, from.line, to.line + 1, lendiff);<tr><td><a id="l4587"></a><a href="#l4587">4587</a><td><tr><td><a id="l4588"></a><a href="#l4588">4588</a><td>    var changesHandler = hasHandler(cm, &quot;changes&quot;), changeHandler = hasHandler(cm, &quot;change&quot;);<tr><td><a id="l4589"></a><a href="#l4589">4589</a><td>    if (changeHandler || changesHandler) {<tr><td><a id="l4590"></a><a href="#l4590">4590</a><td>      var obj = {<tr><td><a id="l4591"></a><a href="#l4591">4591</a><td>        from: from, to: to,<tr><td><a id="l4592"></a><a href="#l4592">4592</a><td>        text: change.text,<tr><td><a id="l4593"></a><a href="#l4593">4593</a><td>        removed: change.removed,<tr><td><a id="l4594"></a><a href="#l4594">4594</a><td>        origin: change.origin<tr><td><a id="l4595"></a><a href="#l4595">4595</a><td>      };<tr><td><a id="l4596"></a><a href="#l4596">4596</a><td>      if (changeHandler) signalLater(cm, &quot;change&quot;, cm, obj);<tr><td><a id="l4597"></a><a href="#l4597">4597</a><td>      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);<tr><td><a id="l4598"></a><a href="#l4598">4598</a><td>    }<tr><td><a id="l4599"></a><a href="#l4599">4599</a><td>    cm.display.selForContextMenu = null;<tr><td><a id="l4600"></a><a href="#l4600">4600</a><td>  }<tr><td><a id="l4601"></a><a href="#l4601">4601</a><td><tr><td><a id="l4602"></a><a href="#l4602">4602</a><td>  function replaceRange(doc, code, from, to, origin) {<tr><td><a id="l4603"></a><a href="#l4603">4603</a><td>    if (!to) to = from;<tr><td><a id="l4604"></a><a href="#l4604">4604</a><td>    if (cmp(to, from) &lt; 0) { var tmp = to; to = from; from = tmp; }<tr><td><a id="l4605"></a><a href="#l4605">4605</a><td>    if (typeof code == &quot;string&quot;) code = doc.splitLines(code);<tr><td><a id="l4606"></a><a href="#l4606">4606</a><td>    makeChange(doc, {from: from, to: to, text: code, origin: origin});<tr><td><a id="l4607"></a><a href="#l4607">4607</a><td>  }<tr><td><a id="l4608"></a><a href="#l4608">4608</a><td><tr><td><a id="l4609"></a><a href="#l4609">4609</a><td>  // SCROLLING THINGS INTO VIEW<tr><td><a id="l4610"></a><a href="#l4610">4610</a><td><tr><td><a id="l4611"></a><a href="#l4611">4611</a><td>  // If an editor sits on the top or bottom of the window, partially<tr><td><a id="l4612"></a><a href="#l4612">4612</a><td>  // scrolled out of view, this ensures that the cursor is visible.<tr><td><a id="l4613"></a><a href="#l4613">4613</a><td>  function maybeScrollWindow(cm, coords) {<tr><td><a id="l4614"></a><a href="#l4614">4614</a><td>    if (signalDOMEvent(cm, &quot;scrollCursorIntoView&quot;)) return;<tr><td><a id="l4615"></a><a href="#l4615">4615</a><td><tr><td><a id="l4616"></a><a href="#l4616">4616</a><td>    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;<tr><td><a id="l4617"></a><a href="#l4617">4617</a><td>    if (coords.top + box.top &lt; 0) doScroll = true;<tr><td><a id="l4618"></a><a href="#l4618">4618</a><td>    else if (coords.bottom + box.top &gt; (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;<tr><td><a id="l4619"></a><a href="#l4619">4619</a><td>    if (doScroll != null &amp;&amp; !phantom) {<tr><td><a id="l4620"></a><a href="#l4620">4620</a><td>      var scrollNode = elt(&quot;div&quot;, &quot;\u200b&quot;, null, &quot;position: absolute; top: &quot; +<tr><td><a id="l4621"></a><a href="#l4621">4621</a><td>                           (coords.top - display.viewOffset - paddingTop(cm.display)) + &quot;px; height: &quot; +<tr><td><a id="l4622"></a><a href="#l4622">4622</a><td>                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + &quot;px; left: &quot; +<tr><td><a id="l4623"></a><a href="#l4623">4623</a><td>                           coords.left + &quot;px; width: 2px;&quot;);<tr><td><a id="l4624"></a><a href="#l4624">4624</a><td>      cm.display.lineSpace.appendChild(scrollNode);<tr><td><a id="l4625"></a><a href="#l4625">4625</a><td>      scrollNode.scrollIntoView(doScroll);<tr><td><a id="l4626"></a><a href="#l4626">4626</a><td>      cm.display.lineSpace.removeChild(scrollNode);<tr><td><a id="l4627"></a><a href="#l4627">4627</a><td>    }<tr><td><a id="l4628"></a><a href="#l4628">4628</a><td>  }<tr><td><a id="l4629"></a><a href="#l4629">4629</a><td><tr><td><a id="l4630"></a><a href="#l4630">4630</a><td>  // Scroll a given position into view (immediately), verifying that<tr><td><a id="l4631"></a><a href="#l4631">4631</a><td>  // it actually became visible (as line heights are accurately<tr><td><a id="l4632"></a><a href="#l4632">4632</a><td>  // measured, the position of something may &#39;drift&#39; during drawing).<tr><td><a id="l4633"></a><a href="#l4633">4633</a><td>  function scrollPosIntoView(cm, pos, end, margin) {<tr><td><a id="l4634"></a><a href="#l4634">4634</a><td>    if (margin == null) margin = 0;<tr><td><a id="l4635"></a><a href="#l4635">4635</a><td>    for (var limit = 0; limit &lt; 5; limit++) {<tr><td><a id="l4636"></a><a href="#l4636">4636</a><td>      var changed = false, coords = cursorCoords(cm, pos);<tr><td><a id="l4637"></a><a href="#l4637">4637</a><td>      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);<tr><td><a id="l4638"></a><a href="#l4638">4638</a><td>      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),<tr><td><a id="l4639"></a><a href="#l4639">4639</a><td>                                         Math.min(coords.top, endCoords.top) - margin,<tr><td><a id="l4640"></a><a href="#l4640">4640</a><td>                                         Math.max(coords.left, endCoords.left),<tr><td><a id="l4641"></a><a href="#l4641">4641</a><td>                                         Math.max(coords.bottom, endCoords.bottom) + margin);<tr><td><a id="l4642"></a><a href="#l4642">4642</a><td>      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;<tr><td><a id="l4643"></a><a href="#l4643">4643</a><td>      if (scrollPos.scrollTop != null) {<tr><td><a id="l4644"></a><a href="#l4644">4644</a><td>        setScrollTop(cm, scrollPos.scrollTop);<tr><td><a id="l4645"></a><a href="#l4645">4645</a><td>        if (Math.abs(cm.doc.scrollTop - startTop) &gt; 1) changed = true;<tr><td><a id="l4646"></a><a href="#l4646">4646</a><td>      }<tr><td><a id="l4647"></a><a href="#l4647">4647</a><td>      if (scrollPos.scrollLeft != null) {<tr><td><a id="l4648"></a><a href="#l4648">4648</a><td>        setScrollLeft(cm, scrollPos.scrollLeft);<tr><td><a id="l4649"></a><a href="#l4649">4649</a><td>        if (Math.abs(cm.doc.scrollLeft - startLeft) &gt; 1) changed = true;<tr><td><a id="l4650"></a><a href="#l4650">4650</a><td>      }<tr><td><a id="l4651"></a><a href="#l4651">4651</a><td>      if (!changed) break;<tr><td><a id="l4652"></a><a href="#l4652">4652</a><td>    }<tr><td><a id="l4653"></a><a href="#l4653">4653</a><td>    return coords;<tr><td><a id="l4654"></a><a href="#l4654">4654</a><td>  }<tr><td><a id="l4655"></a><a href="#l4655">4655</a><td><tr><td><a id="l4656"></a><a href="#l4656">4656</a><td>  // Scroll a given set of coordinates into view (immediately).<tr><td><a id="l4657"></a><a href="#l4657">4657</a><td>  function scrollIntoView(cm, x1, y1, x2, y2) {<tr><td><a id="l4658"></a><a href="#l4658">4658</a><td>    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);<tr><td><a id="l4659"></a><a href="#l4659">4659</a><td>    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);<tr><td><a id="l4660"></a><a href="#l4660">4660</a><td>    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);<tr><td><a id="l4661"></a><a href="#l4661">4661</a><td>  }<tr><td><a id="l4662"></a><a href="#l4662">4662</a><td><tr><td><a id="l4663"></a><a href="#l4663">4663</a><td>  // Calculate a new scroll position needed to scroll the given<tr><td><a id="l4664"></a><a href="#l4664">4664</a><td>  // rectangle into view. Returns an object with scrollTop and<tr><td><a id="l4665"></a><a href="#l4665">4665</a><td>  // scrollLeft properties. When these are undefined, the<tr><td><a id="l4666"></a><a href="#l4666">4666</a><td>  // vertical/horizontal position does not need to be adjusted.<tr><td><a id="l4667"></a><a href="#l4667">4667</a><td>  function calculateScrollPos(cm, x1, y1, x2, y2) {<tr><td><a id="l4668"></a><a href="#l4668">4668</a><td>    var display = cm.display, snapMargin = textHeight(cm.display);<tr><td><a id="l4669"></a><a href="#l4669">4669</a><td>    if (y1 &lt; 0) y1 = 0;<tr><td><a id="l4670"></a><a href="#l4670">4670</a><td>    var screentop = cm.curOp &amp;&amp; cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;<tr><td><a id="l4671"></a><a href="#l4671">4671</a><td>    var screen = displayHeight(cm), result = {};<tr><td><a id="l4672"></a><a href="#l4672">4672</a><td>    if (y2 - y1 &gt; screen) y2 = y1 + screen;<tr><td><a id="l4673"></a><a href="#l4673">4673</a><td>    var docBottom = cm.doc.height + paddingVert(display);<tr><td><a id="l4674"></a><a href="#l4674">4674</a><td>    var atTop = y1 &lt; snapMargin, atBottom = y2 &gt; docBottom - snapMargin;<tr><td><a id="l4675"></a><a href="#l4675">4675</a><td>    if (y1 &lt; screentop) {<tr><td><a id="l4676"></a><a href="#l4676">4676</a><td>      result.scrollTop = atTop ? 0 : y1;<tr><td><a id="l4677"></a><a href="#l4677">4677</a><td>    } else if (y2 &gt; screentop + screen) {<tr><td><a id="l4678"></a><a href="#l4678">4678</a><td>      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);<tr><td><a id="l4679"></a><a href="#l4679">4679</a><td>      if (newTop != screentop) result.scrollTop = newTop;<tr><td><a id="l4680"></a><a href="#l4680">4680</a><td>    }<tr><td><a id="l4681"></a><a href="#l4681">4681</a><td><tr><td><a id="l4682"></a><a href="#l4682">4682</a><td>    var screenleft = cm.curOp &amp;&amp; cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;<tr><td><a id="l4683"></a><a href="#l4683">4683</a><td>    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);<tr><td><a id="l4684"></a><a href="#l4684">4684</a><td>    var tooWide = x2 - x1 &gt; screenw;<tr><td><a id="l4685"></a><a href="#l4685">4685</a><td>    if (tooWide) x2 = x1 + screenw;<tr><td><a id="l4686"></a><a href="#l4686">4686</a><td>    if (x1 &lt; 10)<tr><td><a id="l4687"></a><a href="#l4687">4687</a><td>      result.scrollLeft = 0;<tr><td><a id="l4688"></a><a href="#l4688">4688</a><td>    else if (x1 &lt; screenleft)<tr><td><a id="l4689"></a><a href="#l4689">4689</a><td>      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));<tr><td><a id="l4690"></a><a href="#l4690">4690</a><td>    else if (x2 &gt; screenw + screenleft - 3)<tr><td><a id="l4691"></a><a href="#l4691">4691</a><td>      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;<tr><td><a id="l4692"></a><a href="#l4692">4692</a><td>    return result;<tr><td><a id="l4693"></a><a href="#l4693">4693</a><td>  }<tr><td><a id="l4694"></a><a href="#l4694">4694</a><td><tr><td><a id="l4695"></a><a href="#l4695">4695</a><td>  // Store a relative adjustment to the scroll position in the current<tr><td><a id="l4696"></a><a href="#l4696">4696</a><td>  // operation (to be applied when the operation finishes).<tr><td><a id="l4697"></a><a href="#l4697">4697</a><td>  function addToScrollPos(cm, left, top) {<tr><td><a id="l4698"></a><a href="#l4698">4698</a><td>    if (left != null || top != null) resolveScrollToPos(cm);<tr><td><a id="l4699"></a><a href="#l4699">4699</a><td>    if (left != null)<tr><td><a id="l4700"></a><a href="#l4700">4700</a><td>      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;<tr><td><a id="l4701"></a><a href="#l4701">4701</a><td>    if (top != null)<tr><td><a id="l4702"></a><a href="#l4702">4702</a><td>      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;<tr><td><a id="l4703"></a><a href="#l4703">4703</a><td>  }<tr><td><a id="l4704"></a><a href="#l4704">4704</a><td><tr><td><a id="l4705"></a><a href="#l4705">4705</a><td>  // Make sure that at the end of the operation the current cursor is<tr><td><a id="l4706"></a><a href="#l4706">4706</a><td>  // shown.<tr><td><a id="l4707"></a><a href="#l4707">4707</a><td>  function ensureCursorVisible(cm) {<tr><td><a id="l4708"></a><a href="#l4708">4708</a><td>    resolveScrollToPos(cm);<tr><td><a id="l4709"></a><a href="#l4709">4709</a><td>    var cur = cm.getCursor(), from = cur, to = cur;<tr><td><a id="l4710"></a><a href="#l4710">4710</a><td>    if (!cm.options.lineWrapping) {<tr><td><a id="l4711"></a><a href="#l4711">4711</a><td>      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;<tr><td><a id="l4712"></a><a href="#l4712">4712</a><td>      to = Pos(cur.line, cur.ch + 1);<tr><td><a id="l4713"></a><a href="#l4713">4713</a><td>    }<tr><td><a id="l4714"></a><a href="#l4714">4714</a><td>    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};<tr><td><a id="l4715"></a><a href="#l4715">4715</a><td>  }<tr><td><a id="l4716"></a><a href="#l4716">4716</a><td><tr><td><a id="l4717"></a><a href="#l4717">4717</a><td>  // When an operation has its scrollToPos property set, and another<tr><td><a id="l4718"></a><a href="#l4718">4718</a><td>  // scroll action is applied before the end of the operation, this<tr><td><a id="l4719"></a><a href="#l4719">4719</a><td>  // &#39;simulates&#39; scrolling that position into view in a cheap way, so<tr><td><a id="l4720"></a><a href="#l4720">4720</a><td>  // that the effect of intermediate scroll commands is not ignored.<tr><td><a id="l4721"></a><a href="#l4721">4721</a><td>  function resolveScrollToPos(cm) {<tr><td><a id="l4722"></a><a href="#l4722">4722</a><td>    var range = cm.curOp.scrollToPos;<tr><td><a id="l4723"></a><a href="#l4723">4723</a><td>    if (range) {<tr><td><a id="l4724"></a><a href="#l4724">4724</a><td>      cm.curOp.scrollToPos = null;<tr><td><a id="l4725"></a><a href="#l4725">4725</a><td>      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);<tr><td><a id="l4726"></a><a href="#l4726">4726</a><td>      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),<tr><td><a id="l4727"></a><a href="#l4727">4727</a><td>                                    Math.min(from.top, to.top) - range.margin,<tr><td><a id="l4728"></a><a href="#l4728">4728</a><td>                                    Math.max(from.right, to.right),<tr><td><a id="l4729"></a><a href="#l4729">4729</a><td>                                    Math.max(from.bottom, to.bottom) + range.margin);<tr><td><a id="l4730"></a><a href="#l4730">4730</a><td>      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);<tr><td><a id="l4731"></a><a href="#l4731">4731</a><td>    }<tr><td><a id="l4732"></a><a href="#l4732">4732</a><td>  }<tr><td><a id="l4733"></a><a href="#l4733">4733</a><td><tr><td><a id="l4734"></a><a href="#l4734">4734</a><td>  // API UTILITIES<tr><td><a id="l4735"></a><a href="#l4735">4735</a><td><tr><td><a id="l4736"></a><a href="#l4736">4736</a><td>  // Indent the given line. The how parameter can be &quot;smart&quot;,<tr><td><a id="l4737"></a><a href="#l4737">4737</a><td>  // &quot;add&quot;/null, &quot;subtract&quot;, or &quot;prev&quot;. When aggressive is false<tr><td><a id="l4738"></a><a href="#l4738">4738</a><td>  // (typically set to true for forced single-line indents), empty<tr><td><a id="l4739"></a><a href="#l4739">4739</a><td>  // lines are not indented, and places where the mode returns Pass<tr><td><a id="l4740"></a><a href="#l4740">4740</a><td>  // are left alone.<tr><td><a id="l4741"></a><a href="#l4741">4741</a><td>  function indentLine(cm, n, how, aggressive) {<tr><td><a id="l4742"></a><a href="#l4742">4742</a><td>    var doc = cm.doc, state;<tr><td><a id="l4743"></a><a href="#l4743">4743</a><td>    if (how == null) how = &quot;add&quot;;<tr><td><a id="l4744"></a><a href="#l4744">4744</a><td>    if (how == &quot;smart&quot;) {<tr><td><a id="l4745"></a><a href="#l4745">4745</a><td>      // Fall back to &quot;prev&quot; when the mode doesn&#39;t have an indentation<tr><td><a id="l4746"></a><a href="#l4746">4746</a><td>      // method.<tr><td><a id="l4747"></a><a href="#l4747">4747</a><td>      if (!doc.mode.indent) how = &quot;prev&quot;;<tr><td><a id="l4748"></a><a href="#l4748">4748</a><td>      else state = getStateBefore(cm, n);<tr><td><a id="l4749"></a><a href="#l4749">4749</a><td>    }<tr><td><a id="l4750"></a><a href="#l4750">4750</a><td><tr><td><a id="l4751"></a><a href="#l4751">4751</a><td>    var tabSize = cm.options.tabSize;<tr><td><a id="l4752"></a><a href="#l4752">4752</a><td>    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);<tr><td><a id="l4753"></a><a href="#l4753">4753</a><td>    if (line.stateAfter) line.stateAfter = null;<tr><td><a id="l4754"></a><a href="#l4754">4754</a><td>    var curSpaceString = line.text.match(/^\s*/)[0], indentation;<tr><td><a id="l4755"></a><a href="#l4755">4755</a><td>    if (!aggressive &amp;&amp; !/\S/.test(line.text)) {<tr><td><a id="l4756"></a><a href="#l4756">4756</a><td>      indentation = 0;<tr><td><a id="l4757"></a><a href="#l4757">4757</a><td>      how = &quot;not&quot;;<tr><td><a id="l4758"></a><a href="#l4758">4758</a><td>    } else if (how == &quot;smart&quot;) {<tr><td><a id="l4759"></a><a href="#l4759">4759</a><td>      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);<tr><td><a id="l4760"></a><a href="#l4760">4760</a><td>      if (indentation == Pass || indentation &gt; 150) {<tr><td><a id="l4761"></a><a href="#l4761">4761</a><td>        if (!aggressive) return;<tr><td><a id="l4762"></a><a href="#l4762">4762</a><td>        how = &quot;prev&quot;;<tr><td><a id="l4763"></a><a href="#l4763">4763</a><td>      }<tr><td><a id="l4764"></a><a href="#l4764">4764</a><td>    }<tr><td><a id="l4765"></a><a href="#l4765">4765</a><td>    if (how == &quot;prev&quot;) {<tr><td><a id="l4766"></a><a href="#l4766">4766</a><td>      if (n &gt; doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);<tr><td><a id="l4767"></a><a href="#l4767">4767</a><td>      else indentation = 0;<tr><td><a id="l4768"></a><a href="#l4768">4768</a><td>    } else if (how == &quot;add&quot;) {<tr><td><a id="l4769"></a><a href="#l4769">4769</a><td>      indentation = curSpace + cm.options.indentUnit;<tr><td><a id="l4770"></a><a href="#l4770">4770</a><td>    } else if (how == &quot;subtract&quot;) {<tr><td><a id="l4771"></a><a href="#l4771">4771</a><td>      indentation = curSpace - cm.options.indentUnit;<tr><td><a id="l4772"></a><a href="#l4772">4772</a><td>    } else if (typeof how == &quot;number&quot;) {<tr><td><a id="l4773"></a><a href="#l4773">4773</a><td>      indentation = curSpace + how;<tr><td><a id="l4774"></a><a href="#l4774">4774</a><td>    }<tr><td><a id="l4775"></a><a href="#l4775">4775</a><td>    indentation = Math.max(0, indentation);<tr><td><a id="l4776"></a><a href="#l4776">4776</a><td><tr><td><a id="l4777"></a><a href="#l4777">4777</a><td>    var indentString = &quot;&quot;, pos = 0;<tr><td><a id="l4778"></a><a href="#l4778">4778</a><td>    if (cm.options.indentWithTabs)<tr><td><a id="l4779"></a><a href="#l4779">4779</a><td>      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += &quot;\t&quot;;}<tr><td><a id="l4780"></a><a href="#l4780">4780</a><td>    if (pos &lt; indentation) indentString += spaceStr(indentation - pos);<tr><td><a id="l4781"></a><a href="#l4781">4781</a><td><tr><td><a id="l4782"></a><a href="#l4782">4782</a><td>    if (indentString != curSpaceString) {<tr><td><a id="l4783"></a><a href="#l4783">4783</a><td>      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), &quot;+input&quot;);<tr><td><a id="l4784"></a><a href="#l4784">4784</a><td>      line.stateAfter = null;<tr><td><a id="l4785"></a><a href="#l4785">4785</a><td>      return true;<tr><td><a id="l4786"></a><a href="#l4786">4786</a><td>    } else {<tr><td><a id="l4787"></a><a href="#l4787">4787</a><td>      // Ensure that, if the cursor was in the whitespace at the start<tr><td><a id="l4788"></a><a href="#l4788">4788</a><td>      // of the line, it is moved to the end of that space.<tr><td><a id="l4789"></a><a href="#l4789">4789</a><td>      for (var i = 0; i &lt; doc.sel.ranges.length; i++) {<tr><td><a id="l4790"></a><a href="#l4790">4790</a><td>        var range = doc.sel.ranges[i];<tr><td><a id="l4791"></a><a href="#l4791">4791</a><td>        if (range.head.line == n &amp;&amp; range.head.ch &lt; curSpaceString.length) {<tr><td><a id="l4792"></a><a href="#l4792">4792</a><td>          var pos = Pos(n, curSpaceString.length);<tr><td><a id="l4793"></a><a href="#l4793">4793</a><td>          replaceOneSelection(doc, i, new Range(pos, pos));<tr><td><a id="l4794"></a><a href="#l4794">4794</a><td>          break;<tr><td><a id="l4795"></a><a href="#l4795">4795</a><td>        }<tr><td><a id="l4796"></a><a href="#l4796">4796</a><td>      }<tr><td><a id="l4797"></a><a href="#l4797">4797</a><td>    }<tr><td><a id="l4798"></a><a href="#l4798">4798</a><td>  }<tr><td><a id="l4799"></a><a href="#l4799">4799</a><td><tr><td><a id="l4800"></a><a href="#l4800">4800</a><td>  // Utility for applying a change to a line by handle or number,<tr><td><a id="l4801"></a><a href="#l4801">4801</a><td>  // returning the number and optionally registering the line as<tr><td><a id="l4802"></a><a href="#l4802">4802</a><td>  // changed.<tr><td><a id="l4803"></a><a href="#l4803">4803</a><td>  function changeLine(doc, handle, changeType, op) {<tr><td><a id="l4804"></a><a href="#l4804">4804</a><td>    var no = handle, line = handle;<tr><td><a id="l4805"></a><a href="#l4805">4805</a><td>    if (typeof handle == &quot;number&quot;) line = getLine(doc, clipLine(doc, handle));<tr><td><a id="l4806"></a><a href="#l4806">4806</a><td>    else no = lineNo(handle);<tr><td><a id="l4807"></a><a href="#l4807">4807</a><td>    if (no == null) return null;<tr><td><a id="l4808"></a><a href="#l4808">4808</a><td>    if (op(line, no) &amp;&amp; doc.cm) regLineChange(doc.cm, no, changeType);<tr><td><a id="l4809"></a><a href="#l4809">4809</a><td>    return line;<tr><td><a id="l4810"></a><a href="#l4810">4810</a><td>  }<tr><td><a id="l4811"></a><a href="#l4811">4811</a><td><tr><td><a id="l4812"></a><a href="#l4812">4812</a><td>  // Helper for deleting text near the selection(s), used to implement<tr><td><a id="l4813"></a><a href="#l4813">4813</a><td>  // backspace, delete, and similar functionality.<tr><td><a id="l4814"></a><a href="#l4814">4814</a><td>  function deleteNearSelection(cm, compute) {<tr><td><a id="l4815"></a><a href="#l4815">4815</a><td>    var ranges = cm.doc.sel.ranges, kill = [];<tr><td><a id="l4816"></a><a href="#l4816">4816</a><td>    // Build up a set of ranges to kill first, merging overlapping<tr><td><a id="l4817"></a><a href="#l4817">4817</a><td>    // ranges.<tr><td><a id="l4818"></a><a href="#l4818">4818</a><td>    for (var i = 0; i &lt; ranges.length; i++) {<tr><td><a id="l4819"></a><a href="#l4819">4819</a><td>      var toKill = compute(ranges[i]);<tr><td><a id="l4820"></a><a href="#l4820">4820</a><td>      while (kill.length &amp;&amp; cmp(toKill.from, lst(kill).to) &lt;= 0) {<tr><td><a id="l4821"></a><a href="#l4821">4821</a><td>        var replaced = kill.pop();<tr><td><a id="l4822"></a><a href="#l4822">4822</a><td>        if (cmp(replaced.from, toKill.from) &lt; 0) {<tr><td><a id="l4823"></a><a href="#l4823">4823</a><td>          toKill.from = replaced.from;<tr><td><a id="l4824"></a><a href="#l4824">4824</a><td>          break;<tr><td><a id="l4825"></a><a href="#l4825">4825</a><td>        }<tr><td><a id="l4826"></a><a href="#l4826">4826</a><td>      }<tr><td><a id="l4827"></a><a href="#l4827">4827</a><td>      kill.push(toKill);<tr><td><a id="l4828"></a><a href="#l4828">4828</a><td>    }<tr><td><a id="l4829"></a><a href="#l4829">4829</a><td>    // Next, remove those actual ranges.<tr><td><a id="l4830"></a><a href="#l4830">4830</a><td>    runInOp(cm, function() {<tr><td><a id="l4831"></a><a href="#l4831">4831</a><td>      for (var i = kill.length - 1; i &gt;= 0; i--)<tr><td><a id="l4832"></a><a href="#l4832">4832</a><td>        replaceRange(cm.doc, &quot;&quot;, kill[i].from, kill[i].to, &quot;+delete&quot;);<tr><td><a id="l4833"></a><a href="#l4833">4833</a><td>      ensureCursorVisible(cm);<tr><td><a id="l4834"></a><a href="#l4834">4834</a><td>    });<tr><td><a id="l4835"></a><a href="#l4835">4835</a><td>  }<tr><td><a id="l4836"></a><a href="#l4836">4836</a><td><tr><td><a id="l4837"></a><a href="#l4837">4837</a><td>  // Used for horizontal relative motion. Dir is -1 or 1 (left or<tr><td><a id="l4838"></a><a href="#l4838">4838</a><td>  // right), unit can be &quot;char&quot;, &quot;column&quot; (like char, but doesn&#39;t<tr><td><a id="l4839"></a><a href="#l4839">4839</a><td>  // cross line boundaries), &quot;word&quot; (across next word), or &quot;group&quot; (to<tr><td><a id="l4840"></a><a href="#l4840">4840</a><td>  // the start of next group of word or non-word-non-whitespace<tr><td><a id="l4841"></a><a href="#l4841">4841</a><td>  // chars). The visually param controls whether, in right-to-left<tr><td><a id="l4842"></a><a href="#l4842">4842</a><td>  // text, direction 1 means to move towards the next index in the<tr><td><a id="l4843"></a><a href="#l4843">4843</a><td>  // string, or towards the character to the right of the current<tr><td><a id="l4844"></a><a href="#l4844">4844</a><td>  // position. The resulting position will have a hitSide=true<tr><td><a id="l4845"></a><a href="#l4845">4845</a><td>  // property if it reached the end of the document.<tr><td><a id="l4846"></a><a href="#l4846">4846</a><td>  function findPosH(doc, pos, dir, unit, visually) {<tr><td><a id="l4847"></a><a href="#l4847">4847</a><td>    var line = pos.line, ch = pos.ch, origDir = dir;<tr><td><a id="l4848"></a><a href="#l4848">4848</a><td>    var lineObj = getLine(doc, line);<tr><td><a id="l4849"></a><a href="#l4849">4849</a><td>    function findNextLine() {<tr><td><a id="l4850"></a><a href="#l4850">4850</a><td>      var l = line + dir;<tr><td><a id="l4851"></a><a href="#l4851">4851</a><td>      if (l &lt; doc.first || l &gt;= doc.first + doc.size) return false<tr><td><a id="l4852"></a><a href="#l4852">4852</a><td>      line = l;<tr><td><a id="l4853"></a><a href="#l4853">4853</a><td>      return lineObj = getLine(doc, l);<tr><td><a id="l4854"></a><a href="#l4854">4854</a><td>    }<tr><td><a id="l4855"></a><a href="#l4855">4855</a><td>    function moveOnce(boundToLine) {<tr><td><a id="l4856"></a><a href="#l4856">4856</a><td>      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);<tr><td><a id="l4857"></a><a href="#l4857">4857</a><td>      if (next == null) {<tr><td><a id="l4858"></a><a href="#l4858">4858</a><td>        if (!boundToLine &amp;&amp; findNextLine()) {<tr><td><a id="l4859"></a><a href="#l4859">4859</a><td>          if (visually) ch = (dir &lt; 0 ? lineRight : lineLeft)(lineObj);<tr><td><a id="l4860"></a><a href="#l4860">4860</a><td>          else ch = dir &lt; 0 ? lineObj.text.length : 0;<tr><td><a id="l4861"></a><a href="#l4861">4861</a><td>        } else return false<tr><td><a id="l4862"></a><a href="#l4862">4862</a><td>      } else ch = next;<tr><td><a id="l4863"></a><a href="#l4863">4863</a><td>      return true;<tr><td><a id="l4864"></a><a href="#l4864">4864</a><td>    }<tr><td><a id="l4865"></a><a href="#l4865">4865</a><td><tr><td><a id="l4866"></a><a href="#l4866">4866</a><td>    if (unit == &quot;char&quot;) {<tr><td><a id="l4867"></a><a href="#l4867">4867</a><td>      moveOnce()<tr><td><a id="l4868"></a><a href="#l4868">4868</a><td>    } else if (unit == &quot;column&quot;) {<tr><td><a id="l4869"></a><a href="#l4869">4869</a><td>      moveOnce(true)<tr><td><a id="l4870"></a><a href="#l4870">4870</a><td>    } else if (unit == &quot;word&quot; || unit == &quot;group&quot;) {<tr><td><a id="l4871"></a><a href="#l4871">4871</a><td>      var sawType = null, group = unit == &quot;group&quot;;<tr><td><a id="l4872"></a><a href="#l4872">4872</a><td>      var helper = doc.cm &amp;&amp; doc.cm.getHelper(pos, &quot;wordChars&quot;);<tr><td><a id="l4873"></a><a href="#l4873">4873</a><td>      for (var first = true;; first = false) {<tr><td><a id="l4874"></a><a href="#l4874">4874</a><td>        if (dir &lt; 0 &amp;&amp; !moveOnce(!first)) break;<tr><td><a id="l4875"></a><a href="#l4875">4875</a><td>        var cur = lineObj.text.charAt(ch) || &quot;\n&quot;;<tr><td><a id="l4876"></a><a href="#l4876">4876</a><td>        var type = isWordChar(cur, helper) ? &quot;w&quot;<tr><td><a id="l4877"></a><a href="#l4877">4877</a><td>          : group &amp;&amp; cur == &quot;\n&quot; ? &quot;n&quot;<tr><td><a id="l4878"></a><a href="#l4878">4878</a><td>          : !group || /\s/.test(cur) ? null<tr><td><a id="l4879"></a><a href="#l4879">4879</a><td>          : &quot;p&quot;;<tr><td><a id="l4880"></a><a href="#l4880">4880</a><td>        if (group &amp;&amp; !first &amp;&amp; !type) type = &quot;s&quot;;<tr><td><a id="l4881"></a><a href="#l4881">4881</a><td>        if (sawType &amp;&amp; sawType != type) {<tr><td><a id="l4882"></a><a href="#l4882">4882</a><td>          if (dir &lt; 0) {dir = 1; moveOnce();}<tr><td><a id="l4883"></a><a href="#l4883">4883</a><td>          break;<tr><td><a id="l4884"></a><a href="#l4884">4884</a><td>        }<tr><td><a id="l4885"></a><a href="#l4885">4885</a><td><tr><td><a id="l4886"></a><a href="#l4886">4886</a><td>        if (type) sawType = type;<tr><td><a id="l4887"></a><a href="#l4887">4887</a><td>        if (dir &gt; 0 &amp;&amp; !moveOnce(!first)) break;<tr><td><a id="l4888"></a><a href="#l4888">4888</a><td>      }<tr><td><a id="l4889"></a><a href="#l4889">4889</a><td>    }<tr><td><a id="l4890"></a><a href="#l4890">4890</a><td>    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);<tr><td><a id="l4891"></a><a href="#l4891">4891</a><td>    if (!cmp(pos, result)) result.hitSide = true;<tr><td><a id="l4892"></a><a href="#l4892">4892</a><td>    return result;<tr><td><a id="l4893"></a><a href="#l4893">4893</a><td>  }<tr><td><a id="l4894"></a><a href="#l4894">4894</a><td><tr><td><a id="l4895"></a><a href="#l4895">4895</a><td>  // For relative vertical movement. Dir may be -1 or 1. Unit can be<tr><td><a id="l4896"></a><a href="#l4896">4896</a><td>  // &quot;page&quot; or &quot;line&quot;. The resulting position will have a hitSide=true<tr><td><a id="l4897"></a><a href="#l4897">4897</a><td>  // property if it reached the end of the document.<tr><td><a id="l4898"></a><a href="#l4898">4898</a><td>  function findPosV(cm, pos, dir, unit) {<tr><td><a id="l4899"></a><a href="#l4899">4899</a><td>    var doc = cm.doc, x = pos.left, y;<tr><td><a id="l4900"></a><a href="#l4900">4900</a><td>    if (unit == &quot;page&quot;) {<tr><td><a id="l4901"></a><a href="#l4901">4901</a><td>      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);<tr><td><a id="l4902"></a><a href="#l4902">4902</a><td>      y = pos.top + dir * (pageSize - (dir &lt; 0 ? 1.5 : .5) * textHeight(cm.display));<tr><td><a id="l4903"></a><a href="#l4903">4903</a><td>    } else if (unit == &quot;line&quot;) {<tr><td><a id="l4904"></a><a href="#l4904">4904</a><td>      y = dir &gt; 0 ? pos.bottom + 3 : pos.top - 3;<tr><td><a id="l4905"></a><a href="#l4905">4905</a><td>    }<tr><td><a id="l4906"></a><a href="#l4906">4906</a><td>    for (;;) {<tr><td><a id="l4907"></a><a href="#l4907">4907</a><td>      var target = coordsChar(cm, x, y);<tr><td><a id="l4908"></a><a href="#l4908">4908</a><td>      if (!target.outside) break;<tr><td><a id="l4909"></a><a href="#l4909">4909</a><td>      if (dir &lt; 0 ? y &lt;= 0 : y &gt;= doc.height) { target.hitSide = true; break; }<tr><td><a id="l4910"></a><a href="#l4910">4910</a><td>      y += dir * 5;<tr><td><a id="l4911"></a><a href="#l4911">4911</a><td>    }<tr><td><a id="l4912"></a><a href="#l4912">4912</a><td>    return target;<tr><td><a id="l4913"></a><a href="#l4913">4913</a><td>  }<tr><td><a id="l4914"></a><a href="#l4914">4914</a><td><tr><td><a id="l4915"></a><a href="#l4915">4915</a><td>  // EDITOR METHODS<tr><td><a id="l4916"></a><a href="#l4916">4916</a><td><tr><td><a id="l4917"></a><a href="#l4917">4917</a><td>  // The publicly visible API. Note that methodOp(f) means<tr><td><a id="l4918"></a><a href="#l4918">4918</a><td>  // &#39;wrap f in an operation, performed on its `this` parameter&#39;.<tr><td><a id="l4919"></a><a href="#l4919">4919</a><td><tr><td><a id="l4920"></a><a href="#l4920">4920</a><td>  // This is not the complete set of editor methods. Most of the<tr><td><a id="l4921"></a><a href="#l4921">4921</a><td>  // methods defined on the Doc type are also injected into<tr><td><a id="l4922"></a><a href="#l4922">4922</a><td>  // CodeMirror.prototype, for backwards compatibility and<tr><td><a id="l4923"></a><a href="#l4923">4923</a><td>  // convenience.<tr><td><a id="l4924"></a><a href="#l4924">4924</a><td><tr><td><a id="l4925"></a><a href="#l4925">4925</a><td>  CodeMirror.prototype = {<tr><td><a id="l4926"></a><a href="#l4926">4926</a><td>    constructor: CodeMirror,<tr><td><a id="l4927"></a><a href="#l4927">4927</a><td>    focus: function(){window.focus(); this.display.input.focus();},<tr><td><a id="l4928"></a><a href="#l4928">4928</a><td><tr><td><a id="l4929"></a><a href="#l4929">4929</a><td>    setOption: function(option, value) {<tr><td><a id="l4930"></a><a href="#l4930">4930</a><td>      var options = this.options, old = options[option];<tr><td><a id="l4931"></a><a href="#l4931">4931</a><td>      if (options[option] == value &amp;&amp; option != &quot;mode&quot;) return;<tr><td><a id="l4932"></a><a href="#l4932">4932</a><td>      options[option] = value;<tr><td><a id="l4933"></a><a href="#l4933">4933</a><td>      if (optionHandlers.hasOwnProperty(option))<tr><td><a id="l4934"></a><a href="#l4934">4934</a><td>        operation(this, optionHandlers[option])(this, value, old);<tr><td><a id="l4935"></a><a href="#l4935">4935</a><td>    },<tr><td><a id="l4936"></a><a href="#l4936">4936</a><td><tr><td><a id="l4937"></a><a href="#l4937">4937</a><td>    getOption: function(option) {return this.options[option];},<tr><td><a id="l4938"></a><a href="#l4938">4938</a><td>    getDoc: function() {return this.doc;},<tr><td><a id="l4939"></a><a href="#l4939">4939</a><td><tr><td><a id="l4940"></a><a href="#l4940">4940</a><td>    addKeyMap: function(map, bottom) {<tr><td><a id="l4941"></a><a href="#l4941">4941</a><td>      this.state.keyMaps[bottom ? &quot;push&quot; : &quot;unshift&quot;](getKeyMap(map));<tr><td><a id="l4942"></a><a href="#l4942">4942</a><td>    },<tr><td><a id="l4943"></a><a href="#l4943">4943</a><td>    removeKeyMap: function(map) {<tr><td><a id="l4944"></a><a href="#l4944">4944</a><td>      var maps = this.state.keyMaps;<tr><td><a id="l4945"></a><a href="#l4945">4945</a><td>      for (var i = 0; i &lt; maps.length; ++i)<tr><td><a id="l4946"></a><a href="#l4946">4946</a><td>        if (maps[i] == map || maps[i].name == map) {<tr><td><a id="l4947"></a><a href="#l4947">4947</a><td>          maps.splice(i, 1);<tr><td><a id="l4948"></a><a href="#l4948">4948</a><td>          return true;<tr><td><a id="l4949"></a><a href="#l4949">4949</a><td>        }<tr><td><a id="l4950"></a><a href="#l4950">4950</a><td>    },<tr><td><a id="l4951"></a><a href="#l4951">4951</a><td><tr><td><a id="l4952"></a><a href="#l4952">4952</a><td>    addOverlay: methodOp(function(spec, options) {<tr><td><a id="l4953"></a><a href="#l4953">4953</a><td>      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);<tr><td><a id="l4954"></a><a href="#l4954">4954</a><td>      if (mode.startState) throw new Error(&quot;Overlays may not be stateful.&quot;);<tr><td><a id="l4955"></a><a href="#l4955">4955</a><td>      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options &amp;&amp; options.opaque});<tr><td><a id="l4956"></a><a href="#l4956">4956</a><td>      this.state.modeGen++;<tr><td><a id="l4957"></a><a href="#l4957">4957</a><td>      regChange(this);<tr><td><a id="l4958"></a><a href="#l4958">4958</a><td>    }),<tr><td><a id="l4959"></a><a href="#l4959">4959</a><td>    removeOverlay: methodOp(function(spec) {<tr><td><a id="l4960"></a><a href="#l4960">4960</a><td>      var overlays = this.state.overlays;<tr><td><a id="l4961"></a><a href="#l4961">4961</a><td>      for (var i = 0; i &lt; overlays.length; ++i) {<tr><td><a id="l4962"></a><a href="#l4962">4962</a><td>        var cur = overlays[i].modeSpec;<tr><td><a id="l4963"></a><a href="#l4963">4963</a><td>        if (cur == spec || typeof spec == &quot;string&quot; &amp;&amp; cur.name == spec) {<tr><td><a id="l4964"></a><a href="#l4964">4964</a><td>          overlays.splice(i, 1);<tr><td><a id="l4965"></a><a href="#l4965">4965</a><td>          this.state.modeGen++;<tr><td><a id="l4966"></a><a href="#l4966">4966</a><td>          regChange(this);<tr><td><a id="l4967"></a><a href="#l4967">4967</a><td>          return;<tr><td><a id="l4968"></a><a href="#l4968">4968</a><td>        }<tr><td><a id="l4969"></a><a href="#l4969">4969</a><td>      }<tr><td><a id="l4970"></a><a href="#l4970">4970</a><td>    }),<tr><td><a id="l4971"></a><a href="#l4971">4971</a><td><tr><td><a id="l4972"></a><a href="#l4972">4972</a><td>    indentLine: methodOp(function(n, dir, aggressive) {<tr><td><a id="l4973"></a><a href="#l4973">4973</a><td>      if (typeof dir != &quot;string&quot; &amp;&amp; typeof dir != &quot;number&quot;) {<tr><td><a id="l4974"></a><a href="#l4974">4974</a><td>        if (dir == null) dir = this.options.smartIndent ? &quot;smart&quot; : &quot;prev&quot;;<tr><td><a id="l4975"></a><a href="#l4975">4975</a><td>        else dir = dir ? &quot;add&quot; : &quot;subtract&quot;;<tr><td><a id="l4976"></a><a href="#l4976">4976</a><td>      }<tr><td><a id="l4977"></a><a href="#l4977">4977</a><td>      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);<tr><td><a id="l4978"></a><a href="#l4978">4978</a><td>    }),<tr><td><a id="l4979"></a><a href="#l4979">4979</a><td>    indentSelection: methodOp(function(how) {<tr><td><a id="l4980"></a><a href="#l4980">4980</a><td>      var ranges = this.doc.sel.ranges, end = -1;<tr><td><a id="l4981"></a><a href="#l4981">4981</a><td>      for (var i = 0; i &lt; ranges.length; i++) {<tr><td><a id="l4982"></a><a href="#l4982">4982</a><td>        var range = ranges[i];<tr><td><a id="l4983"></a><a href="#l4983">4983</a><td>        if (!range.empty()) {<tr><td><a id="l4984"></a><a href="#l4984">4984</a><td>          var from = range.from(), to = range.to();<tr><td><a id="l4985"></a><a href="#l4985">4985</a><td>          var start = Math.max(end, from.line);<tr><td><a id="l4986"></a><a href="#l4986">4986</a><td>          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;<tr><td><a id="l4987"></a><a href="#l4987">4987</a><td>          for (var j = start; j &lt; end; ++j)<tr><td><a id="l4988"></a><a href="#l4988">4988</a><td>            indentLine(this, j, how);<tr><td><a id="l4989"></a><a href="#l4989">4989</a><td>          var newRanges = this.doc.sel.ranges;<tr><td><a id="l4990"></a><a href="#l4990">4990</a><td>          if (from.ch == 0 &amp;&amp; ranges.length == newRanges.length &amp;&amp; newRanges[i].from().ch &gt; 0)<tr><td><a id="l4991"></a><a href="#l4991">4991</a><td>            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);<tr><td><a id="l4992"></a><a href="#l4992">4992</a><td>        } else if (range.head.line &gt; end) {<tr><td><a id="l4993"></a><a href="#l4993">4993</a><td>          indentLine(this, range.head.line, how, true);<tr><td><a id="l4994"></a><a href="#l4994">4994</a><td>          end = range.head.line;<tr><td><a id="l4995"></a><a href="#l4995">4995</a><td>          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);<tr><td><a id="l4996"></a><a href="#l4996">4996</a><td>        }<tr><td><a id="l4997"></a><a href="#l4997">4997</a><td>      }<tr><td><a id="l4998"></a><a href="#l4998">4998</a><td>    }),<tr><td><a id="l4999"></a><a href="#l4999">4999</a><td><tr><td><a id="l5000"></a><a href="#l5000">5000</a><td>    // Fetch the parser token for a given character. Useful for hacks<tr><td><a id="l5001"></a><a href="#l5001">5001</a><td>    // that want to inspect the mode state (say, for completion).<tr><td><a id="l5002"></a><a href="#l5002">5002</a><td>    getTokenAt: function(pos, precise) {<tr><td><a id="l5003"></a><a href="#l5003">5003</a><td>      return takeToken(this, pos, precise);<tr><td><a id="l5004"></a><a href="#l5004">5004</a><td>    },<tr><td><a id="l5005"></a><a href="#l5005">5005</a><td><tr><td><a id="l5006"></a><a href="#l5006">5006</a><td>    getLineTokens: function(line, precise) {<tr><td><a id="l5007"></a><a href="#l5007">5007</a><td>      return takeToken(this, Pos(line), precise, true);<tr><td><a id="l5008"></a><a href="#l5008">5008</a><td>    },<tr><td><a id="l5009"></a><a href="#l5009">5009</a><td><tr><td><a id="l5010"></a><a href="#l5010">5010</a><td>    getTokenTypeAt: function(pos) {<tr><td><a id="l5011"></a><a href="#l5011">5011</a><td>      pos = clipPos(this.doc, pos);<tr><td><a id="l5012"></a><a href="#l5012">5012</a><td>      var styles = getLineStyles(this, getLine(this.doc, pos.line));<tr><td><a id="l5013"></a><a href="#l5013">5013</a><td>      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;<tr><td><a id="l5014"></a><a href="#l5014">5014</a><td>      var type;<tr><td><a id="l5015"></a><a href="#l5015">5015</a><td>      if (ch == 0) type = styles[2];<tr><td><a id="l5016"></a><a href="#l5016">5016</a><td>      else for (;;) {<tr><td><a id="l5017"></a><a href="#l5017">5017</a><td>        var mid = (before + after) &gt;&gt; 1;<tr><td><a id="l5018"></a><a href="#l5018">5018</a><td>        if ((mid ? styles[mid * 2 - 1] : 0) &gt;= ch) after = mid;<tr><td><a id="l5019"></a><a href="#l5019">5019</a><td>        else if (styles[mid * 2 + 1] &lt; ch) before = mid + 1;<tr><td><a id="l5020"></a><a href="#l5020">5020</a><td>        else { type = styles[mid * 2 + 2]; break; }<tr><td><a id="l5021"></a><a href="#l5021">5021</a><td>      }<tr><td><a id="l5022"></a><a href="#l5022">5022</a><td>      var cut = type ? type.indexOf(&quot;cm-overlay &quot;) : -1;<tr><td><a id="l5023"></a><a href="#l5023">5023</a><td>      return cut &lt; 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);<tr><td><a id="l5024"></a><a href="#l5024">5024</a><td>    },<tr><td><a id="l5025"></a><a href="#l5025">5025</a><td><tr><td><a id="l5026"></a><a href="#l5026">5026</a><td>    getModeAt: function(pos) {<tr><td><a id="l5027"></a><a href="#l5027">5027</a><td>      var mode = this.doc.mode;<tr><td><a id="l5028"></a><a href="#l5028">5028</a><td>      if (!mode.innerMode) return mode;<tr><td><a id="l5029"></a><a href="#l5029">5029</a><td>      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;<tr><td><a id="l5030"></a><a href="#l5030">5030</a><td>    },<tr><td><a id="l5031"></a><a href="#l5031">5031</a><td><tr><td><a id="l5032"></a><a href="#l5032">5032</a><td>    getHelper: function(pos, type) {<tr><td><a id="l5033"></a><a href="#l5033">5033</a><td>      return this.getHelpers(pos, type)[0];<tr><td><a id="l5034"></a><a href="#l5034">5034</a><td>    },<tr><td><a id="l5035"></a><a href="#l5035">5035</a><td><tr><td><a id="l5036"></a><a href="#l5036">5036</a><td>    getHelpers: function(pos, type) {<tr><td><a id="l5037"></a><a href="#l5037">5037</a><td>      var found = [];<tr><td><a id="l5038"></a><a href="#l5038">5038</a><td>      if (!helpers.hasOwnProperty(type)) return found;<tr><td><a id="l5039"></a><a href="#l5039">5039</a><td>      var help = helpers[type], mode = this.getModeAt(pos);<tr><td><a id="l5040"></a><a href="#l5040">5040</a><td>      if (typeof mode[type] == &quot;string&quot;) {<tr><td><a id="l5041"></a><a href="#l5041">5041</a><td>        if (help[mode[type]]) found.push(help[mode[type]]);<tr><td><a id="l5042"></a><a href="#l5042">5042</a><td>      } else if (mode[type]) {<tr><td><a id="l5043"></a><a href="#l5043">5043</a><td>        for (var i = 0; i &lt; mode[type].length; i++) {<tr><td><a id="l5044"></a><a href="#l5044">5044</a><td>          var val = help[mode[type][i]];<tr><td><a id="l5045"></a><a href="#l5045">5045</a><td>          if (val) found.push(val);<tr><td><a id="l5046"></a><a href="#l5046">5046</a><td>        }<tr><td><a id="l5047"></a><a href="#l5047">5047</a><td>      } else if (mode.helperType &amp;&amp; help[mode.helperType]) {<tr><td><a id="l5048"></a><a href="#l5048">5048</a><td>        found.push(help[mode.helperType]);<tr><td><a id="l5049"></a><a href="#l5049">5049</a><td>      } else if (help[mode.name]) {<tr><td><a id="l5050"></a><a href="#l5050">5050</a><td>        found.push(help[mode.name]);<tr><td><a id="l5051"></a><a href="#l5051">5051</a><td>      }<tr><td><a id="l5052"></a><a href="#l5052">5052</a><td>      for (var i = 0; i &lt; help._global.length; i++) {<tr><td><a id="l5053"></a><a href="#l5053">5053</a><td>        var cur = help._global[i];<tr><td><a id="l5054"></a><a href="#l5054">5054</a><td>        if (cur.pred(mode, this) &amp;&amp; indexOf(found, cur.val) == -1)<tr><td><a id="l5055"></a><a href="#l5055">5055</a><td>          found.push(cur.val);<tr><td><a id="l5056"></a><a href="#l5056">5056</a><td>      }<tr><td><a id="l5057"></a><a href="#l5057">5057</a><td>      return found;<tr><td><a id="l5058"></a><a href="#l5058">5058</a><td>    },<tr><td><a id="l5059"></a><a href="#l5059">5059</a><td><tr><td><a id="l5060"></a><a href="#l5060">5060</a><td>    getStateAfter: function(line, precise) {<tr><td><a id="l5061"></a><a href="#l5061">5061</a><td>      var doc = this.doc;<tr><td><a id="l5062"></a><a href="#l5062">5062</a><td>      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);<tr><td><a id="l5063"></a><a href="#l5063">5063</a><td>      return getStateBefore(this, line + 1, precise);<tr><td><a id="l5064"></a><a href="#l5064">5064</a><td>    },<tr><td><a id="l5065"></a><a href="#l5065">5065</a><td><tr><td><a id="l5066"></a><a href="#l5066">5066</a><td>    cursorCoords: function(start, mode) {<tr><td><a id="l5067"></a><a href="#l5067">5067</a><td>      var pos, range = this.doc.sel.primary();<tr><td><a id="l5068"></a><a href="#l5068">5068</a><td>      if (start == null) pos = range.head;<tr><td><a id="l5069"></a><a href="#l5069">5069</a><td>      else if (typeof start == &quot;object&quot;) pos = clipPos(this.doc, start);<tr><td><a id="l5070"></a><a href="#l5070">5070</a><td>      else pos = start ? range.from() : range.to();<tr><td><a id="l5071"></a><a href="#l5071">5071</a><td>      return cursorCoords(this, pos, mode || &quot;page&quot;);<tr><td><a id="l5072"></a><a href="#l5072">5072</a><td>    },<tr><td><a id="l5073"></a><a href="#l5073">5073</a><td><tr><td><a id="l5074"></a><a href="#l5074">5074</a><td>    charCoords: function(pos, mode) {<tr><td><a id="l5075"></a><a href="#l5075">5075</a><td>      return charCoords(this, clipPos(this.doc, pos), mode || &quot;page&quot;);<tr><td><a id="l5076"></a><a href="#l5076">5076</a><td>    },<tr><td><a id="l5077"></a><a href="#l5077">5077</a><td><tr><td><a id="l5078"></a><a href="#l5078">5078</a><td>    coordsChar: function(coords, mode) {<tr><td><a id="l5079"></a><a href="#l5079">5079</a><td>      coords = fromCoordSystem(this, coords, mode || &quot;page&quot;);<tr><td><a id="l5080"></a><a href="#l5080">5080</a><td>      return coordsChar(this, coords.left, coords.top);<tr><td><a id="l5081"></a><a href="#l5081">5081</a><td>    },<tr><td><a id="l5082"></a><a href="#l5082">5082</a><td><tr><td><a id="l5083"></a><a href="#l5083">5083</a><td>    lineAtHeight: function(height, mode) {<tr><td><a id="l5084"></a><a href="#l5084">5084</a><td>      height = fromCoordSystem(this, {top: height, left: 0}, mode || &quot;page&quot;).top;<tr><td><a id="l5085"></a><a href="#l5085">5085</a><td>      return lineAtHeight(this.doc, height + this.display.viewOffset);<tr><td><a id="l5086"></a><a href="#l5086">5086</a><td>    },<tr><td><a id="l5087"></a><a href="#l5087">5087</a><td>    heightAtLine: function(line, mode) {<tr><td><a id="l5088"></a><a href="#l5088">5088</a><td>      var end = false, lineObj;<tr><td><a id="l5089"></a><a href="#l5089">5089</a><td>      if (typeof line == &quot;number&quot;) {<tr><td><a id="l5090"></a><a href="#l5090">5090</a><td>        var last = this.doc.first + this.doc.size - 1;<tr><td><a id="l5091"></a><a href="#l5091">5091</a><td>        if (line &lt; this.doc.first) line = this.doc.first;<tr><td><a id="l5092"></a><a href="#l5092">5092</a><td>        else if (line &gt; last) { line = last; end = true; }<tr><td><a id="l5093"></a><a href="#l5093">5093</a><td>        lineObj = getLine(this.doc, line);<tr><td><a id="l5094"></a><a href="#l5094">5094</a><td>      } else {<tr><td><a id="l5095"></a><a href="#l5095">5095</a><td>        lineObj = line;<tr><td><a id="l5096"></a><a href="#l5096">5096</a><td>      }<tr><td><a id="l5097"></a><a href="#l5097">5097</a><td>      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || &quot;page&quot;).top +<tr><td><a id="l5098"></a><a href="#l5098">5098</a><td>        (end ? this.doc.height - heightAtLine(lineObj) : 0);<tr><td><a id="l5099"></a><a href="#l5099">5099</a><td>    },<tr><td><a id="l5100"></a><a href="#l5100">5100</a><td><tr><td><a id="l5101"></a><a href="#l5101">5101</a><td>    defaultTextHeight: function() { return textHeight(this.display); },<tr><td><a id="l5102"></a><a href="#l5102">5102</a><td>    defaultCharWidth: function() { return charWidth(this.display); },<tr><td><a id="l5103"></a><a href="#l5103">5103</a><td><tr><td><a id="l5104"></a><a href="#l5104">5104</a><td>    setGutterMarker: methodOp(function(line, gutterID, value) {<tr><td><a id="l5105"></a><a href="#l5105">5105</a><td>      return changeLine(this.doc, line, &quot;gutter&quot;, function(line) {<tr><td><a id="l5106"></a><a href="#l5106">5106</a><td>        var markers = line.gutterMarkers || (line.gutterMarkers = {});<tr><td><a id="l5107"></a><a href="#l5107">5107</a><td>        markers[gutterID] = value;<tr><td><a id="l5108"></a><a href="#l5108">5108</a><td>        if (!value &amp;&amp; isEmpty(markers)) line.gutterMarkers = null;<tr><td><a id="l5109"></a><a href="#l5109">5109</a><td>        return true;<tr><td><a id="l5110"></a><a href="#l5110">5110</a><td>      });<tr><td><a id="l5111"></a><a href="#l5111">5111</a><td>    }),<tr><td><a id="l5112"></a><a href="#l5112">5112</a><td><tr><td><a id="l5113"></a><a href="#l5113">5113</a><td>    clearGutter: methodOp(function(gutterID) {<tr><td><a id="l5114"></a><a href="#l5114">5114</a><td>      var cm = this, doc = cm.doc, i = doc.first;<tr><td><a id="l5115"></a><a href="#l5115">5115</a><td>      doc.iter(function(line) {<tr><td><a id="l5116"></a><a href="#l5116">5116</a><td>        if (line.gutterMarkers &amp;&amp; line.gutterMarkers[gutterID]) {<tr><td><a id="l5117"></a><a href="#l5117">5117</a><td>          line.gutterMarkers[gutterID] = null;<tr><td><a id="l5118"></a><a href="#l5118">5118</a><td>          regLineChange(cm, i, &quot;gutter&quot;);<tr><td><a id="l5119"></a><a href="#l5119">5119</a><td>          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;<tr><td><a id="l5120"></a><a href="#l5120">5120</a><td>        }<tr><td><a id="l5121"></a><a href="#l5121">5121</a><td>        ++i;<tr><td><a id="l5122"></a><a href="#l5122">5122</a><td>      });<tr><td><a id="l5123"></a><a href="#l5123">5123</a><td>    }),<tr><td><a id="l5124"></a><a href="#l5124">5124</a><td><tr><td><a id="l5125"></a><a href="#l5125">5125</a><td>    lineInfo: function(line) {<tr><td><a id="l5126"></a><a href="#l5126">5126</a><td>      if (typeof line == &quot;number&quot;) {<tr><td><a id="l5127"></a><a href="#l5127">5127</a><td>        if (!isLine(this.doc, line)) return null;<tr><td><a id="l5128"></a><a href="#l5128">5128</a><td>        var n = line;<tr><td><a id="l5129"></a><a href="#l5129">5129</a><td>        line = getLine(this.doc, line);<tr><td><a id="l5130"></a><a href="#l5130">5130</a><td>        if (!line) return null;<tr><td><a id="l5131"></a><a href="#l5131">5131</a><td>      } else {<tr><td><a id="l5132"></a><a href="#l5132">5132</a><td>        var n = lineNo(line);<tr><td><a id="l5133"></a><a href="#l5133">5133</a><td>        if (n == null) return null;<tr><td><a id="l5134"></a><a href="#l5134">5134</a><td>      }<tr><td><a id="l5135"></a><a href="#l5135">5135</a><td>      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,<tr><td><a id="l5136"></a><a href="#l5136">5136</a><td>              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,<tr><td><a id="l5137"></a><a href="#l5137">5137</a><td>              widgets: line.widgets};<tr><td><a id="l5138"></a><a href="#l5138">5138</a><td>    },<tr><td><a id="l5139"></a><a href="#l5139">5139</a><td><tr><td><a id="l5140"></a><a href="#l5140">5140</a><td>    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},<tr><td><a id="l5141"></a><a href="#l5141">5141</a><td><tr><td><a id="l5142"></a><a href="#l5142">5142</a><td>    addWidget: function(pos, node, scroll, vert, horiz) {<tr><td><a id="l5143"></a><a href="#l5143">5143</a><td>      var display = this.display;<tr><td><a id="l5144"></a><a href="#l5144">5144</a><td>      pos = cursorCoords(this, clipPos(this.doc, pos));<tr><td><a id="l5145"></a><a href="#l5145">5145</a><td>      var top = pos.bottom, left = pos.left;<tr><td><a id="l5146"></a><a href="#l5146">5146</a><td>      node.style.position = &quot;absolute&quot;;<tr><td><a id="l5147"></a><a href="#l5147">5147</a><td>      node.setAttribute(&quot;cm-ignore-events&quot;, &quot;true&quot;);<tr><td><a id="l5148"></a><a href="#l5148">5148</a><td>      this.display.input.setUneditable(node);<tr><td><a id="l5149"></a><a href="#l5149">5149</a><td>      display.sizer.appendChild(node);<tr><td><a id="l5150"></a><a href="#l5150">5150</a><td>      if (vert == &quot;over&quot;) {<tr><td><a id="l5151"></a><a href="#l5151">5151</a><td>        top = pos.top;<tr><td><a id="l5152"></a><a href="#l5152">5152</a><td>      } else if (vert == &quot;above&quot; || vert == &quot;near&quot;) {<tr><td><a id="l5153"></a><a href="#l5153">5153</a><td>        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),<tr><td><a id="l5154"></a><a href="#l5154">5154</a><td>        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);<tr><td><a id="l5155"></a><a href="#l5155">5155</a><td>        // Default to positioning above (if specified and possible); otherwise default to positioning below<tr><td><a id="l5156"></a><a href="#l5156">5156</a><td>        if ((vert == &#39;above&#39; || pos.bottom + node.offsetHeight &gt; vspace) &amp;&amp; pos.top &gt; node.offsetHeight)<tr><td><a id="l5157"></a><a href="#l5157">5157</a><td>          top = pos.top - node.offsetHeight;<tr><td><a id="l5158"></a><a href="#l5158">5158</a><td>        else if (pos.bottom + node.offsetHeight &lt;= vspace)<tr><td><a id="l5159"></a><a href="#l5159">5159</a><td>          top = pos.bottom;<tr><td><a id="l5160"></a><a href="#l5160">5160</a><td>        if (left + node.offsetWidth &gt; hspace)<tr><td><a id="l5161"></a><a href="#l5161">5161</a><td>          left = hspace - node.offsetWidth;<tr><td><a id="l5162"></a><a href="#l5162">5162</a><td>      }<tr><td><a id="l5163"></a><a href="#l5163">5163</a><td>      node.style.top = top + &quot;px&quot;;<tr><td><a id="l5164"></a><a href="#l5164">5164</a><td>      node.style.left = node.style.right = &quot;&quot;;<tr><td><a id="l5165"></a><a href="#l5165">5165</a><td>      if (horiz == &quot;right&quot;) {<tr><td><a id="l5166"></a><a href="#l5166">5166</a><td>        left = display.sizer.clientWidth - node.offsetWidth;<tr><td><a id="l5167"></a><a href="#l5167">5167</a><td>        node.style.right = &quot;0px&quot;;<tr><td><a id="l5168"></a><a href="#l5168">5168</a><td>      } else {<tr><td><a id="l5169"></a><a href="#l5169">5169</a><td>        if (horiz == &quot;left&quot;) left = 0;<tr><td><a id="l5170"></a><a href="#l5170">5170</a><td>        else if (horiz == &quot;middle&quot;) left = (display.sizer.clientWidth - node.offsetWidth) / 2;<tr><td><a id="l5171"></a><a href="#l5171">5171</a><td>        node.style.left = left + &quot;px&quot;;<tr><td><a id="l5172"></a><a href="#l5172">5172</a><td>      }<tr><td><a id="l5173"></a><a href="#l5173">5173</a><td>      if (scroll)<tr><td><a id="l5174"></a><a href="#l5174">5174</a><td>        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);<tr><td><a id="l5175"></a><a href="#l5175">5175</a><td>    },<tr><td><a id="l5176"></a><a href="#l5176">5176</a><td><tr><td><a id="l5177"></a><a href="#l5177">5177</a><td>    triggerOnKeyDown: methodOp(onKeyDown),<tr><td><a id="l5178"></a><a href="#l5178">5178</a><td>    triggerOnKeyPress: methodOp(onKeyPress),<tr><td><a id="l5179"></a><a href="#l5179">5179</a><td>    triggerOnKeyUp: onKeyUp,<tr><td><a id="l5180"></a><a href="#l5180">5180</a><td><tr><td><a id="l5181"></a><a href="#l5181">5181</a><td>    execCommand: function(cmd) {<tr><td><a id="l5182"></a><a href="#l5182">5182</a><td>      if (commands.hasOwnProperty(cmd))<tr><td><a id="l5183"></a><a href="#l5183">5183</a><td>        return commands[cmd].call(null, this);<tr><td><a id="l5184"></a><a href="#l5184">5184</a><td>    },<tr><td><a id="l5185"></a><a href="#l5185">5185</a><td><tr><td><a id="l5186"></a><a href="#l5186">5186</a><td>    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),<tr><td><a id="l5187"></a><a href="#l5187">5187</a><td><tr><td><a id="l5188"></a><a href="#l5188">5188</a><td>    findPosH: function(from, amount, unit, visually) {<tr><td><a id="l5189"></a><a href="#l5189">5189</a><td>      var dir = 1;<tr><td><a id="l5190"></a><a href="#l5190">5190</a><td>      if (amount &lt; 0) { dir = -1; amount = -amount; }<tr><td><a id="l5191"></a><a href="#l5191">5191</a><td>      for (var i = 0, cur = clipPos(this.doc, from); i &lt; amount; ++i) {<tr><td><a id="l5192"></a><a href="#l5192">5192</a><td>        cur = findPosH(this.doc, cur, dir, unit, visually);<tr><td><a id="l5193"></a><a href="#l5193">5193</a><td>        if (cur.hitSide) break;<tr><td><a id="l5194"></a><a href="#l5194">5194</a><td>      }<tr><td><a id="l5195"></a><a href="#l5195">5195</a><td>      return cur;<tr><td><a id="l5196"></a><a href="#l5196">5196</a><td>    },<tr><td><a id="l5197"></a><a href="#l5197">5197</a><td><tr><td><a id="l5198"></a><a href="#l5198">5198</a><td>    moveH: methodOp(function(dir, unit) {<tr><td><a id="l5199"></a><a href="#l5199">5199</a><td>      var cm = this;<tr><td><a id="l5200"></a><a href="#l5200">5200</a><td>      cm.extendSelectionsBy(function(range) {<tr><td><a id="l5201"></a><a href="#l5201">5201</a><td>        if (cm.display.shift || cm.doc.extend || range.empty())<tr><td><a id="l5202"></a><a href="#l5202">5202</a><td>          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);<tr><td><a id="l5203"></a><a href="#l5203">5203</a><td>        else<tr><td><a id="l5204"></a><a href="#l5204">5204</a><td>          return dir &lt; 0 ? range.from() : range.to();<tr><td><a id="l5205"></a><a href="#l5205">5205</a><td>      }, sel_move);<tr><td><a id="l5206"></a><a href="#l5206">5206</a><td>    }),<tr><td><a id="l5207"></a><a href="#l5207">5207</a><td><tr><td><a id="l5208"></a><a href="#l5208">5208</a><td>    deleteH: methodOp(function(dir, unit) {<tr><td><a id="l5209"></a><a href="#l5209">5209</a><td>      var sel = this.doc.sel, doc = this.doc;<tr><td><a id="l5210"></a><a href="#l5210">5210</a><td>      if (sel.somethingSelected())<tr><td><a id="l5211"></a><a href="#l5211">5211</a><td>        doc.replaceSelection(&quot;&quot;, null, &quot;+delete&quot;);<tr><td><a id="l5212"></a><a href="#l5212">5212</a><td>      else<tr><td><a id="l5213"></a><a href="#l5213">5213</a><td>        deleteNearSelection(this, function(range) {<tr><td><a id="l5214"></a><a href="#l5214">5214</a><td>          var other = findPosH(doc, range.head, dir, unit, false);<tr><td><a id="l5215"></a><a href="#l5215">5215</a><td>          return dir &lt; 0 ? {from: other, to: range.head} : {from: range.head, to: other};<tr><td><a id="l5216"></a><a href="#l5216">5216</a><td>        });<tr><td><a id="l5217"></a><a href="#l5217">5217</a><td>    }),<tr><td><a id="l5218"></a><a href="#l5218">5218</a><td><tr><td><a id="l5219"></a><a href="#l5219">5219</a><td>    findPosV: function(from, amount, unit, goalColumn) {<tr><td><a id="l5220"></a><a href="#l5220">5220</a><td>      var dir = 1, x = goalColumn;<tr><td><a id="l5221"></a><a href="#l5221">5221</a><td>      if (amount &lt; 0) { dir = -1; amount = -amount; }<tr><td><a id="l5222"></a><a href="#l5222">5222</a><td>      for (var i = 0, cur = clipPos(this.doc, from); i &lt; amount; ++i) {<tr><td><a id="l5223"></a><a href="#l5223">5223</a><td>        var coords = cursorCoords(this, cur, &quot;div&quot;);<tr><td><a id="l5224"></a><a href="#l5224">5224</a><td>        if (x == null) x = coords.left;<tr><td><a id="l5225"></a><a href="#l5225">5225</a><td>        else coords.left = x;<tr><td><a id="l5226"></a><a href="#l5226">5226</a><td>        cur = findPosV(this, coords, dir, unit);<tr><td><a id="l5227"></a><a href="#l5227">5227</a><td>        if (cur.hitSide) break;<tr><td><a id="l5228"></a><a href="#l5228">5228</a><td>      }<tr><td><a id="l5229"></a><a href="#l5229">5229</a><td>      return cur;<tr><td><a id="l5230"></a><a href="#l5230">5230</a><td>    },<tr><td><a id="l5231"></a><a href="#l5231">5231</a><td><tr><td><a id="l5232"></a><a href="#l5232">5232</a><td>    moveV: methodOp(function(dir, unit) {<tr><td><a id="l5233"></a><a href="#l5233">5233</a><td>      var cm = this, doc = this.doc, goals = [];<tr><td><a id="l5234"></a><a href="#l5234">5234</a><td>      var collapse = !cm.display.shift &amp;&amp; !doc.extend &amp;&amp; doc.sel.somethingSelected();<tr><td><a id="l5235"></a><a href="#l5235">5235</a><td>      doc.extendSelectionsBy(function(range) {<tr><td><a id="l5236"></a><a href="#l5236">5236</a><td>        if (collapse)<tr><td><a id="l5237"></a><a href="#l5237">5237</a><td>          return dir &lt; 0 ? range.from() : range.to();<tr><td><a id="l5238"></a><a href="#l5238">5238</a><td>        var headPos = cursorCoords(cm, range.head, &quot;div&quot;);<tr><td><a id="l5239"></a><a href="#l5239">5239</a><td>        if (range.goalColumn != null) headPos.left = range.goalColumn;<tr><td><a id="l5240"></a><a href="#l5240">5240</a><td>        goals.push(headPos.left);<tr><td><a id="l5241"></a><a href="#l5241">5241</a><td>        var pos = findPosV(cm, headPos, dir, unit);<tr><td><a id="l5242"></a><a href="#l5242">5242</a><td>        if (unit == &quot;page&quot; &amp;&amp; range == doc.sel.primary())<tr><td><a id="l5243"></a><a href="#l5243">5243</a><td>          addToScrollPos(cm, null, charCoords(cm, pos, &quot;div&quot;).top - headPos.top);<tr><td><a id="l5244"></a><a href="#l5244">5244</a><td>        return pos;<tr><td><a id="l5245"></a><a href="#l5245">5245</a><td>      }, sel_move);<tr><td><a id="l5246"></a><a href="#l5246">5246</a><td>      if (goals.length) for (var i = 0; i &lt; doc.sel.ranges.length; i++)<tr><td><a id="l5247"></a><a href="#l5247">5247</a><td>        doc.sel.ranges[i].goalColumn = goals[i];<tr><td><a id="l5248"></a><a href="#l5248">5248</a><td>    }),<tr><td><a id="l5249"></a><a href="#l5249">5249</a><td><tr><td><a id="l5250"></a><a href="#l5250">5250</a><td>    // Find the word at the given position (as returned by coordsChar).<tr><td><a id="l5251"></a><a href="#l5251">5251</a><td>    findWordAt: function(pos) {<tr><td><a id="l5252"></a><a href="#l5252">5252</a><td>      var doc = this.doc, line = getLine(doc, pos.line).text;<tr><td><a id="l5253"></a><a href="#l5253">5253</a><td>      var start = pos.ch, end = pos.ch;<tr><td><a id="l5254"></a><a href="#l5254">5254</a><td>      if (line) {<tr><td><a id="l5255"></a><a href="#l5255">5255</a><td>        var helper = this.getHelper(pos, &quot;wordChars&quot;);<tr><td><a id="l5256"></a><a href="#l5256">5256</a><td>        if ((pos.xRel &lt; 0 || end == line.length) &amp;&amp; start) --start; else ++end;<tr><td><a id="l5257"></a><a href="#l5257">5257</a><td>        var startChar = line.charAt(start);<tr><td><a id="l5258"></a><a href="#l5258">5258</a><td>        var check = isWordChar(startChar, helper)<tr><td><a id="l5259"></a><a href="#l5259">5259</a><td>          ? function(ch) { return isWordChar(ch, helper); }<tr><td><a id="l5260"></a><a href="#l5260">5260</a><td>          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}<tr><td><a id="l5261"></a><a href="#l5261">5261</a><td>          : function(ch) {return !/\s/.test(ch) &amp;&amp; !isWordChar(ch);};<tr><td><a id="l5262"></a><a href="#l5262">5262</a><td>        while (start &gt; 0 &amp;&amp; check(line.charAt(start - 1))) --start;<tr><td><a id="l5263"></a><a href="#l5263">5263</a><td>        while (end &lt; line.length &amp;&amp; check(line.charAt(end))) ++end;<tr><td><a id="l5264"></a><a href="#l5264">5264</a><td>      }<tr><td><a id="l5265"></a><a href="#l5265">5265</a><td>      return new Range(Pos(pos.line, start), Pos(pos.line, end));<tr><td><a id="l5266"></a><a href="#l5266">5266</a><td>    },<tr><td><a id="l5267"></a><a href="#l5267">5267</a><td><tr><td><a id="l5268"></a><a href="#l5268">5268</a><td>    toggleOverwrite: function(value) {<tr><td><a id="l5269"></a><a href="#l5269">5269</a><td>      if (value != null &amp;&amp; value == this.state.overwrite) return;<tr><td><a id="l5270"></a><a href="#l5270">5270</a><td>      if (this.state.overwrite = !this.state.overwrite)<tr><td><a id="l5271"></a><a href="#l5271">5271</a><td>        addClass(this.display.cursorDiv, &quot;CodeMirror-overwrite&quot;);<tr><td><a id="l5272"></a><a href="#l5272">5272</a><td>      else<tr><td><a id="l5273"></a><a href="#l5273">5273</a><td>        rmClass(this.display.cursorDiv, &quot;CodeMirror-overwrite&quot;);<tr><td><a id="l5274"></a><a href="#l5274">5274</a><td><tr><td><a id="l5275"></a><a href="#l5275">5275</a><td>      signal(this, &quot;overwriteToggle&quot;, this, this.state.overwrite);<tr><td><a id="l5276"></a><a href="#l5276">5276</a><td>    },<tr><td><a id="l5277"></a><a href="#l5277">5277</a><td>    hasFocus: function() { return this.display.input.getField() == activeElt(); },<tr><td><a id="l5278"></a><a href="#l5278">5278</a><td>    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },<tr><td><a id="l5279"></a><a href="#l5279">5279</a><td><tr><td><a id="l5280"></a><a href="#l5280">5280</a><td>    scrollTo: methodOp(function(x, y) {<tr><td><a id="l5281"></a><a href="#l5281">5281</a><td>      if (x != null || y != null) resolveScrollToPos(this);<tr><td><a id="l5282"></a><a href="#l5282">5282</a><td>      if (x != null) this.curOp.scrollLeft = x;<tr><td><a id="l5283"></a><a href="#l5283">5283</a><td>      if (y != null) this.curOp.scrollTop = y;<tr><td><a id="l5284"></a><a href="#l5284">5284</a><td>    }),<tr><td><a id="l5285"></a><a href="#l5285">5285</a><td>    getScrollInfo: function() {<tr><td><a id="l5286"></a><a href="#l5286">5286</a><td>      var scroller = this.display.scroller;<tr><td><a id="l5287"></a><a href="#l5287">5287</a><td>      return {left: scroller.scrollLeft, top: scroller.scrollTop,<tr><td><a id="l5288"></a><a href="#l5288">5288</a><td>              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,<tr><td><a id="l5289"></a><a href="#l5289">5289</a><td>              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,<tr><td><a id="l5290"></a><a href="#l5290">5290</a><td>              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};<tr><td><a id="l5291"></a><a href="#l5291">5291</a><td>    },<tr><td><a id="l5292"></a><a href="#l5292">5292</a><td><tr><td><a id="l5293"></a><a href="#l5293">5293</a><td>    scrollIntoView: methodOp(function(range, margin) {<tr><td><a id="l5294"></a><a href="#l5294">5294</a><td>      if (range == null) {<tr><td><a id="l5295"></a><a href="#l5295">5295</a><td>        range = {from: this.doc.sel.primary().head, to: null};<tr><td><a id="l5296"></a><a href="#l5296">5296</a><td>        if (margin == null) margin = this.options.cursorScrollMargin;<tr><td><a id="l5297"></a><a href="#l5297">5297</a><td>      } else if (typeof range == &quot;number&quot;) {<tr><td><a id="l5298"></a><a href="#l5298">5298</a><td>        range = {from: Pos(range, 0), to: null};<tr><td><a id="l5299"></a><a href="#l5299">5299</a><td>      } else if (range.from == null) {<tr><td><a id="l5300"></a><a href="#l5300">5300</a><td>        range = {from: range, to: null};<tr><td><a id="l5301"></a><a href="#l5301">5301</a><td>      }<tr><td><a id="l5302"></a><a href="#l5302">5302</a><td>      if (!range.to) range.to = range.from;<tr><td><a id="l5303"></a><a href="#l5303">5303</a><td>      range.margin = margin || 0;<tr><td><a id="l5304"></a><a href="#l5304">5304</a><td><tr><td><a id="l5305"></a><a href="#l5305">5305</a><td>      if (range.from.line != null) {<tr><td><a id="l5306"></a><a href="#l5306">5306</a><td>        resolveScrollToPos(this);<tr><td><a id="l5307"></a><a href="#l5307">5307</a><td>        this.curOp.scrollToPos = range;<tr><td><a id="l5308"></a><a href="#l5308">5308</a><td>      } else {<tr><td><a id="l5309"></a><a href="#l5309">5309</a><td>        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),<tr><td><a id="l5310"></a><a href="#l5310">5310</a><td>                                      Math.min(range.from.top, range.to.top) - range.margin,<tr><td><a id="l5311"></a><a href="#l5311">5311</a><td>                                      Math.max(range.from.right, range.to.right),<tr><td><a id="l5312"></a><a href="#l5312">5312</a><td>                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);<tr><td><a id="l5313"></a><a href="#l5313">5313</a><td>        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);<tr><td><a id="l5314"></a><a href="#l5314">5314</a><td>      }<tr><td><a id="l5315"></a><a href="#l5315">5315</a><td>    }),<tr><td><a id="l5316"></a><a href="#l5316">5316</a><td><tr><td><a id="l5317"></a><a href="#l5317">5317</a><td>    setSize: methodOp(function(width, height) {<tr><td><a id="l5318"></a><a href="#l5318">5318</a><td>      var cm = this;<tr><td><a id="l5319"></a><a href="#l5319">5319</a><td>      function interpret(val) {<tr><td><a id="l5320"></a><a href="#l5320">5320</a><td>        return typeof val == &quot;number&quot; || /^\d+$/.test(String(val)) ? val + &quot;px&quot; : val;<tr><td><a id="l5321"></a><a href="#l5321">5321</a><td>      }<tr><td><a id="l5322"></a><a href="#l5322">5322</a><td>      if (width != null) cm.display.wrapper.style.width = interpret(width);<tr><td><a id="l5323"></a><a href="#l5323">5323</a><td>      if (height != null) cm.display.wrapper.style.height = interpret(height);<tr><td><a id="l5324"></a><a href="#l5324">5324</a><td>      if (cm.options.lineWrapping) clearLineMeasurementCache(this);<tr><td><a id="l5325"></a><a href="#l5325">5325</a><td>      var lineNo = cm.display.viewFrom;<tr><td><a id="l5326"></a><a href="#l5326">5326</a><td>      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {<tr><td><a id="l5327"></a><a href="#l5327">5327</a><td>        if (line.widgets) for (var i = 0; i &lt; line.widgets.length; i++)<tr><td><a id="l5328"></a><a href="#l5328">5328</a><td>          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, &quot;widget&quot;); break; }<tr><td><a id="l5329"></a><a href="#l5329">5329</a><td>        ++lineNo;<tr><td><a id="l5330"></a><a href="#l5330">5330</a><td>      });<tr><td><a id="l5331"></a><a href="#l5331">5331</a><td>      cm.curOp.forceUpdate = true;<tr><td><a id="l5332"></a><a href="#l5332">5332</a><td>      signal(cm, &quot;refresh&quot;, this);<tr><td><a id="l5333"></a><a href="#l5333">5333</a><td>    }),<tr><td><a id="l5334"></a><a href="#l5334">5334</a><td><tr><td><a id="l5335"></a><a href="#l5335">5335</a><td>    operation: function(f){return runInOp(this, f);},<tr><td><a id="l5336"></a><a href="#l5336">5336</a><td><tr><td><a id="l5337"></a><a href="#l5337">5337</a><td>    refresh: methodOp(function() {<tr><td><a id="l5338"></a><a href="#l5338">5338</a><td>      var oldHeight = this.display.cachedTextHeight;<tr><td><a id="l5339"></a><a href="#l5339">5339</a><td>      regChange(this);<tr><td><a id="l5340"></a><a href="#l5340">5340</a><td>      this.curOp.forceUpdate = true;<tr><td><a id="l5341"></a><a href="#l5341">5341</a><td>      clearCaches(this);<tr><td><a id="l5342"></a><a href="#l5342">5342</a><td>      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);<tr><td><a id="l5343"></a><a href="#l5343">5343</a><td>      updateGutterSpace(this);<tr><td><a id="l5344"></a><a href="#l5344">5344</a><td>      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) &gt; .5)<tr><td><a id="l5345"></a><a href="#l5345">5345</a><td>        estimateLineHeights(this);<tr><td><a id="l5346"></a><a href="#l5346">5346</a><td>      signal(this, &quot;refresh&quot;, this);<tr><td><a id="l5347"></a><a href="#l5347">5347</a><td>    }),<tr><td><a id="l5348"></a><a href="#l5348">5348</a><td><tr><td><a id="l5349"></a><a href="#l5349">5349</a><td>    swapDoc: methodOp(function(doc) {<tr><td><a id="l5350"></a><a href="#l5350">5350</a><td>      var old = this.doc;<tr><td><a id="l5351"></a><a href="#l5351">5351</a><td>      old.cm = null;<tr><td><a id="l5352"></a><a href="#l5352">5352</a><td>      attachDoc(this, doc);<tr><td><a id="l5353"></a><a href="#l5353">5353</a><td>      clearCaches(this);<tr><td><a id="l5354"></a><a href="#l5354">5354</a><td>      this.display.input.reset();<tr><td><a id="l5355"></a><a href="#l5355">5355</a><td>      this.scrollTo(doc.scrollLeft, doc.scrollTop);<tr><td><a id="l5356"></a><a href="#l5356">5356</a><td>      this.curOp.forceScroll = true;<tr><td><a id="l5357"></a><a href="#l5357">5357</a><td>      signalLater(this, &quot;swapDoc&quot;, this, old);<tr><td><a id="l5358"></a><a href="#l5358">5358</a><td>      return old;<tr><td><a id="l5359"></a><a href="#l5359">5359</a><td>    }),<tr><td><a id="l5360"></a><a href="#l5360">5360</a><td><tr><td><a id="l5361"></a><a href="#l5361">5361</a><td>    getInputField: function(){return this.display.input.getField();},<tr><td><a id="l5362"></a><a href="#l5362">5362</a><td>    getWrapperElement: function(){return this.display.wrapper;},<tr><td><a id="l5363"></a><a href="#l5363">5363</a><td>    getScrollerElement: function(){return this.display.scroller;},<tr><td><a id="l5364"></a><a href="#l5364">5364</a><td>    getGutterElement: function(){return this.display.gutters;}<tr><td><a id="l5365"></a><a href="#l5365">5365</a><td>  };<tr><td><a id="l5366"></a><a href="#l5366">5366</a><td>  eventMixin(CodeMirror);<tr><td><a id="l5367"></a><a href="#l5367">5367</a><td><tr><td><a id="l5368"></a><a href="#l5368">5368</a><td>  // OPTION DEFAULTS<tr><td><a id="l5369"></a><a href="#l5369">5369</a><td><tr><td><a id="l5370"></a><a href="#l5370">5370</a><td>  // The default configuration options.<tr><td><a id="l5371"></a><a href="#l5371">5371</a><td>  var defaults = CodeMirror.defaults = {};<tr><td><a id="l5372"></a><a href="#l5372">5372</a><td>  // Functions to run when options are changed.<tr><td><a id="l5373"></a><a href="#l5373">5373</a><td>  var optionHandlers = CodeMirror.optionHandlers = {};<tr><td><a id="l5374"></a><a href="#l5374">5374</a><td><tr><td><a id="l5375"></a><a href="#l5375">5375</a><td>  function option(name, deflt, handle, notOnInit) {<tr><td><a id="l5376"></a><a href="#l5376">5376</a><td>    CodeMirror.defaults[name] = deflt;<tr><td><a id="l5377"></a><a href="#l5377">5377</a><td>    if (handle) optionHandlers[name] =<tr><td><a id="l5378"></a><a href="#l5378">5378</a><td>      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;<tr><td><a id="l5379"></a><a href="#l5379">5379</a><td>  }<tr><td><a id="l5380"></a><a href="#l5380">5380</a><td><tr><td><a id="l5381"></a><a href="#l5381">5381</a><td>  // Passed to option handlers when there is no old value.<tr><td><a id="l5382"></a><a href="#l5382">5382</a><td>  var Init = CodeMirror.Init = {toString: function(){return &quot;CodeMirror.Init&quot;;}};<tr><td><a id="l5383"></a><a href="#l5383">5383</a><td><tr><td><a id="l5384"></a><a href="#l5384">5384</a><td>  // These two are, on init, called from the constructor because they<tr><td><a id="l5385"></a><a href="#l5385">5385</a><td>  // have to be initialized before the editor can start at all.<tr><td><a id="l5386"></a><a href="#l5386">5386</a><td>  option(&quot;value&quot;, &quot;&quot;, function(cm, val) {<tr><td><a id="l5387"></a><a href="#l5387">5387</a><td>    cm.setValue(val);<tr><td><a id="l5388"></a><a href="#l5388">5388</a><td>  }, true);<tr><td><a id="l5389"></a><a href="#l5389">5389</a><td>  option(&quot;mode&quot;, null, function(cm, val) {<tr><td><a id="l5390"></a><a href="#l5390">5390</a><td>    cm.doc.modeOption = val;<tr><td><a id="l5391"></a><a href="#l5391">5391</a><td>    loadMode(cm);<tr><td><a id="l5392"></a><a href="#l5392">5392</a><td>  }, true);<tr><td><a id="l5393"></a><a href="#l5393">5393</a><td><tr><td><a id="l5394"></a><a href="#l5394">5394</a><td>  option(&quot;indentUnit&quot;, 2, loadMode, true);<tr><td><a id="l5395"></a><a href="#l5395">5395</a><td>  option(&quot;indentWithTabs&quot;, false);<tr><td><a id="l5396"></a><a href="#l5396">5396</a><td>  option(&quot;smartIndent&quot;, true);<tr><td><a id="l5397"></a><a href="#l5397">5397</a><td>  option(&quot;tabSize&quot;, 4, function(cm) {<tr><td><a id="l5398"></a><a href="#l5398">5398</a><td>    resetModeState(cm);<tr><td><a id="l5399"></a><a href="#l5399">5399</a><td>    clearCaches(cm);<tr><td><a id="l5400"></a><a href="#l5400">5400</a><td>    regChange(cm);<tr><td><a id="l5401"></a><a href="#l5401">5401</a><td>  }, true);<tr><td><a id="l5402"></a><a href="#l5402">5402</a><td>  option(&quot;lineSeparator&quot;, null, function(cm, val) {<tr><td><a id="l5403"></a><a href="#l5403">5403</a><td>    cm.doc.lineSep = val;<tr><td><a id="l5404"></a><a href="#l5404">5404</a><td>    if (!val) return;<tr><td><a id="l5405"></a><a href="#l5405">5405</a><td>    var newBreaks = [], lineNo = cm.doc.first;<tr><td><a id="l5406"></a><a href="#l5406">5406</a><td>    cm.doc.iter(function(line) {<tr><td><a id="l5407"></a><a href="#l5407">5407</a><td>      for (var pos = 0;;) {<tr><td><a id="l5408"></a><a href="#l5408">5408</a><td>        var found = line.text.indexOf(val, pos);<tr><td><a id="l5409"></a><a href="#l5409">5409</a><td>        if (found == -1) break;<tr><td><a id="l5410"></a><a href="#l5410">5410</a><td>        pos = found + val.length;<tr><td><a id="l5411"></a><a href="#l5411">5411</a><td>        newBreaks.push(Pos(lineNo, found));<tr><td><a id="l5412"></a><a href="#l5412">5412</a><td>      }<tr><td><a id="l5413"></a><a href="#l5413">5413</a><td>      lineNo++;<tr><td><a id="l5414"></a><a href="#l5414">5414</a><td>    });<tr><td><a id="l5415"></a><a href="#l5415">5415</a><td>    for (var i = newBreaks.length - 1; i &gt;= 0; i--)<tr><td><a id="l5416"></a><a href="#l5416">5416</a><td>      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))<tr><td><a id="l5417"></a><a href="#l5417">5417</a><td>  });<tr><td><a id="l5418"></a><a href="#l5418">5418</a><td>  option(&quot;specialChars&quot;, /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {<tr><td><a id="l5419"></a><a href="#l5419">5419</a><td>    cm.state.specialChars = new RegExp(val.source + (val.test(&quot;\t&quot;) ? &quot;&quot; : &quot;|\t&quot;), &quot;g&quot;);<tr><td><a id="l5420"></a><a href="#l5420">5420</a><td>    if (old != CodeMirror.Init) cm.refresh();<tr><td><a id="l5421"></a><a href="#l5421">5421</a><td>  });<tr><td><a id="l5422"></a><a href="#l5422">5422</a><td>  option(&quot;specialCharPlaceholder&quot;, defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);<tr><td><a id="l5423"></a><a href="#l5423">5423</a><td>  option(&quot;electricChars&quot;, true);<tr><td><a id="l5424"></a><a href="#l5424">5424</a><td>  option(&quot;inputStyle&quot;, mobile ? &quot;contenteditable&quot; : &quot;textarea&quot;, function() {<tr><td><a id="l5425"></a><a href="#l5425">5425</a><td>    throw new Error(&quot;inputStyle can not (yet) be changed in a running editor&quot;); // FIXME<tr><td><a id="l5426"></a><a href="#l5426">5426</a><td>  }, true);<tr><td><a id="l5427"></a><a href="#l5427">5427</a><td>  option(&quot;rtlMoveVisually&quot;, !windows);<tr><td><a id="l5428"></a><a href="#l5428">5428</a><td>  option(&quot;wholeLineUpdateBefore&quot;, true);<tr><td><a id="l5429"></a><a href="#l5429">5429</a><td><tr><td><a id="l5430"></a><a href="#l5430">5430</a><td>  option(&quot;theme&quot;, &quot;default&quot;, function(cm) {<tr><td><a id="l5431"></a><a href="#l5431">5431</a><td>    themeChanged(cm);<tr><td><a id="l5432"></a><a href="#l5432">5432</a><td>    guttersChanged(cm);<tr><td><a id="l5433"></a><a href="#l5433">5433</a><td>  }, true);<tr><td><a id="l5434"></a><a href="#l5434">5434</a><td>  option(&quot;keyMap&quot;, &quot;default&quot;, function(cm, val, old) {<tr><td><a id="l5435"></a><a href="#l5435">5435</a><td>    var next = getKeyMap(val);<tr><td><a id="l5436"></a><a href="#l5436">5436</a><td>    var prev = old != CodeMirror.Init &amp;&amp; getKeyMap(old);<tr><td><a id="l5437"></a><a href="#l5437">5437</a><td>    if (prev &amp;&amp; prev.detach) prev.detach(cm, next);<tr><td><a id="l5438"></a><a href="#l5438">5438</a><td>    if (next.attach) next.attach(cm, prev || null);<tr><td><a id="l5439"></a><a href="#l5439">5439</a><td>  });<tr><td><a id="l5440"></a><a href="#l5440">5440</a><td>  option(&quot;extraKeys&quot;, null);<tr><td><a id="l5441"></a><a href="#l5441">5441</a><td><tr><td><a id="l5442"></a><a href="#l5442">5442</a><td>  option(&quot;lineWrapping&quot;, false, wrappingChanged, true);<tr><td><a id="l5443"></a><a href="#l5443">5443</a><td>  option(&quot;gutters&quot;, [], function(cm) {<tr><td><a id="l5444"></a><a href="#l5444">5444</a><td>    setGuttersForLineNumbers(cm.options);<tr><td><a id="l5445"></a><a href="#l5445">5445</a><td>    guttersChanged(cm);<tr><td><a id="l5446"></a><a href="#l5446">5446</a><td>  }, true);<tr><td><a id="l5447"></a><a href="#l5447">5447</a><td>  option(&quot;fixedGutter&quot;, true, function(cm, val) {<tr><td><a id="l5448"></a><a href="#l5448">5448</a><td>    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + &quot;px&quot; : &quot;0&quot;;<tr><td><a id="l5449"></a><a href="#l5449">5449</a><td>    cm.refresh();<tr><td><a id="l5450"></a><a href="#l5450">5450</a><td>  }, true);<tr><td><a id="l5451"></a><a href="#l5451">5451</a><td>  option(&quot;coverGutterNextToScrollbar&quot;, false, function(cm) {updateScrollbars(cm);}, true);<tr><td><a id="l5452"></a><a href="#l5452">5452</a><td>  option(&quot;scrollbarStyle&quot;, &quot;native&quot;, function(cm) {<tr><td><a id="l5453"></a><a href="#l5453">5453</a><td>    initScrollbars(cm);<tr><td><a id="l5454"></a><a href="#l5454">5454</a><td>    updateScrollbars(cm);<tr><td><a id="l5455"></a><a href="#l5455">5455</a><td>    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);<tr><td><a id="l5456"></a><a href="#l5456">5456</a><td>    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);<tr><td><a id="l5457"></a><a href="#l5457">5457</a><td>  }, true);<tr><td><a id="l5458"></a><a href="#l5458">5458</a><td>  option(&quot;lineNumbers&quot;, false, function(cm) {<tr><td><a id="l5459"></a><a href="#l5459">5459</a><td>    setGuttersForLineNumbers(cm.options);<tr><td><a id="l5460"></a><a href="#l5460">5460</a><td>    guttersChanged(cm);<tr><td><a id="l5461"></a><a href="#l5461">5461</a><td>  }, true);<tr><td><a id="l5462"></a><a href="#l5462">5462</a><td>  option(&quot;firstLineNumber&quot;, 1, guttersChanged, true);<tr><td><a id="l5463"></a><a href="#l5463">5463</a><td>  option(&quot;lineNumberFormatter&quot;, function(integer) {return integer;}, guttersChanged, true);<tr><td><a id="l5464"></a><a href="#l5464">5464</a><td>  option(&quot;showCursorWhenSelecting&quot;, false, updateSelection, true);<tr><td><a id="l5465"></a><a href="#l5465">5465</a><td><tr><td><a id="l5466"></a><a href="#l5466">5466</a><td>  option(&quot;resetSelectionOnContextMenu&quot;, true);<tr><td><a id="l5467"></a><a href="#l5467">5467</a><td>  option(&quot;lineWiseCopyCut&quot;, true);<tr><td><a id="l5468"></a><a href="#l5468">5468</a><td><tr><td><a id="l5469"></a><a href="#l5469">5469</a><td>  option(&quot;readOnly&quot;, false, function(cm, val) {<tr><td><a id="l5470"></a><a href="#l5470">5470</a><td>    if (val == &quot;nocursor&quot;) {<tr><td><a id="l5471"></a><a href="#l5471">5471</a><td>      onBlur(cm);<tr><td><a id="l5472"></a><a href="#l5472">5472</a><td>      cm.display.input.blur();<tr><td><a id="l5473"></a><a href="#l5473">5473</a><td>      cm.display.disabled = true;<tr><td><a id="l5474"></a><a href="#l5474">5474</a><td>    } else {<tr><td><a id="l5475"></a><a href="#l5475">5475</a><td>      cm.display.disabled = false;<tr><td><a id="l5476"></a><a href="#l5476">5476</a><td>    }<tr><td><a id="l5477"></a><a href="#l5477">5477</a><td>    cm.display.input.readOnlyChanged(val)<tr><td><a id="l5478"></a><a href="#l5478">5478</a><td>  });<tr><td><a id="l5479"></a><a href="#l5479">5479</a><td>  option(&quot;disableInput&quot;, false, function(cm, val) {if (!val) cm.display.input.reset();}, true);<tr><td><a id="l5480"></a><a href="#l5480">5480</a><td>  option(&quot;dragDrop&quot;, true, dragDropChanged);<tr><td><a id="l5481"></a><a href="#l5481">5481</a><td>  option(&quot;allowDropFileTypes&quot;, null);<tr><td><a id="l5482"></a><a href="#l5482">5482</a><td><tr><td><a id="l5483"></a><a href="#l5483">5483</a><td>  option(&quot;cursorBlinkRate&quot;, 530);<tr><td><a id="l5484"></a><a href="#l5484">5484</a><td>  option(&quot;cursorScrollMargin&quot;, 0);<tr><td><a id="l5485"></a><a href="#l5485">5485</a><td>  option(&quot;cursorHeight&quot;, 1, updateSelection, true);<tr><td><a id="l5486"></a><a href="#l5486">5486</a><td>  option(&quot;singleCursorHeightPerLine&quot;, true, updateSelection, true);<tr><td><a id="l5487"></a><a href="#l5487">5487</a><td>  option(&quot;workTime&quot;, 100);<tr><td><a id="l5488"></a><a href="#l5488">5488</a><td>  option(&quot;workDelay&quot;, 100);<tr><td><a id="l5489"></a><a href="#l5489">5489</a><td>  option(&quot;flattenSpans&quot;, true, resetModeState, true);<tr><td><a id="l5490"></a><a href="#l5490">5490</a><td>  option(&quot;addModeClass&quot;, false, resetModeState, true);<tr><td><a id="l5491"></a><a href="#l5491">5491</a><td>  option(&quot;pollInterval&quot;, 100);<tr><td><a id="l5492"></a><a href="#l5492">5492</a><td>  option(&quot;undoDepth&quot;, 200, function(cm, val){cm.doc.history.undoDepth = val;});<tr><td><a id="l5493"></a><a href="#l5493">5493</a><td>  option(&quot;historyEventDelay&quot;, 1250);<tr><td><a id="l5494"></a><a href="#l5494">5494</a><td>  option(&quot;viewportMargin&quot;, 10, function(cm){cm.refresh();}, true);<tr><td><a id="l5495"></a><a href="#l5495">5495</a><td>  option(&quot;maxHighlightLength&quot;, 10000, resetModeState, true);<tr><td><a id="l5496"></a><a href="#l5496">5496</a><td>  option(&quot;moveInputWithCursor&quot;, true, function(cm, val) {<tr><td><a id="l5497"></a><a href="#l5497">5497</a><td>    if (!val) cm.display.input.resetPosition();<tr><td><a id="l5498"></a><a href="#l5498">5498</a><td>  });<tr><td><a id="l5499"></a><a href="#l5499">5499</a><td><tr><td><a id="l5500"></a><a href="#l5500">5500</a><td>  option(&quot;tabindex&quot;, null, function(cm, val) {<tr><td><a id="l5501"></a><a href="#l5501">5501</a><td>    cm.display.input.getField().tabIndex = val || &quot;&quot;;<tr><td><a id="l5502"></a><a href="#l5502">5502</a><td>  });<tr><td><a id="l5503"></a><a href="#l5503">5503</a><td>  option(&quot;autofocus&quot;, null);<tr><td><a id="l5504"></a><a href="#l5504">5504</a><td><tr><td><a id="l5505"></a><a href="#l5505">5505</a><td>  // MODE DEFINITION AND QUERYING<tr><td><a id="l5506"></a><a href="#l5506">5506</a><td><tr><td><a id="l5507"></a><a href="#l5507">5507</a><td>  // Known modes, by name and by MIME<tr><td><a id="l5508"></a><a href="#l5508">5508</a><td>  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};<tr><td><a id="l5509"></a><a href="#l5509">5509</a><td><tr><td><a id="l5510"></a><a href="#l5510">5510</a><td>  // Extra arguments are stored as the mode&#39;s dependencies, which is<tr><td><a id="l5511"></a><a href="#l5511">5511</a><td>  // used by (legacy) mechanisms like loadmode.js to automatically<tr><td><a id="l5512"></a><a href="#l5512">5512</a><td>  // load a mode. (Preferred mechanism is the require/define calls.)<tr><td><a id="l5513"></a><a href="#l5513">5513</a><td>  CodeMirror.defineMode = function(name, mode) {<tr><td><a id="l5514"></a><a href="#l5514">5514</a><td>    if (!CodeMirror.defaults.mode &amp;&amp; name != &quot;null&quot;) CodeMirror.defaults.mode = name;<tr><td><a id="l5515"></a><a href="#l5515">5515</a><td>    if (arguments.length &gt; 2)<tr><td><a id="l5516"></a><a href="#l5516">5516</a><td>      mode.dependencies = Array.prototype.slice.call(arguments, 2);<tr><td><a id="l5517"></a><a href="#l5517">5517</a><td>    modes[name] = mode;<tr><td><a id="l5518"></a><a href="#l5518">5518</a><td>  };<tr><td><a id="l5519"></a><a href="#l5519">5519</a><td><tr><td><a id="l5520"></a><a href="#l5520">5520</a><td>  CodeMirror.defineMIME = function(mime, spec) {<tr><td><a id="l5521"></a><a href="#l5521">5521</a><td>    mimeModes[mime] = spec;<tr><td><a id="l5522"></a><a href="#l5522">5522</a><td>  };<tr><td><a id="l5523"></a><a href="#l5523">5523</a><td><tr><td><a id="l5524"></a><a href="#l5524">5524</a><td>  // Given a MIME type, a {name, ...options} config object, or a name<tr><td><a id="l5525"></a><a href="#l5525">5525</a><td>  // string, return a mode config object.<tr><td><a id="l5526"></a><a href="#l5526">5526</a><td>  CodeMirror.resolveMode = function(spec) {<tr><td><a id="l5527"></a><a href="#l5527">5527</a><td>    if (typeof spec == &quot;string&quot; &amp;&amp; mimeModes.hasOwnProperty(spec)) {<tr><td><a id="l5528"></a><a href="#l5528">5528</a><td>      spec = mimeModes[spec];<tr><td><a id="l5529"></a><a href="#l5529">5529</a><td>    } else if (spec &amp;&amp; typeof spec.name == &quot;string&quot; &amp;&amp; mimeModes.hasOwnProperty(spec.name)) {<tr><td><a id="l5530"></a><a href="#l5530">5530</a><td>      var found = mimeModes[spec.name];<tr><td><a id="l5531"></a><a href="#l5531">5531</a><td>      if (typeof found == &quot;string&quot;) found = {name: found};<tr><td><a id="l5532"></a><a href="#l5532">5532</a><td>      spec = createObj(found, spec);<tr><td><a id="l5533"></a><a href="#l5533">5533</a><td>      spec.name = found.name;<tr><td><a id="l5534"></a><a href="#l5534">5534</a><td>    } else if (typeof spec == &quot;string&quot; &amp;&amp; /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {<tr><td><a id="l5535"></a><a href="#l5535">5535</a><td>      return CodeMirror.resolveMode(&quot;application/xml&quot;);<tr><td><a id="l5536"></a><a href="#l5536">5536</a><td>    }<tr><td><a id="l5537"></a><a href="#l5537">5537</a><td>    if (typeof spec == &quot;string&quot;) return {name: spec};<tr><td><a id="l5538"></a><a href="#l5538">5538</a><td>    else return spec || {name: &quot;null&quot;};<tr><td><a id="l5539"></a><a href="#l5539">5539</a><td>  };<tr><td><a id="l5540"></a><a href="#l5540">5540</a><td><tr><td><a id="l5541"></a><a href="#l5541">5541</a><td>  // Given a mode spec (anything that resolveMode accepts), find and<tr><td><a id="l5542"></a><a href="#l5542">5542</a><td>  // initialize an actual mode object.<tr><td><a id="l5543"></a><a href="#l5543">5543</a><td>  CodeMirror.getMode = function(options, spec) {<tr><td><a id="l5544"></a><a href="#l5544">5544</a><td>    var spec = CodeMirror.resolveMode(spec);<tr><td><a id="l5545"></a><a href="#l5545">5545</a><td>    var mfactory = modes[spec.name];<tr><td><a id="l5546"></a><a href="#l5546">5546</a><td>    if (!mfactory) return CodeMirror.getMode(options, &quot;text/plain&quot;);<tr><td><a id="l5547"></a><a href="#l5547">5547</a><td>    var modeObj = mfactory(options, spec);<tr><td><a id="l5548"></a><a href="#l5548">5548</a><td>    if (modeExtensions.hasOwnProperty(spec.name)) {<tr><td><a id="l5549"></a><a href="#l5549">5549</a><td>      var exts = modeExtensions[spec.name];<tr><td><a id="l5550"></a><a href="#l5550">5550</a><td>      for (var prop in exts) {<tr><td><a id="l5551"></a><a href="#l5551">5551</a><td>        if (!exts.hasOwnProperty(prop)) continue;<tr><td><a id="l5552"></a><a href="#l5552">5552</a><td>        if (modeObj.hasOwnProperty(prop)) modeObj[&quot;_&quot; + prop] = modeObj[prop];<tr><td><a id="l5553"></a><a href="#l5553">5553</a><td>        modeObj[prop] = exts[prop];<tr><td><a id="l5554"></a><a href="#l5554">5554</a><td>      }<tr><td><a id="l5555"></a><a href="#l5555">5555</a><td>    }<tr><td><a id="l5556"></a><a href="#l5556">5556</a><td>    modeObj.name = spec.name;<tr><td><a id="l5557"></a><a href="#l5557">5557</a><td>    if (spec.helperType) modeObj.helperType = spec.helperType;<tr><td><a id="l5558"></a><a href="#l5558">5558</a><td>    if (spec.modeProps) for (var prop in spec.modeProps)<tr><td><a id="l5559"></a><a href="#l5559">5559</a><td>      modeObj[prop] = spec.modeProps[prop];<tr><td><a id="l5560"></a><a href="#l5560">5560</a><td><tr><td><a id="l5561"></a><a href="#l5561">5561</a><td>    return modeObj;<tr><td><a id="l5562"></a><a href="#l5562">5562</a><td>  };<tr><td><a id="l5563"></a><a href="#l5563">5563</a><td><tr><td><a id="l5564"></a><a href="#l5564">5564</a><td>  // Minimal default mode.<tr><td><a id="l5565"></a><a href="#l5565">5565</a><td>  CodeMirror.defineMode(&quot;null&quot;, function() {<tr><td><a id="l5566"></a><a href="#l5566">5566</a><td>    return {token: function(stream) {stream.skipToEnd();}};<tr><td><a id="l5567"></a><a href="#l5567">5567</a><td>  });<tr><td><a id="l5568"></a><a href="#l5568">5568</a><td>  CodeMirror.defineMIME(&quot;text/plain&quot;, &quot;null&quot;);<tr><td><a id="l5569"></a><a href="#l5569">5569</a><td><tr><td><a id="l5570"></a><a href="#l5570">5570</a><td>  // This can be used to attach properties to mode objects from<tr><td><a id="l5571"></a><a href="#l5571">5571</a><td>  // outside the actual mode definition.<tr><td><a id="l5572"></a><a href="#l5572">5572</a><td>  var modeExtensions = CodeMirror.modeExtensions = {};<tr><td><a id="l5573"></a><a href="#l5573">5573</a><td>  CodeMirror.extendMode = function(mode, properties) {<tr><td><a id="l5574"></a><a href="#l5574">5574</a><td>    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});<tr><td><a id="l5575"></a><a href="#l5575">5575</a><td>    copyObj(properties, exts);<tr><td><a id="l5576"></a><a href="#l5576">5576</a><td>  };<tr><td><a id="l5577"></a><a href="#l5577">5577</a><td><tr><td><a id="l5578"></a><a href="#l5578">5578</a><td>  // EXTENSIONS<tr><td><a id="l5579"></a><a href="#l5579">5579</a><td><tr><td><a id="l5580"></a><a href="#l5580">5580</a><td>  CodeMirror.defineExtension = function(name, func) {<tr><td><a id="l5581"></a><a href="#l5581">5581</a><td>    CodeMirror.prototype[name] = func;<tr><td><a id="l5582"></a><a href="#l5582">5582</a><td>  };<tr><td><a id="l5583"></a><a href="#l5583">5583</a><td>  CodeMirror.defineDocExtension = function(name, func) {<tr><td><a id="l5584"></a><a href="#l5584">5584</a><td>    Doc.prototype[name] = func;<tr><td><a id="l5585"></a><a href="#l5585">5585</a><td>  };<tr><td><a id="l5586"></a><a href="#l5586">5586</a><td>  CodeMirror.defineOption = option;<tr><td><a id="l5587"></a><a href="#l5587">5587</a><td><tr><td><a id="l5588"></a><a href="#l5588">5588</a><td>  var initHooks = [];<tr><td><a id="l5589"></a><a href="#l5589">5589</a><td>  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};<tr><td><a id="l5590"></a><a href="#l5590">5590</a><td><tr><td><a id="l5591"></a><a href="#l5591">5591</a><td>  var helpers = CodeMirror.helpers = {};<tr><td><a id="l5592"></a><a href="#l5592">5592</a><td>  CodeMirror.registerHelper = function(type, name, value) {<tr><td><a id="l5593"></a><a href="#l5593">5593</a><td>    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};<tr><td><a id="l5594"></a><a href="#l5594">5594</a><td>    helpers[type][name] = value;<tr><td><a id="l5595"></a><a href="#l5595">5595</a><td>  };<tr><td><a id="l5596"></a><a href="#l5596">5596</a><td>  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {<tr><td><a id="l5597"></a><a href="#l5597">5597</a><td>    CodeMirror.registerHelper(type, name, value);<tr><td><a id="l5598"></a><a href="#l5598">5598</a><td>    helpers[type]._global.push({pred: predicate, val: value});<tr><td><a id="l5599"></a><a href="#l5599">5599</a><td>  };<tr><td><a id="l5600"></a><a href="#l5600">5600</a><td><tr><td><a id="l5601"></a><a href="#l5601">5601</a><td>  // MODE STATE HANDLING<tr><td><a id="l5602"></a><a href="#l5602">5602</a><td><tr><td><a id="l5603"></a><a href="#l5603">5603</a><td>  // Utility functions for working with state. Exported because nested<tr><td><a id="l5604"></a><a href="#l5604">5604</a><td>  // modes need to do this for their inner modes.<tr><td><a id="l5605"></a><a href="#l5605">5605</a><td><tr><td><a id="l5606"></a><a href="#l5606">5606</a><td>  var copyState = CodeMirror.copyState = function(mode, state) {<tr><td><a id="l5607"></a><a href="#l5607">5607</a><td>    if (state === true) return state;<tr><td><a id="l5608"></a><a href="#l5608">5608</a><td>    if (mode.copyState) return mode.copyState(state);<tr><td><a id="l5609"></a><a href="#l5609">5609</a><td>    var nstate = {};<tr><td><a id="l5610"></a><a href="#l5610">5610</a><td>    for (var n in state) {<tr><td><a id="l5611"></a><a href="#l5611">5611</a><td>      var val = state[n];<tr><td><a id="l5612"></a><a href="#l5612">5612</a><td>      if (val instanceof Array) val = val.concat([]);<tr><td><a id="l5613"></a><a href="#l5613">5613</a><td>      nstate[n] = val;<tr><td><a id="l5614"></a><a href="#l5614">5614</a><td>    }<tr><td><a id="l5615"></a><a href="#l5615">5615</a><td>    return nstate;<tr><td><a id="l5616"></a><a href="#l5616">5616</a><td>  };<tr><td><a id="l5617"></a><a href="#l5617">5617</a><td><tr><td><a id="l5618"></a><a href="#l5618">5618</a><td>  var startState = CodeMirror.startState = function(mode, a1, a2) {<tr><td><a id="l5619"></a><a href="#l5619">5619</a><td>    return mode.startState ? mode.startState(a1, a2) : true;<tr><td><a id="l5620"></a><a href="#l5620">5620</a><td>  };<tr><td><a id="l5621"></a><a href="#l5621">5621</a><td><tr><td><a id="l5622"></a><a href="#l5622">5622</a><td>  // Given a mode and a state (for that mode), find the inner mode and<tr><td><a id="l5623"></a><a href="#l5623">5623</a><td>  // state at the position that the state refers to.<tr><td><a id="l5624"></a><a href="#l5624">5624</a><td>  CodeMirror.innerMode = function(mode, state) {<tr><td><a id="l5625"></a><a href="#l5625">5625</a><td>    while (mode.innerMode) {<tr><td><a id="l5626"></a><a href="#l5626">5626</a><td>      var info = mode.innerMode(state);<tr><td><a id="l5627"></a><a href="#l5627">5627</a><td>      if (!info || info.mode == mode) break;<tr><td><a id="l5628"></a><a href="#l5628">5628</a><td>      state = info.state;<tr><td><a id="l5629"></a><a href="#l5629">5629</a><td>      mode = info.mode;<tr><td><a id="l5630"></a><a href="#l5630">5630</a><td>    }<tr><td><a id="l5631"></a><a href="#l5631">5631</a><td>    return info || {mode: mode, state: state};<tr><td><a id="l5632"></a><a href="#l5632">5632</a><td>  };<tr><td><a id="l5633"></a><a href="#l5633">5633</a><td><tr><td><a id="l5634"></a><a href="#l5634">5634</a><td>  // STANDARD COMMANDS<tr><td><a id="l5635"></a><a href="#l5635">5635</a><td><tr><td><a id="l5636"></a><a href="#l5636">5636</a><td>  // Commands are parameter-less actions that can be performed on an<tr><td><a id="l5637"></a><a href="#l5637">5637</a><td>  // editor, mostly used for keybindings.<tr><td><a id="l5638"></a><a href="#l5638">5638</a><td>  var commands = CodeMirror.commands = {<tr><td><a id="l5639"></a><a href="#l5639">5639</a><td>    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},<tr><td><a id="l5640"></a><a href="#l5640">5640</a><td>    singleSelection: function(cm) {<tr><td><a id="l5641"></a><a href="#l5641">5641</a><td>      cm.setSelection(cm.getCursor(&quot;anchor&quot;), cm.getCursor(&quot;head&quot;), sel_dontScroll);<tr><td><a id="l5642"></a><a href="#l5642">5642</a><td>    },<tr><td><a id="l5643"></a><a href="#l5643">5643</a><td>    killLine: function(cm) {<tr><td><a id="l5644"></a><a href="#l5644">5644</a><td>      deleteNearSelection(cm, function(range) {<tr><td><a id="l5645"></a><a href="#l5645">5645</a><td>        if (range.empty()) {<tr><td><a id="l5646"></a><a href="#l5646">5646</a><td>          var len = getLine(cm.doc, range.head.line).text.length;<tr><td><a id="l5647"></a><a href="#l5647">5647</a><td>          if (range.head.ch == len &amp;&amp; range.head.line &lt; cm.lastLine())<tr><td><a id="l5648"></a><a href="#l5648">5648</a><td>            return {from: range.head, to: Pos(range.head.line + 1, 0)};<tr><td><a id="l5649"></a><a href="#l5649">5649</a><td>          else<tr><td><a id="l5650"></a><a href="#l5650">5650</a><td>            return {from: range.head, to: Pos(range.head.line, len)};<tr><td><a id="l5651"></a><a href="#l5651">5651</a><td>        } else {<tr><td><a id="l5652"></a><a href="#l5652">5652</a><td>          return {from: range.from(), to: range.to()};<tr><td><a id="l5653"></a><a href="#l5653">5653</a><td>        }<tr><td><a id="l5654"></a><a href="#l5654">5654</a><td>      });<tr><td><a id="l5655"></a><a href="#l5655">5655</a><td>    },<tr><td><a id="l5656"></a><a href="#l5656">5656</a><td>    deleteLine: function(cm) {<tr><td><a id="l5657"></a><a href="#l5657">5657</a><td>      deleteNearSelection(cm, function(range) {<tr><td><a id="l5658"></a><a href="#l5658">5658</a><td>        return {from: Pos(range.from().line, 0),<tr><td><a id="l5659"></a><a href="#l5659">5659</a><td>                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};<tr><td><a id="l5660"></a><a href="#l5660">5660</a><td>      });<tr><td><a id="l5661"></a><a href="#l5661">5661</a><td>    },<tr><td><a id="l5662"></a><a href="#l5662">5662</a><td>    delLineLeft: function(cm) {<tr><td><a id="l5663"></a><a href="#l5663">5663</a><td>      deleteNearSelection(cm, function(range) {<tr><td><a id="l5664"></a><a href="#l5664">5664</a><td>        return {from: Pos(range.from().line, 0), to: range.from()};<tr><td><a id="l5665"></a><a href="#l5665">5665</a><td>      });<tr><td><a id="l5666"></a><a href="#l5666">5666</a><td>    },<tr><td><a id="l5667"></a><a href="#l5667">5667</a><td>    delWrappedLineLeft: function(cm) {<tr><td><a id="l5668"></a><a href="#l5668">5668</a><td>      deleteNearSelection(cm, function(range) {<tr><td><a id="l5669"></a><a href="#l5669">5669</a><td>        var top = cm.charCoords(range.head, &quot;div&quot;).top + 5;<tr><td><a id="l5670"></a><a href="#l5670">5670</a><td>        var leftPos = cm.coordsChar({left: 0, top: top}, &quot;div&quot;);<tr><td><a id="l5671"></a><a href="#l5671">5671</a><td>        return {from: leftPos, to: range.from()};<tr><td><a id="l5672"></a><a href="#l5672">5672</a><td>      });<tr><td><a id="l5673"></a><a href="#l5673">5673</a><td>    },<tr><td><a id="l5674"></a><a href="#l5674">5674</a><td>    delWrappedLineRight: function(cm) {<tr><td><a id="l5675"></a><a href="#l5675">5675</a><td>      deleteNearSelection(cm, function(range) {<tr><td><a id="l5676"></a><a href="#l5676">5676</a><td>        var top = cm.charCoords(range.head, &quot;div&quot;).top + 5;<tr><td><a id="l5677"></a><a href="#l5677">5677</a><td>        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, &quot;div&quot;);<tr><td><a id="l5678"></a><a href="#l5678">5678</a><td>        return {from: range.from(), to: rightPos };<tr><td><a id="l5679"></a><a href="#l5679">5679</a><td>      });<tr><td><a id="l5680"></a><a href="#l5680">5680</a><td>    },<tr><td><a id="l5681"></a><a href="#l5681">5681</a><td>    undo: function(cm) {cm.undo();},<tr><td><a id="l5682"></a><a href="#l5682">5682</a><td>    redo: function(cm) {cm.redo();},<tr><td><a id="l5683"></a><a href="#l5683">5683</a><td>    undoSelection: function(cm) {cm.undoSelection();},<tr><td><a id="l5684"></a><a href="#l5684">5684</a><td>    redoSelection: function(cm) {cm.redoSelection();},<tr><td><a id="l5685"></a><a href="#l5685">5685</a><td>    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},<tr><td><a id="l5686"></a><a href="#l5686">5686</a><td>    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},<tr><td><a id="l5687"></a><a href="#l5687">5687</a><td>    goLineStart: function(cm) {<tr><td><a id="l5688"></a><a href="#l5688">5688</a><td>      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },<tr><td><a id="l5689"></a><a href="#l5689">5689</a><td>                            {origin: &quot;+move&quot;, bias: 1});<tr><td><a id="l5690"></a><a href="#l5690">5690</a><td>    },<tr><td><a id="l5691"></a><a href="#l5691">5691</a><td>    goLineStartSmart: function(cm) {<tr><td><a id="l5692"></a><a href="#l5692">5692</a><td>      cm.extendSelectionsBy(function(range) {<tr><td><a id="l5693"></a><a href="#l5693">5693</a><td>        return lineStartSmart(cm, range.head);<tr><td><a id="l5694"></a><a href="#l5694">5694</a><td>      }, {origin: &quot;+move&quot;, bias: 1});<tr><td><a id="l5695"></a><a href="#l5695">5695</a><td>    },<tr><td><a id="l5696"></a><a href="#l5696">5696</a><td>    goLineEnd: function(cm) {<tr><td><a id="l5697"></a><a href="#l5697">5697</a><td>      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },<tr><td><a id="l5698"></a><a href="#l5698">5698</a><td>                            {origin: &quot;+move&quot;, bias: -1});<tr><td><a id="l5699"></a><a href="#l5699">5699</a><td>    },<tr><td><a id="l5700"></a><a href="#l5700">5700</a><td>    goLineRight: function(cm) {<tr><td><a id="l5701"></a><a href="#l5701">5701</a><td>      cm.extendSelectionsBy(function(range) {<tr><td><a id="l5702"></a><a href="#l5702">5702</a><td>        var top = cm.charCoords(range.head, &quot;div&quot;).top + 5;<tr><td><a id="l5703"></a><a href="#l5703">5703</a><td>        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, &quot;div&quot;);<tr><td><a id="l5704"></a><a href="#l5704">5704</a><td>      }, sel_move);<tr><td><a id="l5705"></a><a href="#l5705">5705</a><td>    },<tr><td><a id="l5706"></a><a href="#l5706">5706</a><td>    goLineLeft: function(cm) {<tr><td><a id="l5707"></a><a href="#l5707">5707</a><td>      cm.extendSelectionsBy(function(range) {<tr><td><a id="l5708"></a><a href="#l5708">5708</a><td>        var top = cm.charCoords(range.head, &quot;div&quot;).top + 5;<tr><td><a id="l5709"></a><a href="#l5709">5709</a><td>        return cm.coordsChar({left: 0, top: top}, &quot;div&quot;);<tr><td><a id="l5710"></a><a href="#l5710">5710</a><td>      }, sel_move);<tr><td><a id="l5711"></a><a href="#l5711">5711</a><td>    },<tr><td><a id="l5712"></a><a href="#l5712">5712</a><td>    goLineLeftSmart: function(cm) {<tr><td><a id="l5713"></a><a href="#l5713">5713</a><td>      cm.extendSelectionsBy(function(range) {<tr><td><a id="l5714"></a><a href="#l5714">5714</a><td>        var top = cm.charCoords(range.head, &quot;div&quot;).top + 5;<tr><td><a id="l5715"></a><a href="#l5715">5715</a><td>        var pos = cm.coordsChar({left: 0, top: top}, &quot;div&quot;);<tr><td><a id="l5716"></a><a href="#l5716">5716</a><td>        if (pos.ch &lt; cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);<tr><td><a id="l5717"></a><a href="#l5717">5717</a><td>        return pos;<tr><td><a id="l5718"></a><a href="#l5718">5718</a><td>      }, sel_move);<tr><td><a id="l5719"></a><a href="#l5719">5719</a><td>    },<tr><td><a id="l5720"></a><a href="#l5720">5720</a><td>    goLineUp: function(cm) {cm.moveV(-1, &quot;line&quot;);},<tr><td><a id="l5721"></a><a href="#l5721">5721</a><td>    goLineDown: function(cm) {cm.moveV(1, &quot;line&quot;);},<tr><td><a id="l5722"></a><a href="#l5722">5722</a><td>    goPageUp: function(cm) {cm.moveV(-1, &quot;page&quot;);},<tr><td><a id="l5723"></a><a href="#l5723">5723</a><td>    goPageDown: function(cm) {cm.moveV(1, &quot;page&quot;);},<tr><td><a id="l5724"></a><a href="#l5724">5724</a><td>    goCharLeft: function(cm) {cm.moveH(-1, &quot;char&quot;);},<tr><td><a id="l5725"></a><a href="#l5725">5725</a><td>    goCharRight: function(cm) {cm.moveH(1, &quot;char&quot;);},<tr><td><a id="l5726"></a><a href="#l5726">5726</a><td>    goColumnLeft: function(cm) {cm.moveH(-1, &quot;column&quot;);},<tr><td><a id="l5727"></a><a href="#l5727">5727</a><td>    goColumnRight: function(cm) {cm.moveH(1, &quot;column&quot;);},<tr><td><a id="l5728"></a><a href="#l5728">5728</a><td>    goWordLeft: function(cm) {cm.moveH(-1, &quot;word&quot;);},<tr><td><a id="l5729"></a><a href="#l5729">5729</a><td>    goGroupRight: function(cm) {cm.moveH(1, &quot;group&quot;);},<tr><td><a id="l5730"></a><a href="#l5730">5730</a><td>    goGroupLeft: function(cm) {cm.moveH(-1, &quot;group&quot;);},<tr><td><a id="l5731"></a><a href="#l5731">5731</a><td>    goWordRight: function(cm) {cm.moveH(1, &quot;word&quot;);},<tr><td><a id="l5732"></a><a href="#l5732">5732</a><td>    delCharBefore: function(cm) {cm.deleteH(-1, &quot;char&quot;);},<tr><td><a id="l5733"></a><a href="#l5733">5733</a><td>    delCharAfter: function(cm) {cm.deleteH(1, &quot;char&quot;);},<tr><td><a id="l5734"></a><a href="#l5734">5734</a><td>    delWordBefore: function(cm) {cm.deleteH(-1, &quot;word&quot;);},<tr><td><a id="l5735"></a><a href="#l5735">5735</a><td>    delWordAfter: function(cm) {cm.deleteH(1, &quot;word&quot;);},<tr><td><a id="l5736"></a><a href="#l5736">5736</a><td>    delGroupBefore: function(cm) {cm.deleteH(-1, &quot;group&quot;);},<tr><td><a id="l5737"></a><a href="#l5737">5737</a><td>    delGroupAfter: function(cm) {cm.deleteH(1, &quot;group&quot;);},<tr><td><a id="l5738"></a><a href="#l5738">5738</a><td>    indentAuto: function(cm) {cm.indentSelection(&quot;smart&quot;);},<tr><td><a id="l5739"></a><a href="#l5739">5739</a><td>    indentMore: function(cm) {cm.indentSelection(&quot;add&quot;);},<tr><td><a id="l5740"></a><a href="#l5740">5740</a><td>    indentLess: function(cm) {cm.indentSelection(&quot;subtract&quot;);},<tr><td><a id="l5741"></a><a href="#l5741">5741</a><td>    insertTab: function(cm) {cm.replaceSelection(&quot;\t&quot;);},<tr><td><a id="l5742"></a><a href="#l5742">5742</a><td>    insertSoftTab: function(cm) {<tr><td><a id="l5743"></a><a href="#l5743">5743</a><td>      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;<tr><td><a id="l5744"></a><a href="#l5744">5744</a><td>      for (var i = 0; i &lt; ranges.length; i++) {<tr><td><a id="l5745"></a><a href="#l5745">5745</a><td>        var pos = ranges[i].from();<tr><td><a id="l5746"></a><a href="#l5746">5746</a><td>        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);<tr><td><a id="l5747"></a><a href="#l5747">5747</a><td>        spaces.push(spaceStr(tabSize - col % tabSize));<tr><td><a id="l5748"></a><a href="#l5748">5748</a><td>      }<tr><td><a id="l5749"></a><a href="#l5749">5749</a><td>      cm.replaceSelections(spaces);<tr><td><a id="l5750"></a><a href="#l5750">5750</a><td>    },<tr><td><a id="l5751"></a><a href="#l5751">5751</a><td>    defaultTab: function(cm) {<tr><td><a id="l5752"></a><a href="#l5752">5752</a><td>      if (cm.somethingSelected()) cm.indentSelection(&quot;add&quot;);<tr><td><a id="l5753"></a><a href="#l5753">5753</a><td>      else cm.execCommand(&quot;insertTab&quot;);<tr><td><a id="l5754"></a><a href="#l5754">5754</a><td>    },<tr><td><a id="l5755"></a><a href="#l5755">5755</a><td>    transposeChars: function(cm) {<tr><td><a id="l5756"></a><a href="#l5756">5756</a><td>      runInOp(cm, function() {<tr><td><a id="l5757"></a><a href="#l5757">5757</a><td>        var ranges = cm.listSelections(), newSel = [];<tr><td><a id="l5758"></a><a href="#l5758">5758</a><td>        for (var i = 0; i &lt; ranges.length; i++) {<tr><td><a id="l5759"></a><a href="#l5759">5759</a><td>          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;<tr><td><a id="l5760"></a><a href="#l5760">5760</a><td>          if (line) {<tr><td><a id="l5761"></a><a href="#l5761">5761</a><td>            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);<tr><td><a id="l5762"></a><a href="#l5762">5762</a><td>            if (cur.ch &gt; 0) {<tr><td><a id="l5763"></a><a href="#l5763">5763</a><td>              cur = new Pos(cur.line, cur.ch + 1);<tr><td><a id="l5764"></a><a href="#l5764">5764</a><td>              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),<tr><td><a id="l5765"></a><a href="#l5765">5765</a><td>                              Pos(cur.line, cur.ch - 2), cur, &quot;+transpose&quot;);<tr><td><a id="l5766"></a><a href="#l5766">5766</a><td>            } else if (cur.line &gt; cm.doc.first) {<tr><td><a id="l5767"></a><a href="#l5767">5767</a><td>              var prev = getLine(cm.doc, cur.line - 1).text;<tr><td><a id="l5768"></a><a href="#l5768">5768</a><td>              if (prev)<tr><td><a id="l5769"></a><a href="#l5769">5769</a><td>                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +<tr><td><a id="l5770"></a><a href="#l5770">5770</a><td>                                prev.charAt(prev.length - 1),<tr><td><a id="l5771"></a><a href="#l5771">5771</a><td>                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), &quot;+transpose&quot;);<tr><td><a id="l5772"></a><a href="#l5772">5772</a><td>            }<tr><td><a id="l5773"></a><a href="#l5773">5773</a><td>          }<tr><td><a id="l5774"></a><a href="#l5774">5774</a><td>          newSel.push(new Range(cur, cur));<tr><td><a id="l5775"></a><a href="#l5775">5775</a><td>        }<tr><td><a id="l5776"></a><a href="#l5776">5776</a><td>        cm.setSelections(newSel);<tr><td><a id="l5777"></a><a href="#l5777">5777</a><td>      });<tr><td><a id="l5778"></a><a href="#l5778">5778</a><td>    },<tr><td><a id="l5779"></a><a href="#l5779">5779</a><td>    newlineAndIndent: function(cm) {<tr><td><a id="l5780"></a><a href="#l5780">5780</a><td>      runInOp(cm, function() {<tr><td><a id="l5781"></a><a href="#l5781">5781</a><td>        var len = cm.listSelections().length;<tr><td><a id="l5782"></a><a href="#l5782">5782</a><td>        for (var i = 0; i &lt; len; i++) {<tr><td><a id="l5783"></a><a href="#l5783">5783</a><td>          var range = cm.listSelections()[i];<tr><td><a id="l5784"></a><a href="#l5784">5784</a><td>          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, &quot;+input&quot;);<tr><td><a id="l5785"></a><a href="#l5785">5785</a><td>          cm.indentLine(range.from().line + 1, null, true);<tr><td><a id="l5786"></a><a href="#l5786">5786</a><td>        }<tr><td><a id="l5787"></a><a href="#l5787">5787</a><td>        ensureCursorVisible(cm);<tr><td><a id="l5788"></a><a href="#l5788">5788</a><td>      });<tr><td><a id="l5789"></a><a href="#l5789">5789</a><td>    },<tr><td><a id="l5790"></a><a href="#l5790">5790</a><td>    openLine: function(cm) {cm.replaceSelection(&quot;\n&quot;, &quot;start&quot;)},<tr><td><a id="l5791"></a><a href="#l5791">5791</a><td>    toggleOverwrite: function(cm) {cm.toggleOverwrite();}<tr><td><a id="l5792"></a><a href="#l5792">5792</a><td>  };<tr><td><a id="l5793"></a><a href="#l5793">5793</a><td><tr><td><a id="l5794"></a><a href="#l5794">5794</a><td><tr><td><a id="l5795"></a><a href="#l5795">5795</a><td>  // STANDARD KEYMAPS<tr><td><a id="l5796"></a><a href="#l5796">5796</a><td><tr><td><a id="l5797"></a><a href="#l5797">5797</a><td>  var keyMap = CodeMirror.keyMap = {};<tr><td><a id="l5798"></a><a href="#l5798">5798</a><td><tr><td><a id="l5799"></a><a href="#l5799">5799</a><td>  keyMap.basic = {<tr><td><a id="l5800"></a><a href="#l5800">5800</a><td>    &quot;Left&quot;: &quot;goCharLeft&quot;, &quot;Right&quot;: &quot;goCharRight&quot;, &quot;Up&quot;: &quot;goLineUp&quot;, &quot;Down&quot;: &quot;goLineDown&quot;,<tr><td><a id="l5801"></a><a href="#l5801">5801</a><td>    &quot;End&quot;: &quot;goLineEnd&quot;, &quot;Home&quot;: &quot;goLineStartSmart&quot;, &quot;PageUp&quot;: &quot;goPageUp&quot;, &quot;PageDown&quot;: &quot;goPageDown&quot;,<tr><td><a id="l5802"></a><a href="#l5802">5802</a><td>    &quot;Delete&quot;: &quot;delCharAfter&quot;, &quot;Backspace&quot;: &quot;delCharBefore&quot;, &quot;Shift-Backspace&quot;: &quot;delCharBefore&quot;,<tr><td><a id="l5803"></a><a href="#l5803">5803</a><td>    &quot;Tab&quot;: &quot;defaultTab&quot;, &quot;Shift-Tab&quot;: &quot;indentAuto&quot;,<tr><td><a id="l5804"></a><a href="#l5804">5804</a><td>    &quot;Enter&quot;: &quot;newlineAndIndent&quot;, &quot;Insert&quot;: &quot;toggleOverwrite&quot;,<tr><td><a id="l5805"></a><a href="#l5805">5805</a><td>    &quot;Esc&quot;: &quot;singleSelection&quot;<tr><td><a id="l5806"></a><a href="#l5806">5806</a><td>  };<tr><td><a id="l5807"></a><a href="#l5807">5807</a><td>  // Note that the save and find-related commands aren&#39;t defined by<tr><td><a id="l5808"></a><a href="#l5808">5808</a><td>  // default. User code or addons can define them. Unknown commands<tr><td><a id="l5809"></a><a href="#l5809">5809</a><td>  // are simply ignored.<tr><td><a id="l5810"></a><a href="#l5810">5810</a><td>  keyMap.pcDefault = {<tr><td><a id="l5811"></a><a href="#l5811">5811</a><td>    &quot;Ctrl-A&quot;: &quot;selectAll&quot;, &quot;Ctrl-D&quot;: &quot;deleteLine&quot;, &quot;Ctrl-Z&quot;: &quot;undo&quot;, &quot;Shift-Ctrl-Z&quot;: &quot;redo&quot;, &quot;Ctrl-Y&quot;: &quot;redo&quot;,<tr><td><a id="l5812"></a><a href="#l5812">5812</a><td>    &quot;Ctrl-Home&quot;: &quot;goDocStart&quot;, &quot;Ctrl-End&quot;: &quot;goDocEnd&quot;, &quot;Ctrl-Up&quot;: &quot;goLineUp&quot;, &quot;Ctrl-Down&quot;: &quot;goLineDown&quot;,<tr><td><a id="l5813"></a><a href="#l5813">5813</a><td>    &quot;Ctrl-Left&quot;: &quot;goGroupLeft&quot;, &quot;Ctrl-Right&quot;: &quot;goGroupRight&quot;, &quot;Alt-Left&quot;: &quot;goLineStart&quot;, &quot;Alt-Right&quot;: &quot;goLineEnd&quot;,<tr><td><a id="l5814"></a><a href="#l5814">5814</a><td>    &quot;Ctrl-Backspace&quot;: &quot;delGroupBefore&quot;, &quot;Ctrl-Delete&quot;: &quot;delGroupAfter&quot;, &quot;Ctrl-S&quot;: &quot;save&quot;, &quot;Ctrl-F&quot;: &quot;find&quot;,<tr><td><a id="l5815"></a><a href="#l5815">5815</a><td>    &quot;Ctrl-G&quot;: &quot;findNext&quot;, &quot;Shift-Ctrl-G&quot;: &quot;findPrev&quot;, &quot;Shift-Ctrl-F&quot;: &quot;replace&quot;, &quot;Shift-Ctrl-R&quot;: &quot;replaceAll&quot;,<tr><td><a id="l5816"></a><a href="#l5816">5816</a><td>    &quot;Ctrl-[&quot;: &quot;indentLess&quot;, &quot;Ctrl-]&quot;: &quot;indentMore&quot;,<tr><td><a id="l5817"></a><a href="#l5817">5817</a><td>    &quot;Ctrl-U&quot;: &quot;undoSelection&quot;, &quot;Shift-Ctrl-U&quot;: &quot;redoSelection&quot;, &quot;Alt-U&quot;: &quot;redoSelection&quot;,<tr><td><a id="l5818"></a><a href="#l5818">5818</a><td>    fallthrough: &quot;basic&quot;<tr><td><a id="l5819"></a><a href="#l5819">5819</a><td>  };<tr><td><a id="l5820"></a><a href="#l5820">5820</a><td>  // Very basic readline/emacs-style bindings, which are standard on Mac.<tr><td><a id="l5821"></a><a href="#l5821">5821</a><td>  keyMap.emacsy = {<tr><td><a id="l5822"></a><a href="#l5822">5822</a><td>    &quot;Ctrl-F&quot;: &quot;goCharRight&quot;, &quot;Ctrl-B&quot;: &quot;goCharLeft&quot;, &quot;Ctrl-P&quot;: &quot;goLineUp&quot;, &quot;Ctrl-N&quot;: &quot;goLineDown&quot;,<tr><td><a id="l5823"></a><a href="#l5823">5823</a><td>    &quot;Alt-F&quot;: &quot;goWordRight&quot;, &quot;Alt-B&quot;: &quot;goWordLeft&quot;, &quot;Ctrl-A&quot;: &quot;goLineStart&quot;, &quot;Ctrl-E&quot;: &quot;goLineEnd&quot;,<tr><td><a id="l5824"></a><a href="#l5824">5824</a><td>    &quot;Ctrl-V&quot;: &quot;goPageDown&quot;, &quot;Shift-Ctrl-V&quot;: &quot;goPageUp&quot;, &quot;Ctrl-D&quot;: &quot;delCharAfter&quot;, &quot;Ctrl-H&quot;: &quot;delCharBefore&quot;,<tr><td><a id="l5825"></a><a href="#l5825">5825</a><td>    &quot;Alt-D&quot;: &quot;delWordAfter&quot;, &quot;Alt-Backspace&quot;: &quot;delWordBefore&quot;, &quot;Ctrl-K&quot;: &quot;killLine&quot;, &quot;Ctrl-T&quot;: &quot;transposeChars&quot;,<tr><td><a id="l5826"></a><a href="#l5826">5826</a><td>    &quot;Ctrl-O&quot;: &quot;openLine&quot;<tr><td><a id="l5827"></a><a href="#l5827">5827</a><td>  };<tr><td><a id="l5828"></a><a href="#l5828">5828</a><td>  keyMap.macDefault = {<tr><td><a id="l5829"></a><a href="#l5829">5829</a><td>    &quot;Cmd-A&quot;: &quot;selectAll&quot;, &quot;Cmd-D&quot;: &quot;deleteLine&quot;, &quot;Cmd-Z&quot;: &quot;undo&quot;, &quot;Shift-Cmd-Z&quot;: &quot;redo&quot;, &quot;Cmd-Y&quot;: &quot;redo&quot;,<tr><td><a id="l5830"></a><a href="#l5830">5830</a><td>    &quot;Cmd-Home&quot;: &quot;goDocStart&quot;, &quot;Cmd-Up&quot;: &quot;goDocStart&quot;, &quot;Cmd-End&quot;: &quot;goDocEnd&quot;, &quot;Cmd-Down&quot;: &quot;goDocEnd&quot;, &quot;Alt-Left&quot;: &quot;goGroupLeft&quot;,<tr><td><a id="l5831"></a><a href="#l5831">5831</a><td>    &quot;Alt-Right&quot;: &quot;goGroupRight&quot;, &quot;Cmd-Left&quot;: &quot;goLineLeft&quot;, &quot;Cmd-Right&quot;: &quot;goLineRight&quot;, &quot;Alt-Backspace&quot;: &quot;delGroupBefore&quot;,<tr><td><a id="l5832"></a><a href="#l5832">5832</a><td>    &quot;Ctrl-Alt-Backspace&quot;: &quot;delGroupAfter&quot;, &quot;Alt-Delete&quot;: &quot;delGroupAfter&quot;, &quot;Cmd-S&quot;: &quot;save&quot;, &quot;Cmd-F&quot;: &quot;find&quot;,<tr><td><a id="l5833"></a><a href="#l5833">5833</a><td>    &quot;Cmd-G&quot;: &quot;findNext&quot;, &quot;Shift-Cmd-G&quot;: &quot;findPrev&quot;, &quot;Cmd-Alt-F&quot;: &quot;replace&quot;, &quot;Shift-Cmd-Alt-F&quot;: &quot;replaceAll&quot;,<tr><td><a id="l5834"></a><a href="#l5834">5834</a><td>    &quot;Cmd-[&quot;: &quot;indentLess&quot;, &quot;Cmd-]&quot;: &quot;indentMore&quot;, &quot;Cmd-Backspace&quot;: &quot;delWrappedLineLeft&quot;, &quot;Cmd-Delete&quot;: &quot;delWrappedLineRight&quot;,<tr><td><a id="l5835"></a><a href="#l5835">5835</a><td>    &quot;Cmd-U&quot;: &quot;undoSelection&quot;, &quot;Shift-Cmd-U&quot;: &quot;redoSelection&quot;, &quot;Ctrl-Up&quot;: &quot;goDocStart&quot;, &quot;Ctrl-Down&quot;: &quot;goDocEnd&quot;,<tr><td><a id="l5836"></a><a href="#l5836">5836</a><td>    fallthrough: [&quot;basic&quot;, &quot;emacsy&quot;]<tr><td><a id="l5837"></a><a href="#l5837">5837</a><td>  };<tr><td><a id="l5838"></a><a href="#l5838">5838</a><td>  keyMap[&quot;default&quot;] = mac ? keyMap.macDefault : keyMap.pcDefault;<tr><td><a id="l5839"></a><a href="#l5839">5839</a><td><tr><td><a id="l5840"></a><a href="#l5840">5840</a><td>  // KEYMAP DISPATCH<tr><td><a id="l5841"></a><a href="#l5841">5841</a><td><tr><td><a id="l5842"></a><a href="#l5842">5842</a><td>  function normalizeKeyName(name) {<tr><td><a id="l5843"></a><a href="#l5843">5843</a><td>    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];<tr><td><a id="l5844"></a><a href="#l5844">5844</a><td>    var alt, ctrl, shift, cmd;<tr><td><a id="l5845"></a><a href="#l5845">5845</a><td>    for (var i = 0; i &lt; parts.length - 1; i++) {<tr><td><a id="l5846"></a><a href="#l5846">5846</a><td>      var mod = parts[i];<tr><td><a id="l5847"></a><a href="#l5847">5847</a><td>      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;<tr><td><a id="l5848"></a><a href="#l5848">5848</a><td>      else if (/^a(lt)?$/i.test(mod)) alt = true;<tr><td><a id="l5849"></a><a href="#l5849">5849</a><td>      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;<tr><td><a id="l5850"></a><a href="#l5850">5850</a><td>      else if (/^s(hift)$/i.test(mod)) shift = true;<tr><td><a id="l5851"></a><a href="#l5851">5851</a><td>      else throw new Error(&quot;Unrecognized modifier name: &quot; + mod);<tr><td><a id="l5852"></a><a href="#l5852">5852</a><td>    }<tr><td><a id="l5853"></a><a href="#l5853">5853</a><td>    if (alt) name = &quot;Alt-&quot; + name;<tr><td><a id="l5854"></a><a href="#l5854">5854</a><td>    if (ctrl) name = &quot;Ctrl-&quot; + name;<tr><td><a id="l5855"></a><a href="#l5855">5855</a><td>    if (cmd) name = &quot;Cmd-&quot; + name;<tr><td><a id="l5856"></a><a href="#l5856">5856</a><td>    if (shift) name = &quot;Shift-&quot; + name;<tr><td><a id="l5857"></a><a href="#l5857">5857</a><td>    return name;<tr><td><a id="l5858"></a><a href="#l5858">5858</a><td>  }<tr><td><a id="l5859"></a><a href="#l5859">5859</a><td><tr><td><a id="l5860"></a><a href="#l5860">5860</a><td>  // This is a kludge to keep keymaps mostly working as raw objects<tr><td><a id="l5861"></a><a href="#l5861">5861</a><td>  // (backwards compatibility) while at the same time support features<tr><td><a id="l5862"></a><a href="#l5862">5862</a><td>  // like normalization and multi-stroke key bindings. It compiles a<tr><td><a id="l5863"></a><a href="#l5863">5863</a><td>  // new normalized keymap, and then updates the old object to reflect<tr><td><a id="l5864"></a><a href="#l5864">5864</a><td>  // this.<tr><td><a id="l5865"></a><a href="#l5865">5865</a><td>  CodeMirror.normalizeKeyMap = function(keymap) {<tr><td><a id="l5866"></a><a href="#l5866">5866</a><td>    var copy = {};<tr><td><a id="l5867"></a><a href="#l5867">5867</a><td>    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {<tr><td><a id="l5868"></a><a href="#l5868">5868</a><td>      var value = keymap[keyname];<tr><td><a id="l5869"></a><a href="#l5869">5869</a><td>      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;<tr><td><a id="l5870"></a><a href="#l5870">5870</a><td>      if (value == &quot;...&quot;) { delete keymap[keyname]; continue; }<tr><td><a id="l5871"></a><a href="#l5871">5871</a><td><tr><td><a id="l5872"></a><a href="#l5872">5872</a><td>      var keys = map(keyname.split(&quot; &quot;), normalizeKeyName);<tr><td><a id="l5873"></a><a href="#l5873">5873</a><td>      for (var i = 0; i &lt; keys.length; i++) {<tr><td><a id="l5874"></a><a href="#l5874">5874</a><td>        var val, name;<tr><td><a id="l5875"></a><a href="#l5875">5875</a><td>        if (i == keys.length - 1) {<tr><td><a id="l5876"></a><a href="#l5876">5876</a><td>          name = keys.join(&quot; &quot;);<tr><td><a id="l5877"></a><a href="#l5877">5877</a><td>          val = value;<tr><td><a id="l5878"></a><a href="#l5878">5878</a><td>        } else {<tr><td><a id="l5879"></a><a href="#l5879">5879</a><td>          name = keys.slice(0, i + 1).join(&quot; &quot;);<tr><td><a id="l5880"></a><a href="#l5880">5880</a><td>          val = &quot;...&quot;;<tr><td><a id="l5881"></a><a href="#l5881">5881</a><td>        }<tr><td><a id="l5882"></a><a href="#l5882">5882</a><td>        var prev = copy[name];<tr><td><a id="l5883"></a><a href="#l5883">5883</a><td>        if (!prev) copy[name] = val;<tr><td><a id="l5884"></a><a href="#l5884">5884</a><td>        else if (prev != val) throw new Error(&quot;Inconsistent bindings for &quot; + name);<tr><td><a id="l5885"></a><a href="#l5885">5885</a><td>      }<tr><td><a id="l5886"></a><a href="#l5886">5886</a><td>      delete keymap[keyname];<tr><td><a id="l5887"></a><a href="#l5887">5887</a><td>    }<tr><td><a id="l5888"></a><a href="#l5888">5888</a><td>    for (var prop in copy) keymap[prop] = copy[prop];<tr><td><a id="l5889"></a><a href="#l5889">5889</a><td>    return keymap;<tr><td><a id="l5890"></a><a href="#l5890">5890</a><td>  };<tr><td><a id="l5891"></a><a href="#l5891">5891</a><td><tr><td><a id="l5892"></a><a href="#l5892">5892</a><td>  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {<tr><td><a id="l5893"></a><a href="#l5893">5893</a><td>    map = getKeyMap(map);<tr><td><a id="l5894"></a><a href="#l5894">5894</a><td>    var found = map.call ? map.call(key, context) : map[key];<tr><td><a id="l5895"></a><a href="#l5895">5895</a><td>    if (found === false) return &quot;nothing&quot;;<tr><td><a id="l5896"></a><a href="#l5896">5896</a><td>    if (found === &quot;...&quot;) return &quot;multi&quot;;<tr><td><a id="l5897"></a><a href="#l5897">5897</a><td>    if (found != null &amp;&amp; handle(found)) return &quot;handled&quot;;<tr><td><a id="l5898"></a><a href="#l5898">5898</a><td><tr><td><a id="l5899"></a><a href="#l5899">5899</a><td>    if (map.fallthrough) {<tr><td><a id="l5900"></a><a href="#l5900">5900</a><td>      if (Object.prototype.toString.call(map.fallthrough) != &quot;[object Array]&quot;)<tr><td><a id="l5901"></a><a href="#l5901">5901</a><td>        return lookupKey(key, map.fallthrough, handle, context);<tr><td><a id="l5902"></a><a href="#l5902">5902</a><td>      for (var i = 0; i &lt; map.fallthrough.length; i++) {<tr><td><a id="l5903"></a><a href="#l5903">5903</a><td>        var result = lookupKey(key, map.fallthrough[i], handle, context);<tr><td><a id="l5904"></a><a href="#l5904">5904</a><td>        if (result) return result;<tr><td><a id="l5905"></a><a href="#l5905">5905</a><td>      }<tr><td><a id="l5906"></a><a href="#l5906">5906</a><td>    }<tr><td><a id="l5907"></a><a href="#l5907">5907</a><td>  };<tr><td><a id="l5908"></a><a href="#l5908">5908</a><td><tr><td><a id="l5909"></a><a href="#l5909">5909</a><td>  // Modifier key presses don&#39;t count as &#39;real&#39; key presses for the<tr><td><a id="l5910"></a><a href="#l5910">5910</a><td>  // purpose of keymap fallthrough.<tr><td><a id="l5911"></a><a href="#l5911">5911</a><td>  var isModifierKey = CodeMirror.isModifierKey = function(value) {<tr><td><a id="l5912"></a><a href="#l5912">5912</a><td>    var name = typeof value == &quot;string&quot; ? value : keyNames[value.keyCode];<tr><td><a id="l5913"></a><a href="#l5913">5913</a><td>    return name == &quot;Ctrl&quot; || name == &quot;Alt&quot; || name == &quot;Shift&quot; || name == &quot;Mod&quot;;<tr><td><a id="l5914"></a><a href="#l5914">5914</a><td>  };<tr><td><a id="l5915"></a><a href="#l5915">5915</a><td><tr><td><a id="l5916"></a><a href="#l5916">5916</a><td>  // Look up the name of a key as indicated by an event object.<tr><td><a id="l5917"></a><a href="#l5917">5917</a><td>  var keyName = CodeMirror.keyName = function(event, noShift) {<tr><td><a id="l5918"></a><a href="#l5918">5918</a><td>    if (presto &amp;&amp; event.keyCode == 34 &amp;&amp; event[&quot;char&quot;]) return false;<tr><td><a id="l5919"></a><a href="#l5919">5919</a><td>    var base = keyNames[event.keyCode], name = base;<tr><td><a id="l5920"></a><a href="#l5920">5920</a><td>    if (name == null || event.altGraphKey) return false;<tr><td><a id="l5921"></a><a href="#l5921">5921</a><td>    if (event.altKey &amp;&amp; base != &quot;Alt&quot;) name = &quot;Alt-&quot; + name;<tr><td><a id="l5922"></a><a href="#l5922">5922</a><td>    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) &amp;&amp; base != &quot;Ctrl&quot;) name = &quot;Ctrl-&quot; + name;<tr><td><a id="l5923"></a><a href="#l5923">5923</a><td>    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) &amp;&amp; base != &quot;Cmd&quot;) name = &quot;Cmd-&quot; + name;<tr><td><a id="l5924"></a><a href="#l5924">5924</a><td>    if (!noShift &amp;&amp; event.shiftKey &amp;&amp; base != &quot;Shift&quot;) name = &quot;Shift-&quot; + name;<tr><td><a id="l5925"></a><a href="#l5925">5925</a><td>    return name;<tr><td><a id="l5926"></a><a href="#l5926">5926</a><td>  };<tr><td><a id="l5927"></a><a href="#l5927">5927</a><td><tr><td><a id="l5928"></a><a href="#l5928">5928</a><td>  function getKeyMap(val) {<tr><td><a id="l5929"></a><a href="#l5929">5929</a><td>    return typeof val == &quot;string&quot; ? keyMap[val] : val;<tr><td><a id="l5930"></a><a href="#l5930">5930</a><td>  }<tr><td><a id="l5931"></a><a href="#l5931">5931</a><td><tr><td><a id="l5932"></a><a href="#l5932">5932</a><td>  // FROMTEXTAREA<tr><td><a id="l5933"></a><a href="#l5933">5933</a><td><tr><td><a id="l5934"></a><a href="#l5934">5934</a><td>  CodeMirror.fromTextArea = function(textarea, options) {<tr><td><a id="l5935"></a><a href="#l5935">5935</a><td>    options = options ? copyObj(options) : {};<tr><td><a id="l5936"></a><a href="#l5936">5936</a><td>    options.value = textarea.value;<tr><td><a id="l5937"></a><a href="#l5937">5937</a><td>    if (!options.tabindex &amp;&amp; textarea.tabIndex)<tr><td><a id="l5938"></a><a href="#l5938">5938</a><td>      options.tabindex = textarea.tabIndex;<tr><td><a id="l5939"></a><a href="#l5939">5939</a><td>    if (!options.placeholder &amp;&amp; textarea.placeholder)<tr><td><a id="l5940"></a><a href="#l5940">5940</a><td>      options.placeholder = textarea.placeholder;<tr><td><a id="l5941"></a><a href="#l5941">5941</a><td>    // Set autofocus to true if this textarea is focused, or if it has<tr><td><a id="l5942"></a><a href="#l5942">5942</a><td>    // autofocus and no other element is focused.<tr><td><a id="l5943"></a><a href="#l5943">5943</a><td>    if (options.autofocus == null) {<tr><td><a id="l5944"></a><a href="#l5944">5944</a><td>      var hasFocus = activeElt();<tr><td><a id="l5945"></a><a href="#l5945">5945</a><td>      options.autofocus = hasFocus == textarea ||<tr><td><a id="l5946"></a><a href="#l5946">5946</a><td>        textarea.getAttribute(&quot;autofocus&quot;) != null &amp;&amp; hasFocus == document.body;<tr><td><a id="l5947"></a><a href="#l5947">5947</a><td>    }<tr><td><a id="l5948"></a><a href="#l5948">5948</a><td><tr><td><a id="l5949"></a><a href="#l5949">5949</a><td>    function save() {textarea.value = cm.getValue();}<tr><td><a id="l5950"></a><a href="#l5950">5950</a><td>    if (textarea.form) {<tr><td><a id="l5951"></a><a href="#l5951">5951</a><td>      on(textarea.form, &quot;submit&quot;, save);<tr><td><a id="l5952"></a><a href="#l5952">5952</a><td>      // Deplorable hack to make the submit method do the right thing.<tr><td><a id="l5953"></a><a href="#l5953">5953</a><td>      if (!options.leaveSubmitMethodAlone) {<tr><td><a id="l5954"></a><a href="#l5954">5954</a><td>        var form = textarea.form, realSubmit = form.submit;<tr><td><a id="l5955"></a><a href="#l5955">5955</a><td>        try {<tr><td><a id="l5956"></a><a href="#l5956">5956</a><td>          var wrappedSubmit = form.submit = function() {<tr><td><a id="l5957"></a><a href="#l5957">5957</a><td>            save();<tr><td><a id="l5958"></a><a href="#l5958">5958</a><td>            form.submit = realSubmit;<tr><td><a id="l5959"></a><a href="#l5959">5959</a><td>            form.submit();<tr><td><a id="l5960"></a><a href="#l5960">5960</a><td>            form.submit = wrappedSubmit;<tr><td><a id="l5961"></a><a href="#l5961">5961</a><td>          };<tr><td><a id="l5962"></a><a href="#l5962">5962</a><td>        } catch(e) {}<tr><td><a id="l5963"></a><a href="#l5963">5963</a><td>      }<tr><td><a id="l5964"></a><a href="#l5964">5964</a><td>    }<tr><td><a id="l5965"></a><a href="#l5965">5965</a><td><tr><td><a id="l5966"></a><a href="#l5966">5966</a><td>    options.finishInit = function(cm) {<tr><td><a id="l5967"></a><a href="#l5967">5967</a><td>      cm.save = save;<tr><td><a id="l5968"></a><a href="#l5968">5968</a><td>      cm.getTextArea = function() { return textarea; };<tr><td><a id="l5969"></a><a href="#l5969">5969</a><td>      cm.toTextArea = function() {<tr><td><a id="l5970"></a><a href="#l5970">5970</a><td>        cm.toTextArea = isNaN; // Prevent this from being ran twice<tr><td><a id="l5971"></a><a href="#l5971">5971</a><td>        save();<tr><td><a id="l5972"></a><a href="#l5972">5972</a><td>        textarea.parentNode.removeChild(cm.getWrapperElement());<tr><td><a id="l5973"></a><a href="#l5973">5973</a><td>        textarea.style.display = &quot;&quot;;<tr><td><a id="l5974"></a><a href="#l5974">5974</a><td>        if (textarea.form) {<tr><td><a id="l5975"></a><a href="#l5975">5975</a><td>          off(textarea.form, &quot;submit&quot;, save);<tr><td><a id="l5976"></a><a href="#l5976">5976</a><td>          if (typeof textarea.form.submit == &quot;function&quot;)<tr><td><a id="l5977"></a><a href="#l5977">5977</a><td>            textarea.form.submit = realSubmit;<tr><td><a id="l5978"></a><a href="#l5978">5978</a><td>        }<tr><td><a id="l5979"></a><a href="#l5979">5979</a><td>      };<tr><td><a id="l5980"></a><a href="#l5980">5980</a><td>    };<tr><td><a id="l5981"></a><a href="#l5981">5981</a><td><tr><td><a id="l5982"></a><a href="#l5982">5982</a><td>    textarea.style.display = &quot;none&quot;;<tr><td><a id="l5983"></a><a href="#l5983">5983</a><td>    var cm = CodeMirror(function(node) {<tr><td><a id="l5984"></a><a href="#l5984">5984</a><td>      textarea.parentNode.insertBefore(node, textarea.nextSibling);<tr><td><a id="l5985"></a><a href="#l5985">5985</a><td>    }, options);<tr><td><a id="l5986"></a><a href="#l5986">5986</a><td>    return cm;<tr><td><a id="l5987"></a><a href="#l5987">5987</a><td>  };<tr><td><a id="l5988"></a><a href="#l5988">5988</a><td><tr><td><a id="l5989"></a><a href="#l5989">5989</a><td>  // STRING STREAM<tr><td><a id="l5990"></a><a href="#l5990">5990</a><td><tr><td><a id="l5991"></a><a href="#l5991">5991</a><td>  // Fed to the mode parsers, provides helper functions to make<tr><td><a id="l5992"></a><a href="#l5992">5992</a><td>  // parsers more succinct.<tr><td><a id="l5993"></a><a href="#l5993">5993</a><td><tr><td><a id="l5994"></a><a href="#l5994">5994</a><td>  var StringStream = CodeMirror.StringStream = function(string, tabSize) {<tr><td><a id="l5995"></a><a href="#l5995">5995</a><td>    this.pos = this.start = 0;<tr><td><a id="l5996"></a><a href="#l5996">5996</a><td>    this.string = string;<tr><td><a id="l5997"></a><a href="#l5997">5997</a><td>    this.tabSize = tabSize || 8;<tr><td><a id="l5998"></a><a href="#l5998">5998</a><td>    this.lastColumnPos = this.lastColumnValue = 0;<tr><td><a id="l5999"></a><a href="#l5999">5999</a><td>    this.lineStart = 0;<tr><td><a id="l6000"></a><a href="#l6000">6000</a><td>  };<tr><td><a id="l6001"></a><a href="#l6001">6001</a><td><tr><td><a id="l6002"></a><a href="#l6002">6002</a><td>  StringStream.prototype = {<tr><td><a id="l6003"></a><a href="#l6003">6003</a><td>    eol: function() {return this.pos &gt;= this.string.length;},<tr><td><a id="l6004"></a><a href="#l6004">6004</a><td>    sol: function() {return this.pos == this.lineStart;},<tr><td><a id="l6005"></a><a href="#l6005">6005</a><td>    peek: function() {return this.string.charAt(this.pos) || undefined;},<tr><td><a id="l6006"></a><a href="#l6006">6006</a><td>    next: function() {<tr><td><a id="l6007"></a><a href="#l6007">6007</a><td>      if (this.pos &lt; this.string.length)<tr><td><a id="l6008"></a><a href="#l6008">6008</a><td>        return this.string.charAt(this.pos++);<tr><td><a id="l6009"></a><a href="#l6009">6009</a><td>    },<tr><td><a id="l6010"></a><a href="#l6010">6010</a><td>    eat: function(match) {<tr><td><a id="l6011"></a><a href="#l6011">6011</a><td>      var ch = this.string.charAt(this.pos);<tr><td><a id="l6012"></a><a href="#l6012">6012</a><td>      if (typeof match == &quot;string&quot;) var ok = ch == match;<tr><td><a id="l6013"></a><a href="#l6013">6013</a><td>      else var ok = ch &amp;&amp; (match.test ? match.test(ch) : match(ch));<tr><td><a id="l6014"></a><a href="#l6014">6014</a><td>      if (ok) {++this.pos; return ch;}<tr><td><a id="l6015"></a><a href="#l6015">6015</a><td>    },<tr><td><a id="l6016"></a><a href="#l6016">6016</a><td>    eatWhile: function(match) {<tr><td><a id="l6017"></a><a href="#l6017">6017</a><td>      var start = this.pos;<tr><td><a id="l6018"></a><a href="#l6018">6018</a><td>      while (this.eat(match)){}<tr><td><a id="l6019"></a><a href="#l6019">6019</a><td>      return this.pos &gt; start;<tr><td><a id="l6020"></a><a href="#l6020">6020</a><td>    },<tr><td><a id="l6021"></a><a href="#l6021">6021</a><td>    eatSpace: function() {<tr><td><a id="l6022"></a><a href="#l6022">6022</a><td>      var start = this.pos;<tr><td><a id="l6023"></a><a href="#l6023">6023</a><td>      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;<tr><td><a id="l6024"></a><a href="#l6024">6024</a><td>      return this.pos &gt; start;<tr><td><a id="l6025"></a><a href="#l6025">6025</a><td>    },<tr><td><a id="l6026"></a><a href="#l6026">6026</a><td>    skipToEnd: function() {this.pos = this.string.length;},<tr><td><a id="l6027"></a><a href="#l6027">6027</a><td>    skipTo: function(ch) {<tr><td><a id="l6028"></a><a href="#l6028">6028</a><td>      var found = this.string.indexOf(ch, this.pos);<tr><td><a id="l6029"></a><a href="#l6029">6029</a><td>      if (found &gt; -1) {this.pos = found; return true;}<tr><td><a id="l6030"></a><a href="#l6030">6030</a><td>    },<tr><td><a id="l6031"></a><a href="#l6031">6031</a><td>    backUp: function(n) {this.pos -= n;},<tr><td><a id="l6032"></a><a href="#l6032">6032</a><td>    column: function() {<tr><td><a id="l6033"></a><a href="#l6033">6033</a><td>      if (this.lastColumnPos &lt; this.start) {<tr><td><a id="l6034"></a><a href="#l6034">6034</a><td>        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);<tr><td><a id="l6035"></a><a href="#l6035">6035</a><td>        this.lastColumnPos = this.start;<tr><td><a id="l6036"></a><a href="#l6036">6036</a><td>      }<tr><td><a id="l6037"></a><a href="#l6037">6037</a><td>      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);<tr><td><a id="l6038"></a><a href="#l6038">6038</a><td>    },<tr><td><a id="l6039"></a><a href="#l6039">6039</a><td>    indentation: function() {<tr><td><a id="l6040"></a><a href="#l6040">6040</a><td>      return countColumn(this.string, null, this.tabSize) -<tr><td><a id="l6041"></a><a href="#l6041">6041</a><td>        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);<tr><td><a id="l6042"></a><a href="#l6042">6042</a><td>    },<tr><td><a id="l6043"></a><a href="#l6043">6043</a><td>    match: function(pattern, consume, caseInsensitive) {<tr><td><a id="l6044"></a><a href="#l6044">6044</a><td>      if (typeof pattern == &quot;string&quot;) {<tr><td><a id="l6045"></a><a href="#l6045">6045</a><td>        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};<tr><td><a id="l6046"></a><a href="#l6046">6046</a><td>        var substr = this.string.substr(this.pos, pattern.length);<tr><td><a id="l6047"></a><a href="#l6047">6047</a><td>        if (cased(substr) == cased(pattern)) {<tr><td><a id="l6048"></a><a href="#l6048">6048</a><td>          if (consume !== false) this.pos += pattern.length;<tr><td><a id="l6049"></a><a href="#l6049">6049</a><td>          return true;<tr><td><a id="l6050"></a><a href="#l6050">6050</a><td>        }<tr><td><a id="l6051"></a><a href="#l6051">6051</a><td>      } else {<tr><td><a id="l6052"></a><a href="#l6052">6052</a><td>        var match = this.string.slice(this.pos).match(pattern);<tr><td><a id="l6053"></a><a href="#l6053">6053</a><td>        if (match &amp;&amp; match.index &gt; 0) return null;<tr><td><a id="l6054"></a><a href="#l6054">6054</a><td>        if (match &amp;&amp; consume !== false) this.pos += match[0].length;<tr><td><a id="l6055"></a><a href="#l6055">6055</a><td>        return match;<tr><td><a id="l6056"></a><a href="#l6056">6056</a><td>      }<tr><td><a id="l6057"></a><a href="#l6057">6057</a><td>    },<tr><td><a id="l6058"></a><a href="#l6058">6058</a><td>    current: function(){return this.string.slice(this.start, this.pos);},<tr><td><a id="l6059"></a><a href="#l6059">6059</a><td>    hideFirstChars: function(n, inner) {<tr><td><a id="l6060"></a><a href="#l6060">6060</a><td>      this.lineStart += n;<tr><td><a id="l6061"></a><a href="#l6061">6061</a><td>      try { return inner(); }<tr><td><a id="l6062"></a><a href="#l6062">6062</a><td>      finally { this.lineStart -= n; }<tr><td><a id="l6063"></a><a href="#l6063">6063</a><td>    }<tr><td><a id="l6064"></a><a href="#l6064">6064</a><td>  };<tr><td><a id="l6065"></a><a href="#l6065">6065</a><td><tr><td><a id="l6066"></a><a href="#l6066">6066</a><td>  // TEXTMARKERS<tr><td><a id="l6067"></a><a href="#l6067">6067</a><td><tr><td><a id="l6068"></a><a href="#l6068">6068</a><td>  // Created with markText and setBookmark methods. A TextMarker is a<tr><td><a id="l6069"></a><a href="#l6069">6069</a><td>  // handle that can be used to clear or find a marked position in the<tr><td><a id="l6070"></a><a href="#l6070">6070</a><td>  // document. Line objects hold arrays (markedSpans) containing<tr><td><a id="l6071"></a><a href="#l6071">6071</a><td>  // {from, to, marker} object pointing to such marker objects, and<tr><td><a id="l6072"></a><a href="#l6072">6072</a><td>  // indicating that such a marker is present on that line. Multiple<tr><td><a id="l6073"></a><a href="#l6073">6073</a><td>  // lines may point to the same marker when it spans across lines.<tr><td><a id="l6074"></a><a href="#l6074">6074</a><td>  // The spans will have null for their from/to properties when the<tr><td><a id="l6075"></a><a href="#l6075">6075</a><td>  // marker continues beyond the start/end of the line. Markers have<tr><td><a id="l6076"></a><a href="#l6076">6076</a><td>  // links back to the lines they currently touch.<tr><td><a id="l6077"></a><a href="#l6077">6077</a><td><tr><td><a id="l6078"></a><a href="#l6078">6078</a><td>  var nextMarkerId = 0;<tr><td><a id="l6079"></a><a href="#l6079">6079</a><td><tr><td><a id="l6080"></a><a href="#l6080">6080</a><td>  var TextMarker = CodeMirror.TextMarker = function(doc, type) {<tr><td><a id="l6081"></a><a href="#l6081">6081</a><td>    this.lines = [];<tr><td><a id="l6082"></a><a href="#l6082">6082</a><td>    this.type = type;<tr><td><a id="l6083"></a><a href="#l6083">6083</a><td>    this.doc = doc;<tr><td><a id="l6084"></a><a href="#l6084">6084</a><td>    this.id = ++nextMarkerId;<tr><td><a id="l6085"></a><a href="#l6085">6085</a><td>  };<tr><td><a id="l6086"></a><a href="#l6086">6086</a><td>  eventMixin(TextMarker);<tr><td><a id="l6087"></a><a href="#l6087">6087</a><td><tr><td><a id="l6088"></a><a href="#l6088">6088</a><td>  // Clear the marker.<tr><td><a id="l6089"></a><a href="#l6089">6089</a><td>  TextMarker.prototype.clear = function() {<tr><td><a id="l6090"></a><a href="#l6090">6090</a><td>    if (this.explicitlyCleared) return;<tr><td><a id="l6091"></a><a href="#l6091">6091</a><td>    var cm = this.doc.cm, withOp = cm &amp;&amp; !cm.curOp;<tr><td><a id="l6092"></a><a href="#l6092">6092</a><td>    if (withOp) startOperation(cm);<tr><td><a id="l6093"></a><a href="#l6093">6093</a><td>    if (hasHandler(this, &quot;clear&quot;)) {<tr><td><a id="l6094"></a><a href="#l6094">6094</a><td>      var found = this.find();<tr><td><a id="l6095"></a><a href="#l6095">6095</a><td>      if (found) signalLater(this, &quot;clear&quot;, found.from, found.to);<tr><td><a id="l6096"></a><a href="#l6096">6096</a><td>    }<tr><td><a id="l6097"></a><a href="#l6097">6097</a><td>    var min = null, max = null;<tr><td><a id="l6098"></a><a href="#l6098">6098</a><td>    for (var i = 0; i &lt; this.lines.length; ++i) {<tr><td><a id="l6099"></a><a href="#l6099">6099</a><td>      var line = this.lines[i];<tr><td><a id="l6100"></a><a href="#l6100">6100</a><td>      var span = getMarkedSpanFor(line.markedSpans, this);<tr><td><a id="l6101"></a><a href="#l6101">6101</a><td>      if (cm &amp;&amp; !this.collapsed) regLineChange(cm, lineNo(line), &quot;text&quot;);<tr><td><a id="l6102"></a><a href="#l6102">6102</a><td>      else if (cm) {<tr><td><a id="l6103"></a><a href="#l6103">6103</a><td>        if (span.to != null) max = lineNo(line);<tr><td><a id="l6104"></a><a href="#l6104">6104</a><td>        if (span.from != null) min = lineNo(line);<tr><td><a id="l6105"></a><a href="#l6105">6105</a><td>      }<tr><td><a id="l6106"></a><a href="#l6106">6106</a><td>      line.markedSpans = removeMarkedSpan(line.markedSpans, span);<tr><td><a id="l6107"></a><a href="#l6107">6107</a><td>      if (span.from == null &amp;&amp; this.collapsed &amp;&amp; !lineIsHidden(this.doc, line) &amp;&amp; cm)<tr><td><a id="l6108"></a><a href="#l6108">6108</a><td>        updateLineHeight(line, textHeight(cm.display));<tr><td><a id="l6109"></a><a href="#l6109">6109</a><td>    }<tr><td><a id="l6110"></a><a href="#l6110">6110</a><td>    if (cm &amp;&amp; this.collapsed &amp;&amp; !cm.options.lineWrapping) for (var i = 0; i &lt; this.lines.length; ++i) {<tr><td><a id="l6111"></a><a href="#l6111">6111</a><td>      var visual = visualLine(this.lines[i]), len = lineLength(visual);<tr><td><a id="l6112"></a><a href="#l6112">6112</a><td>      if (len &gt; cm.display.maxLineLength) {<tr><td><a id="l6113"></a><a href="#l6113">6113</a><td>        cm.display.maxLine = visual;<tr><td><a id="l6114"></a><a href="#l6114">6114</a><td>        cm.display.maxLineLength = len;<tr><td><a id="l6115"></a><a href="#l6115">6115</a><td>        cm.display.maxLineChanged = true;<tr><td><a id="l6116"></a><a href="#l6116">6116</a><td>      }<tr><td><a id="l6117"></a><a href="#l6117">6117</a><td>    }<tr><td><a id="l6118"></a><a href="#l6118">6118</a><td><tr><td><a id="l6119"></a><a href="#l6119">6119</a><td>    if (min != null &amp;&amp; cm &amp;&amp; this.collapsed) regChange(cm, min, max + 1);<tr><td><a id="l6120"></a><a href="#l6120">6120</a><td>    this.lines.length = 0;<tr><td><a id="l6121"></a><a href="#l6121">6121</a><td>    this.explicitlyCleared = true;<tr><td><a id="l6122"></a><a href="#l6122">6122</a><td>    if (this.atomic &amp;&amp; this.doc.cantEdit) {<tr><td><a id="l6123"></a><a href="#l6123">6123</a><td>      this.doc.cantEdit = false;<tr><td><a id="l6124"></a><a href="#l6124">6124</a><td>      if (cm) reCheckSelection(cm.doc);<tr><td><a id="l6125"></a><a href="#l6125">6125</a><td>    }<tr><td><a id="l6126"></a><a href="#l6126">6126</a><td>    if (cm) signalLater(cm, &quot;markerCleared&quot;, cm, this);<tr><td><a id="l6127"></a><a href="#l6127">6127</a><td>    if (withOp) endOperation(cm);<tr><td><a id="l6128"></a><a href="#l6128">6128</a><td>    if (this.parent) this.parent.clear();<tr><td><a id="l6129"></a><a href="#l6129">6129</a><td>  };<tr><td><a id="l6130"></a><a href="#l6130">6130</a><td><tr><td><a id="l6131"></a><a href="#l6131">6131</a><td>  // Find the position of the marker in the document. Returns a {from,<tr><td><a id="l6132"></a><a href="#l6132">6132</a><td>  // to} object by default. Side can be passed to get a specific side<tr><td><a id="l6133"></a><a href="#l6133">6133</a><td>  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the<tr><td><a id="l6134"></a><a href="#l6134">6134</a><td>  // Pos objects returned contain a line object, rather than a line<tr><td><a id="l6135"></a><a href="#l6135">6135</a><td>  // number (used to prevent looking up the same line twice).<tr><td><a id="l6136"></a><a href="#l6136">6136</a><td>  TextMarker.prototype.find = function(side, lineObj) {<tr><td><a id="l6137"></a><a href="#l6137">6137</a><td>    if (side == null &amp;&amp; this.type == &quot;bookmark&quot;) side = 1;<tr><td><a id="l6138"></a><a href="#l6138">6138</a><td>    var from, to;<tr><td><a id="l6139"></a><a href="#l6139">6139</a><td>    for (var i = 0; i &lt; this.lines.length; ++i) {<tr><td><a id="l6140"></a><a href="#l6140">6140</a><td>      var line = this.lines[i];<tr><td><a id="l6141"></a><a href="#l6141">6141</a><td>      var span = getMarkedSpanFor(line.markedSpans, this);<tr><td><a id="l6142"></a><a href="#l6142">6142</a><td>      if (span.from != null) {<tr><td><a id="l6143"></a><a href="#l6143">6143</a><td>        from = Pos(lineObj ? line : lineNo(line), span.from);<tr><td><a id="l6144"></a><a href="#l6144">6144</a><td>        if (side == -1) return from;<tr><td><a id="l6145"></a><a href="#l6145">6145</a><td>      }<tr><td><a id="l6146"></a><a href="#l6146">6146</a><td>      if (span.to != null) {<tr><td><a id="l6147"></a><a href="#l6147">6147</a><td>        to = Pos(lineObj ? line : lineNo(line), span.to);<tr><td><a id="l6148"></a><a href="#l6148">6148</a><td>        if (side == 1) return to;<tr><td><a id="l6149"></a><a href="#l6149">6149</a><td>      }<tr><td><a id="l6150"></a><a href="#l6150">6150</a><td>    }<tr><td><a id="l6151"></a><a href="#l6151">6151</a><td>    return from &amp;&amp; {from: from, to: to};<tr><td><a id="l6152"></a><a href="#l6152">6152</a><td>  };<tr><td><a id="l6153"></a><a href="#l6153">6153</a><td><tr><td><a id="l6154"></a><a href="#l6154">6154</a><td>  // Signals that the marker&#39;s widget changed, and surrounding layout<tr><td><a id="l6155"></a><a href="#l6155">6155</a><td>  // should be recomputed.<tr><td><a id="l6156"></a><a href="#l6156">6156</a><td>  TextMarker.prototype.changed = function() {<tr><td><a id="l6157"></a><a href="#l6157">6157</a><td>    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;<tr><td><a id="l6158"></a><a href="#l6158">6158</a><td>    if (!pos || !cm) return;<tr><td><a id="l6159"></a><a href="#l6159">6159</a><td>    runInOp(cm, function() {<tr><td><a id="l6160"></a><a href="#l6160">6160</a><td>      var line = pos.line, lineN = lineNo(pos.line);<tr><td><a id="l6161"></a><a href="#l6161">6161</a><td>      var view = findViewForLine(cm, lineN);<tr><td><a id="l6162"></a><a href="#l6162">6162</a><td>      if (view) {<tr><td><a id="l6163"></a><a href="#l6163">6163</a><td>        clearLineMeasurementCacheFor(view);<tr><td><a id="l6164"></a><a href="#l6164">6164</a><td>        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;<tr><td><a id="l6165"></a><a href="#l6165">6165</a><td>      }<tr><td><a id="l6166"></a><a href="#l6166">6166</a><td>      cm.curOp.updateMaxLine = true;<tr><td><a id="l6167"></a><a href="#l6167">6167</a><td>      if (!lineIsHidden(widget.doc, line) &amp;&amp; widget.height != null) {<tr><td><a id="l6168"></a><a href="#l6168">6168</a><td>        var oldHeight = widget.height;<tr><td><a id="l6169"></a><a href="#l6169">6169</a><td>        widget.height = null;<tr><td><a id="l6170"></a><a href="#l6170">6170</a><td>        var dHeight = widgetHeight(widget) - oldHeight;<tr><td><a id="l6171"></a><a href="#l6171">6171</a><td>        if (dHeight)<tr><td><a id="l6172"></a><a href="#l6172">6172</a><td>          updateLineHeight(line, line.height + dHeight);<tr><td><a id="l6173"></a><a href="#l6173">6173</a><td>      }<tr><td><a id="l6174"></a><a href="#l6174">6174</a><td>    });<tr><td><a id="l6175"></a><a href="#l6175">6175</a><td>  };<tr><td><a id="l6176"></a><a href="#l6176">6176</a><td><tr><td><a id="l6177"></a><a href="#l6177">6177</a><td>  TextMarker.prototype.attachLine = function(line) {<tr><td><a id="l6178"></a><a href="#l6178">6178</a><td>    if (!this.lines.length &amp;&amp; this.doc.cm) {<tr><td><a id="l6179"></a><a href="#l6179">6179</a><td>      var op = this.doc.cm.curOp;<tr><td><a id="l6180"></a><a href="#l6180">6180</a><td>      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)<tr><td><a id="l6181"></a><a href="#l6181">6181</a><td>        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);<tr><td><a id="l6182"></a><a href="#l6182">6182</a><td>    }<tr><td><a id="l6183"></a><a href="#l6183">6183</a><td>    this.lines.push(line);<tr><td><a id="l6184"></a><a href="#l6184">6184</a><td>  };<tr><td><a id="l6185"></a><a href="#l6185">6185</a><td>  TextMarker.prototype.detachLine = function(line) {<tr><td><a id="l6186"></a><a href="#l6186">6186</a><td>    this.lines.splice(indexOf(this.lines, line), 1);<tr><td><a id="l6187"></a><a href="#l6187">6187</a><td>    if (!this.lines.length &amp;&amp; this.doc.cm) {<tr><td><a id="l6188"></a><a href="#l6188">6188</a><td>      var op = this.doc.cm.curOp;<tr><td><a id="l6189"></a><a href="#l6189">6189</a><td>      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);<tr><td><a id="l6190"></a><a href="#l6190">6190</a><td>    }<tr><td><a id="l6191"></a><a href="#l6191">6191</a><td>  };<tr><td><a id="l6192"></a><a href="#l6192">6192</a><td><tr><td><a id="l6193"></a><a href="#l6193">6193</a><td>  // Collapsed markers have unique ids, in order to be able to order<tr><td><a id="l6194"></a><a href="#l6194">6194</a><td>  // them, which is needed for uniquely determining an outer marker<tr><td><a id="l6195"></a><a href="#l6195">6195</a><td>  // when they overlap (they may nest, but not partially overlap).<tr><td><a id="l6196"></a><a href="#l6196">6196</a><td>  var nextMarkerId = 0;<tr><td><a id="l6197"></a><a href="#l6197">6197</a><td><tr><td><a id="l6198"></a><a href="#l6198">6198</a><td>  // Create a marker, wire it up to the right lines, and<tr><td><a id="l6199"></a><a href="#l6199">6199</a><td>  function markText(doc, from, to, options, type) {<tr><td><a id="l6200"></a><a href="#l6200">6200</a><td>    // Shared markers (across linked documents) are handled separately<tr><td><a id="l6201"></a><a href="#l6201">6201</a><td>    // (markTextShared will call out to this again, once per<tr><td><a id="l6202"></a><a href="#l6202">6202</a><td>    // document).<tr><td><a id="l6203"></a><a href="#l6203">6203</a><td>    if (options &amp;&amp; options.shared) return markTextShared(doc, from, to, options, type);<tr><td><a id="l6204"></a><a href="#l6204">6204</a><td>    // Ensure we are in an operation.<tr><td><a id="l6205"></a><a href="#l6205">6205</a><td>    if (doc.cm &amp;&amp; !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);<tr><td><a id="l6206"></a><a href="#l6206">6206</a><td><tr><td><a id="l6207"></a><a href="#l6207">6207</a><td>    var marker = new TextMarker(doc, type), diff = cmp(from, to);<tr><td><a id="l6208"></a><a href="#l6208">6208</a><td>    if (options) copyObj(options, marker, false);<tr><td><a id="l6209"></a><a href="#l6209">6209</a><td>    // Don&#39;t connect empty markers unless clearWhenEmpty is false<tr><td><a id="l6210"></a><a href="#l6210">6210</a><td>    if (diff &gt; 0 || diff == 0 &amp;&amp; marker.clearWhenEmpty !== false)<tr><td><a id="l6211"></a><a href="#l6211">6211</a><td>      return marker;<tr><td><a id="l6212"></a><a href="#l6212">6212</a><td>    if (marker.replacedWith) {<tr><td><a id="l6213"></a><a href="#l6213">6213</a><td>      // Showing up as a widget implies collapsed (widget replaces text)<tr><td><a id="l6214"></a><a href="#l6214">6214</a><td>      marker.collapsed = true;<tr><td><a id="l6215"></a><a href="#l6215">6215</a><td>      marker.widgetNode = elt(&quot;span&quot;, [marker.replacedWith], &quot;CodeMirror-widget&quot;);<tr><td><a id="l6216"></a><a href="#l6216">6216</a><td>      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(&quot;cm-ignore-events&quot;, &quot;true&quot;);<tr><td><a id="l6217"></a><a href="#l6217">6217</a><td>      if (options.insertLeft) marker.widgetNode.insertLeft = true;<tr><td><a id="l6218"></a><a href="#l6218">6218</a><td>    }<tr><td><a id="l6219"></a><a href="#l6219">6219</a><td>    if (marker.collapsed) {<tr><td><a id="l6220"></a><a href="#l6220">6220</a><td>      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||<tr><td><a id="l6221"></a><a href="#l6221">6221</a><td>          from.line != to.line &amp;&amp; conflictingCollapsedRange(doc, to.line, from, to, marker))<tr><td><a id="l6222"></a><a href="#l6222">6222</a><td>        throw new Error(&quot;Inserting collapsed marker partially overlapping an existing one&quot;);<tr><td><a id="l6223"></a><a href="#l6223">6223</a><td>      sawCollapsedSpans = true;<tr><td><a id="l6224"></a><a href="#l6224">6224</a><td>    }<tr><td><a id="l6225"></a><a href="#l6225">6225</a><td><tr><td><a id="l6226"></a><a href="#l6226">6226</a><td>    if (marker.addToHistory)<tr><td><a id="l6227"></a><a href="#l6227">6227</a><td>      addChangeToHistory(doc, {from: from, to: to, origin: &quot;markText&quot;}, doc.sel, NaN);<tr><td><a id="l6228"></a><a href="#l6228">6228</a><td><tr><td><a id="l6229"></a><a href="#l6229">6229</a><td>    var curLine = from.line, cm = doc.cm, updateMaxLine;<tr><td><a id="l6230"></a><a href="#l6230">6230</a><td>    doc.iter(curLine, to.line + 1, function(line) {<tr><td><a id="l6231"></a><a href="#l6231">6231</a><td>      if (cm &amp;&amp; marker.collapsed &amp;&amp; !cm.options.lineWrapping &amp;&amp; visualLine(line) == cm.display.maxLine)<tr><td><a id="l6232"></a><a href="#l6232">6232</a><td>        updateMaxLine = true;<tr><td><a id="l6233"></a><a href="#l6233">6233</a><td>      if (marker.collapsed &amp;&amp; curLine != from.line) updateLineHeight(line, 0);<tr><td><a id="l6234"></a><a href="#l6234">6234</a><td>      addMarkedSpan(line, new MarkedSpan(marker,<tr><td><a id="l6235"></a><a href="#l6235">6235</a><td>                                         curLine == from.line ? from.ch : null,<tr><td><a id="l6236"></a><a href="#l6236">6236</a><td>                                         curLine == to.line ? to.ch : null));<tr><td><a id="l6237"></a><a href="#l6237">6237</a><td>      ++curLine;<tr><td><a id="l6238"></a><a href="#l6238">6238</a><td>    });<tr><td><a id="l6239"></a><a href="#l6239">6239</a><td>    // lineIsHidden depends on the presence of the spans, so needs a second pass<tr><td><a id="l6240"></a><a href="#l6240">6240</a><td>    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {<tr><td><a id="l6241"></a><a href="#l6241">6241</a><td>      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);<tr><td><a id="l6242"></a><a href="#l6242">6242</a><td>    });<tr><td><a id="l6243"></a><a href="#l6243">6243</a><td><tr><td><a id="l6244"></a><a href="#l6244">6244</a><td>    if (marker.clearOnEnter) on(marker, &quot;beforeCursorEnter&quot;, function() { marker.clear(); });<tr><td><a id="l6245"></a><a href="#l6245">6245</a><td><tr><td><a id="l6246"></a><a href="#l6246">6246</a><td>    if (marker.readOnly) {<tr><td><a id="l6247"></a><a href="#l6247">6247</a><td>      sawReadOnlySpans = true;<tr><td><a id="l6248"></a><a href="#l6248">6248</a><td>      if (doc.history.done.length || doc.history.undone.length)<tr><td><a id="l6249"></a><a href="#l6249">6249</a><td>        doc.clearHistory();<tr><td><a id="l6250"></a><a href="#l6250">6250</a><td>    }<tr><td><a id="l6251"></a><a href="#l6251">6251</a><td>    if (marker.collapsed) {<tr><td><a id="l6252"></a><a href="#l6252">6252</a><td>      marker.id = ++nextMarkerId;<tr><td><a id="l6253"></a><a href="#l6253">6253</a><td>      marker.atomic = true;<tr><td><a id="l6254"></a><a href="#l6254">6254</a><td>    }<tr><td><a id="l6255"></a><a href="#l6255">6255</a><td>    if (cm) {<tr><td><a id="l6256"></a><a href="#l6256">6256</a><td>      // Sync editor state<tr><td><a id="l6257"></a><a href="#l6257">6257</a><td>      if (updateMaxLine) cm.curOp.updateMaxLine = true;<tr><td><a id="l6258"></a><a href="#l6258">6258</a><td>      if (marker.collapsed)<tr><td><a id="l6259"></a><a href="#l6259">6259</a><td>        regChange(cm, from.line, to.line + 1);<tr><td><a id="l6260"></a><a href="#l6260">6260</a><td>      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)<tr><td><a id="l6261"></a><a href="#l6261">6261</a><td>        for (var i = from.line; i &lt;= to.line; i++) regLineChange(cm, i, &quot;text&quot;);<tr><td><a id="l6262"></a><a href="#l6262">6262</a><td>      if (marker.atomic) reCheckSelection(cm.doc);<tr><td><a id="l6263"></a><a href="#l6263">6263</a><td>      signalLater(cm, &quot;markerAdded&quot;, cm, marker);<tr><td><a id="l6264"></a><a href="#l6264">6264</a><td>    }<tr><td><a id="l6265"></a><a href="#l6265">6265</a><td>    return marker;<tr><td><a id="l6266"></a><a href="#l6266">6266</a><td>  }<tr><td><a id="l6267"></a><a href="#l6267">6267</a><td><tr><td><a id="l6268"></a><a href="#l6268">6268</a><td>  // SHARED TEXTMARKERS<tr><td><a id="l6269"></a><a href="#l6269">6269</a><td><tr><td><a id="l6270"></a><a href="#l6270">6270</a><td>  // A shared marker spans multiple linked documents. It is<tr><td><a id="l6271"></a><a href="#l6271">6271</a><td>  // implemented as a meta-marker-object controlling multiple normal<tr><td><a id="l6272"></a><a href="#l6272">6272</a><td>  // markers.<tr><td><a id="l6273"></a><a href="#l6273">6273</a><td>  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {<tr><td><a id="l6274"></a><a href="#l6274">6274</a><td>    this.markers = markers;<tr><td><a id="l6275"></a><a href="#l6275">6275</a><td>    this.primary = primary;<tr><td><a id="l6276"></a><a href="#l6276">6276</a><td>    for (var i = 0; i &lt; markers.length; ++i)<tr><td><a id="l6277"></a><a href="#l6277">6277</a><td>      markers[i].parent = this;<tr><td><a id="l6278"></a><a href="#l6278">6278</a><td>  };<tr><td><a id="l6279"></a><a href="#l6279">6279</a><td>  eventMixin(SharedTextMarker);<tr><td><a id="l6280"></a><a href="#l6280">6280</a><td><tr><td><a id="l6281"></a><a href="#l6281">6281</a><td>  SharedTextMarker.prototype.clear = function() {<tr><td><a id="l6282"></a><a href="#l6282">6282</a><td>    if (this.explicitlyCleared) return;<tr><td><a id="l6283"></a><a href="#l6283">6283</a><td>    this.explicitlyCleared = true;<tr><td><a id="l6284"></a><a href="#l6284">6284</a><td>    for (var i = 0; i &lt; this.markers.length; ++i)<tr><td><a id="l6285"></a><a href="#l6285">6285</a><td>      this.markers[i].clear();<tr><td><a id="l6286"></a><a href="#l6286">6286</a><td>    signalLater(this, &quot;clear&quot;);<tr><td><a id="l6287"></a><a href="#l6287">6287</a><td>  };<tr><td><a id="l6288"></a><a href="#l6288">6288</a><td>  SharedTextMarker.prototype.find = function(side, lineObj) {<tr><td><a id="l6289"></a><a href="#l6289">6289</a><td>    return this.primary.find(side, lineObj);<tr><td><a id="l6290"></a><a href="#l6290">6290</a><td>  };<tr><td><a id="l6291"></a><a href="#l6291">6291</a><td><tr><td><a id="l6292"></a><a href="#l6292">6292</a><td>  function markTextShared(doc, from, to, options, type) {<tr><td><a id="l6293"></a><a href="#l6293">6293</a><td>    options = copyObj(options);<tr><td><a id="l6294"></a><a href="#l6294">6294</a><td>    options.shared = false;<tr><td><a id="l6295"></a><a href="#l6295">6295</a><td>    var markers = [markText(doc, from, to, options, type)], primary = markers[0];<tr><td><a id="l6296"></a><a href="#l6296">6296</a><td>    var widget = options.widgetNode;<tr><td><a id="l6297"></a><a href="#l6297">6297</a><td>    linkedDocs(doc, function(doc) {<tr><td><a id="l6298"></a><a href="#l6298">6298</a><td>      if (widget) options.widgetNode = widget.cloneNode(true);<tr><td><a id="l6299"></a><a href="#l6299">6299</a><td>      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));<tr><td><a id="l6300"></a><a href="#l6300">6300</a><td>      for (var i = 0; i &lt; doc.linked.length; ++i)<tr><td><a id="l6301"></a><a href="#l6301">6301</a><td>        if (doc.linked[i].isParent) return;<tr><td><a id="l6302"></a><a href="#l6302">6302</a><td>      primary = lst(markers);<tr><td><a id="l6303"></a><a href="#l6303">6303</a><td>    });<tr><td><a id="l6304"></a><a href="#l6304">6304</a><td>    return new SharedTextMarker(markers, primary);<tr><td><a id="l6305"></a><a href="#l6305">6305</a><td>  }<tr><td><a id="l6306"></a><a href="#l6306">6306</a><td><tr><td><a id="l6307"></a><a href="#l6307">6307</a><td>  function findSharedMarkers(doc) {<tr><td><a id="l6308"></a><a href="#l6308">6308</a><td>    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),<tr><td><a id="l6309"></a><a href="#l6309">6309</a><td>                         function(m) { return m.parent; });<tr><td><a id="l6310"></a><a href="#l6310">6310</a><td>  }<tr><td><a id="l6311"></a><a href="#l6311">6311</a><td><tr><td><a id="l6312"></a><a href="#l6312">6312</a><td>  function copySharedMarkers(doc, markers) {<tr><td><a id="l6313"></a><a href="#l6313">6313</a><td>    for (var i = 0; i &lt; markers.length; i++) {<tr><td><a id="l6314"></a><a href="#l6314">6314</a><td>      var marker = markers[i], pos = marker.find();<tr><td><a id="l6315"></a><a href="#l6315">6315</a><td>      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);<tr><td><a id="l6316"></a><a href="#l6316">6316</a><td>      if (cmp(mFrom, mTo)) {<tr><td><a id="l6317"></a><a href="#l6317">6317</a><td>        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);<tr><td><a id="l6318"></a><a href="#l6318">6318</a><td>        marker.markers.push(subMark);<tr><td><a id="l6319"></a><a href="#l6319">6319</a><td>        subMark.parent = marker;<tr><td><a id="l6320"></a><a href="#l6320">6320</a><td>      }<tr><td><a id="l6321"></a><a href="#l6321">6321</a><td>    }<tr><td><a id="l6322"></a><a href="#l6322">6322</a><td>  }<tr><td><a id="l6323"></a><a href="#l6323">6323</a><td><tr><td><a id="l6324"></a><a href="#l6324">6324</a><td>  function detachSharedMarkers(markers) {<tr><td><a id="l6325"></a><a href="#l6325">6325</a><td>    for (var i = 0; i &lt; markers.length; i++) {<tr><td><a id="l6326"></a><a href="#l6326">6326</a><td>      var marker = markers[i], linked = [marker.primary.doc];;<tr><td><a id="l6327"></a><a href="#l6327">6327</a><td>      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });<tr><td><a id="l6328"></a><a href="#l6328">6328</a><td>      for (var j = 0; j &lt; marker.markers.length; j++) {<tr><td><a id="l6329"></a><a href="#l6329">6329</a><td>        var subMarker = marker.markers[j];<tr><td><a id="l6330"></a><a href="#l6330">6330</a><td>        if (indexOf(linked, subMarker.doc) == -1) {<tr><td><a id="l6331"></a><a href="#l6331">6331</a><td>          subMarker.parent = null;<tr><td><a id="l6332"></a><a href="#l6332">6332</a><td>          marker.markers.splice(j--, 1);<tr><td><a id="l6333"></a><a href="#l6333">6333</a><td>        }<tr><td><a id="l6334"></a><a href="#l6334">6334</a><td>      }<tr><td><a id="l6335"></a><a href="#l6335">6335</a><td>    }<tr><td><a id="l6336"></a><a href="#l6336">6336</a><td>  }<tr><td><a id="l6337"></a><a href="#l6337">6337</a><td><tr><td><a id="l6338"></a><a href="#l6338">6338</a><td>  // TEXTMARKER SPANS<tr><td><a id="l6339"></a><a href="#l6339">6339</a><td><tr><td><a id="l6340"></a><a href="#l6340">6340</a><td>  function MarkedSpan(marker, from, to) {<tr><td><a id="l6341"></a><a href="#l6341">6341</a><td>    this.marker = marker;<tr><td><a id="l6342"></a><a href="#l6342">6342</a><td>    this.from = from; this.to = to;<tr><td><a id="l6343"></a><a href="#l6343">6343</a><td>  }<tr><td><a id="l6344"></a><a href="#l6344">6344</a><td><tr><td><a id="l6345"></a><a href="#l6345">6345</a><td>  // Search an array of spans for a span matching the given marker.<tr><td><a id="l6346"></a><a href="#l6346">6346</a><td>  function getMarkedSpanFor(spans, marker) {<tr><td><a id="l6347"></a><a href="#l6347">6347</a><td>    if (spans) for (var i = 0; i &lt; spans.length; ++i) {<tr><td><a id="l6348"></a><a href="#l6348">6348</a><td>      var span = spans[i];<tr><td><a id="l6349"></a><a href="#l6349">6349</a><td>      if (span.marker == marker) return span;<tr><td><a id="l6350"></a><a href="#l6350">6350</a><td>    }<tr><td><a id="l6351"></a><a href="#l6351">6351</a><td>  }<tr><td><a id="l6352"></a><a href="#l6352">6352</a><td>  // Remove a span from an array, returning undefined if no spans are<tr><td><a id="l6353"></a><a href="#l6353">6353</a><td>  // left (we don&#39;t store arrays for lines without spans).<tr><td><a id="l6354"></a><a href="#l6354">6354</a><td>  function removeMarkedSpan(spans, span) {<tr><td><a id="l6355"></a><a href="#l6355">6355</a><td>    for (var r, i = 0; i &lt; spans.length; ++i)<tr><td><a id="l6356"></a><a href="#l6356">6356</a><td>      if (spans[i] != span) (r || (r = [])).push(spans[i]);<tr><td><a id="l6357"></a><a href="#l6357">6357</a><td>    return r;<tr><td><a id="l6358"></a><a href="#l6358">6358</a><td>  }<tr><td><a id="l6359"></a><a href="#l6359">6359</a><td>  // Add a span to a line.<tr><td><a id="l6360"></a><a href="#l6360">6360</a><td>  function addMarkedSpan(line, span) {<tr><td><a id="l6361"></a><a href="#l6361">6361</a><td>    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];<tr><td><a id="l6362"></a><a href="#l6362">6362</a><td>    span.marker.attachLine(line);<tr><td><a id="l6363"></a><a href="#l6363">6363</a><td>  }<tr><td><a id="l6364"></a><a href="#l6364">6364</a><td><tr><td><a id="l6365"></a><a href="#l6365">6365</a><td>  // Used for the algorithm that adjusts markers for a change in the<tr><td><a id="l6366"></a><a href="#l6366">6366</a><td>  // document. These functions cut an array of spans at a given<tr><td><a id="l6367"></a><a href="#l6367">6367</a><td>  // character position, returning an array of remaining chunks (or<tr><td><a id="l6368"></a><a href="#l6368">6368</a><td>  // undefined if nothing remains).<tr><td><a id="l6369"></a><a href="#l6369">6369</a><td>  function markedSpansBefore(old, startCh, isInsert) {<tr><td><a id="l6370"></a><a href="#l6370">6370</a><td>    if (old) for (var i = 0, nw; i &lt; old.length; ++i) {<tr><td><a id="l6371"></a><a href="#l6371">6371</a><td>      var span = old[i], marker = span.marker;<tr><td><a id="l6372"></a><a href="#l6372">6372</a><td>      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from &lt;= startCh : span.from &lt; startCh);<tr><td><a id="l6373"></a><a href="#l6373">6373</a><td>      if (startsBefore || span.from == startCh &amp;&amp; marker.type == &quot;bookmark&quot; &amp;&amp; (!isInsert || !span.marker.insertLeft)) {<tr><td><a id="l6374"></a><a href="#l6374">6374</a><td>        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to &gt;= startCh : span.to &gt; startCh);<tr><td><a id="l6375"></a><a href="#l6375">6375</a><td>        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));<tr><td><a id="l6376"></a><a href="#l6376">6376</a><td>      }<tr><td><a id="l6377"></a><a href="#l6377">6377</a><td>    }<tr><td><a id="l6378"></a><a href="#l6378">6378</a><td>    return nw;<tr><td><a id="l6379"></a><a href="#l6379">6379</a><td>  }<tr><td><a id="l6380"></a><a href="#l6380">6380</a><td>  function markedSpansAfter(old, endCh, isInsert) {<tr><td><a id="l6381"></a><a href="#l6381">6381</a><td>    if (old) for (var i = 0, nw; i &lt; old.length; ++i) {<tr><td><a id="l6382"></a><a href="#l6382">6382</a><td>      var span = old[i], marker = span.marker;<tr><td><a id="l6383"></a><a href="#l6383">6383</a><td>      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to &gt;= endCh : span.to &gt; endCh);<tr><td><a id="l6384"></a><a href="#l6384">6384</a><td>      if (endsAfter || span.from == endCh &amp;&amp; marker.type == &quot;bookmark&quot; &amp;&amp; (!isInsert || span.marker.insertLeft)) {<tr><td><a id="l6385"></a><a href="#l6385">6385</a><td>        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from &lt;= endCh : span.from &lt; endCh);<tr><td><a id="l6386"></a><a href="#l6386">6386</a><td>        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,<tr><td><a id="l6387"></a><a href="#l6387">6387</a><td>                                              span.to == null ? null : span.to - endCh));<tr><td><a id="l6388"></a><a href="#l6388">6388</a><td>      }<tr><td><a id="l6389"></a><a href="#l6389">6389</a><td>    }<tr><td><a id="l6390"></a><a href="#l6390">6390</a><td>    return nw;<tr><td><a id="l6391"></a><a href="#l6391">6391</a><td>  }<tr><td><a id="l6392"></a><a href="#l6392">6392</a><td><tr><td><a id="l6393"></a><a href="#l6393">6393</a><td>  // Given a change object, compute the new set of marker spans that<tr><td><a id="l6394"></a><a href="#l6394">6394</a><td>  // cover the line in which the change took place. Removes spans<tr><td><a id="l6395"></a><a href="#l6395">6395</a><td>  // entirely within the change, reconnects spans belonging to the<tr><td><a id="l6396"></a><a href="#l6396">6396</a><td>  // same marker that appear on both sides of the change, and cuts off<tr><td><a id="l6397"></a><a href="#l6397">6397</a><td>  // spans partially within the change. Returns an array of span<tr><td><a id="l6398"></a><a href="#l6398">6398</a><td>  // arrays with one element for each line in (after) the change.<tr><td><a id="l6399"></a><a href="#l6399">6399</a><td>  function stretchSpansOverChange(doc, change) {<tr><td><a id="l6400"></a><a href="#l6400">6400</a><td>    if (change.full) return null;<tr><td><a id="l6401"></a><a href="#l6401">6401</a><td>    var oldFirst = isLine(doc, change.from.line) &amp;&amp; getLine(doc, change.from.line).markedSpans;<tr><td><a id="l6402"></a><a href="#l6402">6402</a><td>    var oldLast = isLine(doc, change.to.line) &amp;&amp; getLine(doc, change.to.line).markedSpans;<tr><td><a id="l6403"></a><a href="#l6403">6403</a><td>    if (!oldFirst &amp;&amp; !oldLast) return null;<tr><td><a id="l6404"></a><a href="#l6404">6404</a><td><tr><td><a id="l6405"></a><a href="#l6405">6405</a><td>    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;<tr><td><a id="l6406"></a><a href="#l6406">6406</a><td>    // Get the spans that &#39;stick out&#39; on both sides<tr><td><a id="l6407"></a><a href="#l6407">6407</a><td>    var first = markedSpansBefore(oldFirst, startCh, isInsert);<tr><td><a id="l6408"></a><a href="#l6408">6408</a><td>    var last = markedSpansAfter(oldLast, endCh, isInsert);<tr><td><a id="l6409"></a><a href="#l6409">6409</a><td><tr><td><a id="l6410"></a><a href="#l6410">6410</a><td>    // Next, merge those two ends<tr><td><a id="l6411"></a><a href="#l6411">6411</a><td>    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);<tr><td><a id="l6412"></a><a href="#l6412">6412</a><td>    if (first) {<tr><td><a id="l6413"></a><a href="#l6413">6413</a><td>      // Fix up .to properties of first<tr><td><a id="l6414"></a><a href="#l6414">6414</a><td>      for (var i = 0; i &lt; first.length; ++i) {<tr><td><a id="l6415"></a><a href="#l6415">6415</a><td>        var span = first[i];<tr><td><a id="l6416"></a><a href="#l6416">6416</a><td>        if (span.to == null) {<tr><td><a id="l6417"></a><a href="#l6417">6417</a><td>          var found = getMarkedSpanFor(last, span.marker);<tr><td><a id="l6418"></a><a href="#l6418">6418</a><td>          if (!found) span.to = startCh;<tr><td><a id="l6419"></a><a href="#l6419">6419</a><td>          else if (sameLine) span.to = found.to == null ? null : found.to + offset;<tr><td><a id="l6420"></a><a href="#l6420">6420</a><td>        }<tr><td><a id="l6421"></a><a href="#l6421">6421</a><td>      }<tr><td><a id="l6422"></a><a href="#l6422">6422</a><td>    }<tr><td><a id="l6423"></a><a href="#l6423">6423</a><td>    if (last) {<tr><td><a id="l6424"></a><a href="#l6424">6424</a><td>      // Fix up .from in last (or move them into first in case of sameLine)<tr><td><a id="l6425"></a><a href="#l6425">6425</a><td>      for (var i = 0; i &lt; last.length; ++i) {<tr><td><a id="l6426"></a><a href="#l6426">6426</a><td>        var span = last[i];<tr><td><a id="l6427"></a><a href="#l6427">6427</a><td>        if (span.to != null) span.to += offset;<tr><td><a id="l6428"></a><a href="#l6428">6428</a><td>        if (span.from == null) {<tr><td><a id="l6429"></a><a href="#l6429">6429</a><td>          var found = getMarkedSpanFor(first, span.marker);<tr><td><a id="l6430"></a><a href="#l6430">6430</a><td>          if (!found) {<tr><td><a id="l6431"></a><a href="#l6431">6431</a><td>            span.from = offset;<tr><td><a id="l6432"></a><a href="#l6432">6432</a><td>            if (sameLine) (first || (first = [])).push(span);<tr><td><a id="l6433"></a><a href="#l6433">6433</a><td>          }<tr><td><a id="l6434"></a><a href="#l6434">6434</a><td>        } else {<tr><td><a id="l6435"></a><a href="#l6435">6435</a><td>          span.from += offset;<tr><td><a id="l6436"></a><a href="#l6436">6436</a><td>          if (sameLine) (first || (first = [])).push(span);<tr><td><a id="l6437"></a><a href="#l6437">6437</a><td>        }<tr><td><a id="l6438"></a><a href="#l6438">6438</a><td>      }<tr><td><a id="l6439"></a><a href="#l6439">6439</a><td>    }<tr><td><a id="l6440"></a><a href="#l6440">6440</a><td>    // Make sure we didn&#39;t create any zero-length spans<tr><td><a id="l6441"></a><a href="#l6441">6441</a><td>    if (first) first = clearEmptySpans(first);<tr><td><a id="l6442"></a><a href="#l6442">6442</a><td>    if (last &amp;&amp; last != first) last = clearEmptySpans(last);<tr><td><a id="l6443"></a><a href="#l6443">6443</a><td><tr><td><a id="l6444"></a><a href="#l6444">6444</a><td>    var newMarkers = [first];<tr><td><a id="l6445"></a><a href="#l6445">6445</a><td>    if (!sameLine) {<tr><td><a id="l6446"></a><a href="#l6446">6446</a><td>      // Fill gap with whole-line-spans<tr><td><a id="l6447"></a><a href="#l6447">6447</a><td>      var gap = change.text.length - 2, gapMarkers;<tr><td><a id="l6448"></a><a href="#l6448">6448</a><td>      if (gap &gt; 0 &amp;&amp; first)<tr><td><a id="l6449"></a><a href="#l6449">6449</a><td>        for (var i = 0; i &lt; first.length; ++i)<tr><td><a id="l6450"></a><a href="#l6450">6450</a><td>          if (first[i].to == null)<tr><td><a id="l6451"></a><a href="#l6451">6451</a><td>            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));<tr><td><a id="l6452"></a><a href="#l6452">6452</a><td>      for (var i = 0; i &lt; gap; ++i)<tr><td><a id="l6453"></a><a href="#l6453">6453</a><td>        newMarkers.push(gapMarkers);<tr><td><a id="l6454"></a><a href="#l6454">6454</a><td>      newMarkers.push(last);<tr><td><a id="l6455"></a><a href="#l6455">6455</a><td>    }<tr><td><a id="l6456"></a><a href="#l6456">6456</a><td>    return newMarkers;<tr><td><a id="l6457"></a><a href="#l6457">6457</a><td>  }<tr><td><a id="l6458"></a><a href="#l6458">6458</a><td><tr><td><a id="l6459"></a><a href="#l6459">6459</a><td>  // Remove spans that are empty and don&#39;t have a clearWhenEmpty<tr><td><a id="l6460"></a><a href="#l6460">6460</a><td>  // option of false.<tr><td><a id="l6461"></a><a href="#l6461">6461</a><td>  function clearEmptySpans(spans) {<tr><td><a id="l6462"></a><a href="#l6462">6462</a><td>    for (var i = 0; i &lt; spans.length; ++i) {<tr><td><a id="l6463"></a><a href="#l6463">6463</a><td>      var span = spans[i];<tr><td><a id="l6464"></a><a href="#l6464">6464</a><td>      if (span.from != null &amp;&amp; span.from == span.to &amp;&amp; span.marker.clearWhenEmpty !== false)<tr><td><a id="l6465"></a><a href="#l6465">6465</a><td>        spans.splice(i--, 1);<tr><td><a id="l6466"></a><a href="#l6466">6466</a><td>    }<tr><td><a id="l6467"></a><a href="#l6467">6467</a><td>    if (!spans.length) return null;<tr><td><a id="l6468"></a><a href="#l6468">6468</a><td>    return spans;<tr><td><a id="l6469"></a><a href="#l6469">6469</a><td>  }<tr><td><a id="l6470"></a><a href="#l6470">6470</a><td><tr><td><a id="l6471"></a><a href="#l6471">6471</a><td>  // Used for un/re-doing changes from the history. Combines the<tr><td><a id="l6472"></a><a href="#l6472">6472</a><td>  // result of computing the existing spans with the set of spans that<tr><td><a id="l6473"></a><a href="#l6473">6473</a><td>  // existed in the history (so that deleting around a span and then<tr><td><a id="l6474"></a><a href="#l6474">6474</a><td>  // undoing brings back the span).<tr><td><a id="l6475"></a><a href="#l6475">6475</a><td>  function mergeOldSpans(doc, change) {<tr><td><a id="l6476"></a><a href="#l6476">6476</a><td>    var old = getOldSpans(doc, change);<tr><td><a id="l6477"></a><a href="#l6477">6477</a><td>    var stretched = stretchSpansOverChange(doc, change);<tr><td><a id="l6478"></a><a href="#l6478">6478</a><td>    if (!old) return stretched;<tr><td><a id="l6479"></a><a href="#l6479">6479</a><td>    if (!stretched) return old;<tr><td><a id="l6480"></a><a href="#l6480">6480</a><td><tr><td><a id="l6481"></a><a href="#l6481">6481</a><td>    for (var i = 0; i &lt; old.length; ++i) {<tr><td><a id="l6482"></a><a href="#l6482">6482</a><td>      var oldCur = old[i], stretchCur = stretched[i];<tr><td><a id="l6483"></a><a href="#l6483">6483</a><td>      if (oldCur &amp;&amp; stretchCur) {<tr><td><a id="l6484"></a><a href="#l6484">6484</a><td>        spans: for (var j = 0; j &lt; stretchCur.length; ++j) {<tr><td><a id="l6485"></a><a href="#l6485">6485</a><td>          var span = stretchCur[j];<tr><td><a id="l6486"></a><a href="#l6486">6486</a><td>          for (var k = 0; k &lt; oldCur.length; ++k)<tr><td><a id="l6487"></a><a href="#l6487">6487</a><td>            if (oldCur[k].marker == span.marker) continue spans;<tr><td><a id="l6488"></a><a href="#l6488">6488</a><td>          oldCur.push(span);<tr><td><a id="l6489"></a><a href="#l6489">6489</a><td>        }<tr><td><a id="l6490"></a><a href="#l6490">6490</a><td>      } else if (stretchCur) {<tr><td><a id="l6491"></a><a href="#l6491">6491</a><td>        old[i] = stretchCur;<tr><td><a id="l6492"></a><a href="#l6492">6492</a><td>      }<tr><td><a id="l6493"></a><a href="#l6493">6493</a><td>    }<tr><td><a id="l6494"></a><a href="#l6494">6494</a><td>    return old;<tr><td><a id="l6495"></a><a href="#l6495">6495</a><td>  }<tr><td><a id="l6496"></a><a href="#l6496">6496</a><td><tr><td><a id="l6497"></a><a href="#l6497">6497</a><td>  // Used to &#39;clip&#39; out readOnly ranges when making a change.<tr><td><a id="l6498"></a><a href="#l6498">6498</a><td>  function removeReadOnlyRanges(doc, from, to) {<tr><td><a id="l6499"></a><a href="#l6499">6499</a><td>    var markers = null;<tr><td><a id="l6500"></a><a href="#l6500">6500</a><td>    doc.iter(from.line, to.line + 1, function(line) {<tr><td><a id="l6501"></a><a href="#l6501">6501</a><td>      if (line.markedSpans) for (var i = 0; i &lt; line.markedSpans.length; ++i) {<tr><td><a id="l6502"></a><a href="#l6502">6502</a><td>        var mark = line.markedSpans[i].marker;<tr><td><a id="l6503"></a><a href="#l6503">6503</a><td>        if (mark.readOnly &amp;&amp; (!markers || indexOf(markers, mark) == -1))<tr><td><a id="l6504"></a><a href="#l6504">6504</a><td>          (markers || (markers = [])).push(mark);<tr><td><a id="l6505"></a><a href="#l6505">6505</a><td>      }<tr><td><a id="l6506"></a><a href="#l6506">6506</a><td>    });<tr><td><a id="l6507"></a><a href="#l6507">6507</a><td>    if (!markers) return null;<tr><td><a id="l6508"></a><a href="#l6508">6508</a><td>    var parts = [{from: from, to: to}];<tr><td><a id="l6509"></a><a href="#l6509">6509</a><td>    for (var i = 0; i &lt; markers.length; ++i) {<tr><td><a id="l6510"></a><a href="#l6510">6510</a><td>      var mk = markers[i], m = mk.find(0);<tr><td><a id="l6511"></a><a href="#l6511">6511</a><td>      for (var j = 0; j &lt; parts.length; ++j) {<tr><td><a id="l6512"></a><a href="#l6512">6512</a><td>        var p = parts[j];<tr><td><a id="l6513"></a><a href="#l6513">6513</a><td>        if (cmp(p.to, m.from) &lt; 0 || cmp(p.from, m.to) &gt; 0) continue;<tr><td><a id="l6514"></a><a href="#l6514">6514</a><td>        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);<tr><td><a id="l6515"></a><a href="#l6515">6515</a><td>        if (dfrom &lt; 0 || !mk.inclusiveLeft &amp;&amp; !dfrom)<tr><td><a id="l6516"></a><a href="#l6516">6516</a><td>          newParts.push({from: p.from, to: m.from});<tr><td><a id="l6517"></a><a href="#l6517">6517</a><td>        if (dto &gt; 0 || !mk.inclusiveRight &amp;&amp; !dto)<tr><td><a id="l6518"></a><a href="#l6518">6518</a><td>          newParts.push({from: m.to, to: p.to});<tr><td><a id="l6519"></a><a href="#l6519">6519</a><td>        parts.splice.apply(parts, newParts);<tr><td><a id="l6520"></a><a href="#l6520">6520</a><td>        j += newParts.length - 1;<tr><td><a id="l6521"></a><a href="#l6521">6521</a><td>      }<tr><td><a id="l6522"></a><a href="#l6522">6522</a><td>    }<tr><td><a id="l6523"></a><a href="#l6523">6523</a><td>    return parts;<tr><td><a id="l6524"></a><a href="#l6524">6524</a><td>  }<tr><td><a id="l6525"></a><a href="#l6525">6525</a><td><tr><td><a id="l6526"></a><a href="#l6526">6526</a><td>  // Connect or disconnect spans from a line.<tr><td><a id="l6527"></a><a href="#l6527">6527</a><td>  function detachMarkedSpans(line) {<tr><td><a id="l6528"></a><a href="#l6528">6528</a><td>    var spans = line.markedSpans;<tr><td><a id="l6529"></a><a href="#l6529">6529</a><td>    if (!spans) return;<tr><td><a id="l6530"></a><a href="#l6530">6530</a><td>    for (var i = 0; i &lt; spans.length; ++i)<tr><td><a id="l6531"></a><a href="#l6531">6531</a><td>      spans[i].marker.detachLine(line);<tr><td><a id="l6532"></a><a href="#l6532">6532</a><td>    line.markedSpans = null;<tr><td><a id="l6533"></a><a href="#l6533">6533</a><td>  }<tr><td><a id="l6534"></a><a href="#l6534">6534</a><td>  function attachMarkedSpans(line, spans) {<tr><td><a id="l6535"></a><a href="#l6535">6535</a><td>    if (!spans) return;<tr><td><a id="l6536"></a><a href="#l6536">6536</a><td>    for (var i = 0; i &lt; spans.length; ++i)<tr><td><a id="l6537"></a><a href="#l6537">6537</a><td>      spans[i].marker.attachLine(line);<tr><td><a id="l6538"></a><a href="#l6538">6538</a><td>    line.markedSpans = spans;<tr><td><a id="l6539"></a><a href="#l6539">6539</a><td>  }<tr><td><a id="l6540"></a><a href="#l6540">6540</a><td><tr><td><a id="l6541"></a><a href="#l6541">6541</a><td>  // Helpers used when computing which overlapping collapsed span<tr><td><a id="l6542"></a><a href="#l6542">6542</a><td>  // counts as the larger one.<tr><td><a id="l6543"></a><a href="#l6543">6543</a><td>  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }<tr><td><a id="l6544"></a><a href="#l6544">6544</a><td>  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }<tr><td><a id="l6545"></a><a href="#l6545">6545</a><td><tr><td><a id="l6546"></a><a href="#l6546">6546</a><td>  // Returns a number indicating which of two overlapping collapsed<tr><td><a id="l6547"></a><a href="#l6547">6547</a><td>  // spans is larger (and thus includes the other). Falls back to<tr><td><a id="l6548"></a><a href="#l6548">6548</a><td>  // comparing ids when the spans cover exactly the same range.<tr><td><a id="l6549"></a><a href="#l6549">6549</a><td>  function compareCollapsedMarkers(a, b) {<tr><td><a id="l6550"></a><a href="#l6550">6550</a><td>    var lenDiff = a.lines.length - b.lines.length;<tr><td><a id="l6551"></a><a href="#l6551">6551</a><td>    if (lenDiff != 0) return lenDiff;<tr><td><a id="l6552"></a><a href="#l6552">6552</a><td>    var aPos = a.find(), bPos = b.find();<tr><td><a id="l6553"></a><a href="#l6553">6553</a><td>    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);<tr><td><a id="l6554"></a><a href="#l6554">6554</a><td>    if (fromCmp) return -fromCmp;<tr><td><a id="l6555"></a><a href="#l6555">6555</a><td>    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);<tr><td><a id="l6556"></a><a href="#l6556">6556</a><td>    if (toCmp) return toCmp;<tr><td><a id="l6557"></a><a href="#l6557">6557</a><td>    return b.id - a.id;<tr><td><a id="l6558"></a><a href="#l6558">6558</a><td>  }<tr><td><a id="l6559"></a><a href="#l6559">6559</a><td><tr><td><a id="l6560"></a><a href="#l6560">6560</a><td>  // Find out whether a line ends or starts in a collapsed span. If<tr><td><a id="l6561"></a><a href="#l6561">6561</a><td>  // so, return the marker for that span.<tr><td><a id="l6562"></a><a href="#l6562">6562</a><td>  function collapsedSpanAtSide(line, start) {<tr><td><a id="l6563"></a><a href="#l6563">6563</a><td>    var sps = sawCollapsedSpans &amp;&amp; line.markedSpans, found;<tr><td><a id="l6564"></a><a href="#l6564">6564</a><td>    if (sps) for (var sp, i = 0; i &lt; sps.length; ++i) {<tr><td><a id="l6565"></a><a href="#l6565">6565</a><td>      sp = sps[i];<tr><td><a id="l6566"></a><a href="#l6566">6566</a><td>      if (sp.marker.collapsed &amp;&amp; (start ? sp.from : sp.to) == null &amp;&amp;<tr><td><a id="l6567"></a><a href="#l6567">6567</a><td>          (!found || compareCollapsedMarkers(found, sp.marker) &lt; 0))<tr><td><a id="l6568"></a><a href="#l6568">6568</a><td>        found = sp.marker;<tr><td><a id="l6569"></a><a href="#l6569">6569</a><td>    }<tr><td><a id="l6570"></a><a href="#l6570">6570</a><td>    return found;<tr><td><a id="l6571"></a><a href="#l6571">6571</a><td>  }<tr><td><a id="l6572"></a><a href="#l6572">6572</a><td>  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }<tr><td><a id="l6573"></a><a href="#l6573">6573</a><td>  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }<tr><td><a id="l6574"></a><a href="#l6574">6574</a><td><tr><td><a id="l6575"></a><a href="#l6575">6575</a><td>  // Test whether there exists a collapsed span that partially<tr><td><a id="l6576"></a><a href="#l6576">6576</a><td>  // overlaps (covers the start or end, but not both) of a new span.<tr><td><a id="l6577"></a><a href="#l6577">6577</a><td>  // Such overlap is not allowed.<tr><td><a id="l6578"></a><a href="#l6578">6578</a><td>  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {<tr><td><a id="l6579"></a><a href="#l6579">6579</a><td>    var line = getLine(doc, lineNo);<tr><td><a id="l6580"></a><a href="#l6580">6580</a><td>    var sps = sawCollapsedSpans &amp;&amp; line.markedSpans;<tr><td><a id="l6581"></a><a href="#l6581">6581</a><td>    if (sps) for (var i = 0; i &lt; sps.length; ++i) {<tr><td><a id="l6582"></a><a href="#l6582">6582</a><td>      var sp = sps[i];<tr><td><a id="l6583"></a><a href="#l6583">6583</a><td>      if (!sp.marker.collapsed) continue;<tr><td><a id="l6584"></a><a href="#l6584">6584</a><td>      var found = sp.marker.find(0);<tr><td><a id="l6585"></a><a href="#l6585">6585</a><td>      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);<tr><td><a id="l6586"></a><a href="#l6586">6586</a><td>      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);<tr><td><a id="l6587"></a><a href="#l6587">6587</a><td>      if (fromCmp &gt;= 0 &amp;&amp; toCmp &lt;= 0 || fromCmp &lt;= 0 &amp;&amp; toCmp &gt;= 0) continue;<tr><td><a id="l6588"></a><a href="#l6588">6588</a><td>      if (fromCmp &lt;= 0 &amp;&amp; (sp.marker.inclusiveRight &amp;&amp; marker.inclusiveLeft ? cmp(found.to, from) &gt;= 0 : cmp(found.to, from) &gt; 0) ||<tr><td><a id="l6589"></a><a href="#l6589">6589</a><td>          fromCmp &gt;= 0 &amp;&amp; (sp.marker.inclusiveRight &amp;&amp; marker.inclusiveLeft ? cmp(found.from, to) &lt;= 0 : cmp(found.from, to) &lt; 0))<tr><td><a id="l6590"></a><a href="#l6590">6590</a><td>        return true;<tr><td><a id="l6591"></a><a href="#l6591">6591</a><td>    }<tr><td><a id="l6592"></a><a href="#l6592">6592</a><td>  }<tr><td><a id="l6593"></a><a href="#l6593">6593</a><td><tr><td><a id="l6594"></a><a href="#l6594">6594</a><td>  // A visual line is a line as drawn on the screen. Folding, for<tr><td><a id="l6595"></a><a href="#l6595">6595</a><td>  // example, can cause multiple logical lines to appear on the same<tr><td><a id="l6596"></a><a href="#l6596">6596</a><td>  // visual line. This finds the start of the visual line that the<tr><td><a id="l6597"></a><a href="#l6597">6597</a><td>  // given line is part of (usually that is the line itself).<tr><td><a id="l6598"></a><a href="#l6598">6598</a><td>  function visualLine(line) {<tr><td><a id="l6599"></a><a href="#l6599">6599</a><td>    var merged;<tr><td><a id="l6600"></a><a href="#l6600">6600</a><td>    while (merged = collapsedSpanAtStart(line))<tr><td><a id="l6601"></a><a href="#l6601">6601</a><td>      line = merged.find(-1, true).line;<tr><td><a id="l6602"></a><a href="#l6602">6602</a><td>    return line;<tr><td><a id="l6603"></a><a href="#l6603">6603</a><td>  }<tr><td><a id="l6604"></a><a href="#l6604">6604</a><td><tr><td><a id="l6605"></a><a href="#l6605">6605</a><td>  // Returns an array of logical lines that continue the visual line<tr><td><a id="l6606"></a><a href="#l6606">6606</a><td>  // started by the argument, or undefined if there are no such lines.<tr><td><a id="l6607"></a><a href="#l6607">6607</a><td>  function visualLineContinued(line) {<tr><td><a id="l6608"></a><a href="#l6608">6608</a><td>    var merged, lines;<tr><td><a id="l6609"></a><a href="#l6609">6609</a><td>    while (merged = collapsedSpanAtEnd(line)) {<tr><td><a id="l6610"></a><a href="#l6610">6610</a><td>      line = merged.find(1, true).line;<tr><td><a id="l6611"></a><a href="#l6611">6611</a><td>      (lines || (lines = [])).push(line);<tr><td><a id="l6612"></a><a href="#l6612">6612</a><td>    }<tr><td><a id="l6613"></a><a href="#l6613">6613</a><td>    return lines;<tr><td><a id="l6614"></a><a href="#l6614">6614</a><td>  }<tr><td><a id="l6615"></a><a href="#l6615">6615</a><td><tr><td><a id="l6616"></a><a href="#l6616">6616</a><td>  // Get the line number of the start of the visual line that the<tr><td><a id="l6617"></a><a href="#l6617">6617</a><td>  // given line number is part of.<tr><td><a id="l6618"></a><a href="#l6618">6618</a><td>  function visualLineNo(doc, lineN) {<tr><td><a id="l6619"></a><a href="#l6619">6619</a><td>    var line = getLine(doc, lineN), vis = visualLine(line);<tr><td><a id="l6620"></a><a href="#l6620">6620</a><td>    if (line == vis) return lineN;<tr><td><a id="l6621"></a><a href="#l6621">6621</a><td>    return lineNo(vis);<tr><td><a id="l6622"></a><a href="#l6622">6622</a><td>  }<tr><td><a id="l6623"></a><a href="#l6623">6623</a><td>  // Get the line number of the start of the next visual line after<tr><td><a id="l6624"></a><a href="#l6624">6624</a><td>  // the given line.<tr><td><a id="l6625"></a><a href="#l6625">6625</a><td>  function visualLineEndNo(doc, lineN) {<tr><td><a id="l6626"></a><a href="#l6626">6626</a><td>    if (lineN &gt; doc.lastLine()) return lineN;<tr><td><a id="l6627"></a><a href="#l6627">6627</a><td>    var line = getLine(doc, lineN), merged;<tr><td><a id="l6628"></a><a href="#l6628">6628</a><td>    if (!lineIsHidden(doc, line)) return lineN;<tr><td><a id="l6629"></a><a href="#l6629">6629</a><td>    while (merged = collapsedSpanAtEnd(line))<tr><td><a id="l6630"></a><a href="#l6630">6630</a><td>      line = merged.find(1, true).line;<tr><td><a id="l6631"></a><a href="#l6631">6631</a><td>    return lineNo(line) + 1;<tr><td><a id="l6632"></a><a href="#l6632">6632</a><td>  }<tr><td><a id="l6633"></a><a href="#l6633">6633</a><td><tr><td><a id="l6634"></a><a href="#l6634">6634</a><td>  // Compute whether a line is hidden. Lines count as hidden when they<tr><td><a id="l6635"></a><a href="#l6635">6635</a><td>  // are part of a visual line that starts with another line, or when<tr><td><a id="l6636"></a><a href="#l6636">6636</a><td>  // they are entirely covered by collapsed, non-widget span.<tr><td><a id="l6637"></a><a href="#l6637">6637</a><td>  function lineIsHidden(doc, line) {<tr><td><a id="l6638"></a><a href="#l6638">6638</a><td>    var sps = sawCollapsedSpans &amp;&amp; line.markedSpans;<tr><td><a id="l6639"></a><a href="#l6639">6639</a><td>    if (sps) for (var sp, i = 0; i &lt; sps.length; ++i) {<tr><td><a id="l6640"></a><a href="#l6640">6640</a><td>      sp = sps[i];<tr><td><a id="l6641"></a><a href="#l6641">6641</a><td>      if (!sp.marker.collapsed) continue;<tr><td><a id="l6642"></a><a href="#l6642">6642</a><td>      if (sp.from == null) return true;<tr><td><a id="l6643"></a><a href="#l6643">6643</a><td>      if (sp.marker.widgetNode) continue;<tr><td><a id="l6644"></a><a href="#l6644">6644</a><td>      if (sp.from == 0 &amp;&amp; sp.marker.inclusiveLeft &amp;&amp; lineIsHiddenInner(doc, line, sp))<tr><td><a id="l6645"></a><a href="#l6645">6645</a><td>        return true;<tr><td><a id="l6646"></a><a href="#l6646">6646</a><td>    }<tr><td><a id="l6647"></a><a href="#l6647">6647</a><td>  }<tr><td><a id="l6648"></a><a href="#l6648">6648</a><td>  function lineIsHiddenInner(doc, line, span) {<tr><td><a id="l6649"></a><a href="#l6649">6649</a><td>    if (span.to == null) {<tr><td><a id="l6650"></a><a href="#l6650">6650</a><td>      var end = span.marker.find(1, true);<tr><td><a id="l6651"></a><a href="#l6651">6651</a><td>      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));<tr><td><a id="l6652"></a><a href="#l6652">6652</a><td>    }<tr><td><a id="l6653"></a><a href="#l6653">6653</a><td>    if (span.marker.inclusiveRight &amp;&amp; span.to == line.text.length)<tr><td><a id="l6654"></a><a href="#l6654">6654</a><td>      return true;<tr><td><a id="l6655"></a><a href="#l6655">6655</a><td>    for (var sp, i = 0; i &lt; line.markedSpans.length; ++i) {<tr><td><a id="l6656"></a><a href="#l6656">6656</a><td>      sp = line.markedSpans[i];<tr><td><a id="l6657"></a><a href="#l6657">6657</a><td>      if (sp.marker.collapsed &amp;&amp; !sp.marker.widgetNode &amp;&amp; sp.from == span.to &amp;&amp;<tr><td><a id="l6658"></a><a href="#l6658">6658</a><td>          (sp.to == null || sp.to != span.from) &amp;&amp;<tr><td><a id="l6659"></a><a href="#l6659">6659</a><td>          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &amp;&amp;<tr><td><a id="l6660"></a><a href="#l6660">6660</a><td>          lineIsHiddenInner(doc, line, sp)) return true;<tr><td><a id="l6661"></a><a href="#l6661">6661</a><td>    }<tr><td><a id="l6662"></a><a href="#l6662">6662</a><td>  }<tr><td><a id="l6663"></a><a href="#l6663">6663</a><td><tr><td><a id="l6664"></a><a href="#l6664">6664</a><td>  // LINE WIDGETS<tr><td><a id="l6665"></a><a href="#l6665">6665</a><td><tr><td><a id="l6666"></a><a href="#l6666">6666</a><td>  // Line widgets are block elements displayed above or below a line.<tr><td><a id="l6667"></a><a href="#l6667">6667</a><td><tr><td><a id="l6668"></a><a href="#l6668">6668</a><td>  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {<tr><td><a id="l6669"></a><a href="#l6669">6669</a><td>    if (options) for (var opt in options) if (options.hasOwnProperty(opt))<tr><td><a id="l6670"></a><a href="#l6670">6670</a><td>      this[opt] = options[opt];<tr><td><a id="l6671"></a><a href="#l6671">6671</a><td>    this.doc = doc;<tr><td><a id="l6672"></a><a href="#l6672">6672</a><td>    this.node = node;<tr><td><a id="l6673"></a><a href="#l6673">6673</a><td>  };<tr><td><a id="l6674"></a><a href="#l6674">6674</a><td>  eventMixin(LineWidget);<tr><td><a id="l6675"></a><a href="#l6675">6675</a><td><tr><td><a id="l6676"></a><a href="#l6676">6676</a><td>  function adjustScrollWhenAboveVisible(cm, line, diff) {<tr><td><a id="l6677"></a><a href="#l6677">6677</a><td>    if (heightAtLine(line) &lt; ((cm.curOp &amp;&amp; cm.curOp.scrollTop) || cm.doc.scrollTop))<tr><td><a id="l6678"></a><a href="#l6678">6678</a><td>      addToScrollPos(cm, null, diff);<tr><td><a id="l6679"></a><a href="#l6679">6679</a><td>  }<tr><td><a id="l6680"></a><a href="#l6680">6680</a><td><tr><td><a id="l6681"></a><a href="#l6681">6681</a><td>  LineWidget.prototype.clear = function() {<tr><td><a id="l6682"></a><a href="#l6682">6682</a><td>    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);<tr><td><a id="l6683"></a><a href="#l6683">6683</a><td>    if (no == null || !ws) return;<tr><td><a id="l6684"></a><a href="#l6684">6684</a><td>    for (var i = 0; i &lt; ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);<tr><td><a id="l6685"></a><a href="#l6685">6685</a><td>    if (!ws.length) line.widgets = null;<tr><td><a id="l6686"></a><a href="#l6686">6686</a><td>    var height = widgetHeight(this);<tr><td><a id="l6687"></a><a href="#l6687">6687</a><td>    updateLineHeight(line, Math.max(0, line.height - height));<tr><td><a id="l6688"></a><a href="#l6688">6688</a><td>    if (cm) runInOp(cm, function() {<tr><td><a id="l6689"></a><a href="#l6689">6689</a><td>      adjustScrollWhenAboveVisible(cm, line, -height);<tr><td><a id="l6690"></a><a href="#l6690">6690</a><td>      regLineChange(cm, no, &quot;widget&quot;);<tr><td><a id="l6691"></a><a href="#l6691">6691</a><td>    });<tr><td><a id="l6692"></a><a href="#l6692">6692</a><td>  };<tr><td><a id="l6693"></a><a href="#l6693">6693</a><td>  LineWidget.prototype.changed = function() {<tr><td><a id="l6694"></a><a href="#l6694">6694</a><td>    var oldH = this.height, cm = this.doc.cm, line = this.line;<tr><td><a id="l6695"></a><a href="#l6695">6695</a><td>    this.height = null;<tr><td><a id="l6696"></a><a href="#l6696">6696</a><td>    var diff = widgetHeight(this) - oldH;<tr><td><a id="l6697"></a><a href="#l6697">6697</a><td>    if (!diff) return;<tr><td><a id="l6698"></a><a href="#l6698">6698</a><td>    updateLineHeight(line, line.height + diff);<tr><td><a id="l6699"></a><a href="#l6699">6699</a><td>    if (cm) runInOp(cm, function() {<tr><td><a id="l6700"></a><a href="#l6700">6700</a><td>      cm.curOp.forceUpdate = true;<tr><td><a id="l6701"></a><a href="#l6701">6701</a><td>      adjustScrollWhenAboveVisible(cm, line, diff);<tr><td><a id="l6702"></a><a href="#l6702">6702</a><td>    });<tr><td><a id="l6703"></a><a href="#l6703">6703</a><td>  };<tr><td><a id="l6704"></a><a href="#l6704">6704</a><td><tr><td><a id="l6705"></a><a href="#l6705">6705</a><td>  function widgetHeight(widget) {<tr><td><a id="l6706"></a><a href="#l6706">6706</a><td>    if (widget.height != null) return widget.height;<tr><td><a id="l6707"></a><a href="#l6707">6707</a><td>    var cm = widget.doc.cm;<tr><td><a id="l6708"></a><a href="#l6708">6708</a><td>    if (!cm) return 0;<tr><td><a id="l6709"></a><a href="#l6709">6709</a><td>    if (!contains(document.body, widget.node)) {<tr><td><a id="l6710"></a><a href="#l6710">6710</a><td>      var parentStyle = &quot;position: relative;&quot;;<tr><td><a id="l6711"></a><a href="#l6711">6711</a><td>      if (widget.coverGutter)<tr><td><a id="l6712"></a><a href="#l6712">6712</a><td>        parentStyle += &quot;margin-left: -&quot; + cm.display.gutters.offsetWidth + &quot;px;&quot;;<tr><td><a id="l6713"></a><a href="#l6713">6713</a><td>      if (widget.noHScroll)<tr><td><a id="l6714"></a><a href="#l6714">6714</a><td>        parentStyle += &quot;width: &quot; + cm.display.wrapper.clientWidth + &quot;px;&quot;;<tr><td><a id="l6715"></a><a href="#l6715">6715</a><td>      removeChildrenAndAdd(cm.display.measure, elt(&quot;div&quot;, [widget.node], null, parentStyle));<tr><td><a id="l6716"></a><a href="#l6716">6716</a><td>    }<tr><td><a id="l6717"></a><a href="#l6717">6717</a><td>    return widget.height = widget.node.parentNode.offsetHeight;<tr><td><a id="l6718"></a><a href="#l6718">6718</a><td>  }<tr><td><a id="l6719"></a><a href="#l6719">6719</a><td><tr><td><a id="l6720"></a><a href="#l6720">6720</a><td>  function addLineWidget(doc, handle, node, options) {<tr><td><a id="l6721"></a><a href="#l6721">6721</a><td>    var widget = new LineWidget(doc, node, options);<tr><td><a id="l6722"></a><a href="#l6722">6722</a><td>    var cm = doc.cm;<tr><td><a id="l6723"></a><a href="#l6723">6723</a><td>    if (cm &amp;&amp; widget.noHScroll) cm.display.alignWidgets = true;<tr><td><a id="l6724"></a><a href="#l6724">6724</a><td>    changeLine(doc, handle, &quot;widget&quot;, function(line) {<tr><td><a id="l6725"></a><a href="#l6725">6725</a><td>      var widgets = line.widgets || (line.widgets = []);<tr><td><a id="l6726"></a><a href="#l6726">6726</a><td>      if (widget.insertAt == null) widgets.push(widget);<tr><td><a id="l6727"></a><a href="#l6727">6727</a><td>      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);<tr><td><a id="l6728"></a><a href="#l6728">6728</a><td>      widget.line = line;<tr><td><a id="l6729"></a><a href="#l6729">6729</a><td>      if (cm &amp;&amp; !lineIsHidden(doc, line)) {<tr><td><a id="l6730"></a><a href="#l6730">6730</a><td>        var aboveVisible = heightAtLine(line) &lt; doc.scrollTop;<tr><td><a id="l6731"></a><a href="#l6731">6731</a><td>        updateLineHeight(line, line.height + widgetHeight(widget));<tr><td><a id="l6732"></a><a href="#l6732">6732</a><td>        if (aboveVisible) addToScrollPos(cm, null, widget.height);<tr><td><a id="l6733"></a><a href="#l6733">6733</a><td>        cm.curOp.forceUpdate = true;<tr><td><a id="l6734"></a><a href="#l6734">6734</a><td>      }<tr><td><a id="l6735"></a><a href="#l6735">6735</a><td>      return true;<tr><td><a id="l6736"></a><a href="#l6736">6736</a><td>    });<tr><td><a id="l6737"></a><a href="#l6737">6737</a><td>    return widget;<tr><td><a id="l6738"></a><a href="#l6738">6738</a><td>  }<tr><td><a id="l6739"></a><a href="#l6739">6739</a><td><tr><td><a id="l6740"></a><a href="#l6740">6740</a><td>  // LINE DATA STRUCTURE<tr><td><a id="l6741"></a><a href="#l6741">6741</a><td><tr><td><a id="l6742"></a><a href="#l6742">6742</a><td>  // Line objects. These hold state related to a line, including<tr><td><a id="l6743"></a><a href="#l6743">6743</a><td>  // highlighting info (the styles array).<tr><td><a id="l6744"></a><a href="#l6744">6744</a><td>  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {<tr><td><a id="l6745"></a><a href="#l6745">6745</a><td>    this.text = text;<tr><td><a id="l6746"></a><a href="#l6746">6746</a><td>    attachMarkedSpans(this, markedSpans);<tr><td><a id="l6747"></a><a href="#l6747">6747</a><td>    this.height = estimateHeight ? estimateHeight(this) : 1;<tr><td><a id="l6748"></a><a href="#l6748">6748</a><td>  };<tr><td><a id="l6749"></a><a href="#l6749">6749</a><td>  eventMixin(Line);<tr><td><a id="l6750"></a><a href="#l6750">6750</a><td>  Line.prototype.lineNo = function() { return lineNo(this); };<tr><td><a id="l6751"></a><a href="#l6751">6751</a><td><tr><td><a id="l6752"></a><a href="#l6752">6752</a><td>  // Change the content (text, markers) of a line. Automatically<tr><td><a id="l6753"></a><a href="#l6753">6753</a><td>  // invalidates cached information and tries to re-estimate the<tr><td><a id="l6754"></a><a href="#l6754">6754</a><td>  // line&#39;s height.<tr><td><a id="l6755"></a><a href="#l6755">6755</a><td>  function updateLine(line, text, markedSpans, estimateHeight) {<tr><td><a id="l6756"></a><a href="#l6756">6756</a><td>    line.text = text;<tr><td><a id="l6757"></a><a href="#l6757">6757</a><td>    if (line.stateAfter) line.stateAfter = null;<tr><td><a id="l6758"></a><a href="#l6758">6758</a><td>    if (line.styles) line.styles = null;<tr><td><a id="l6759"></a><a href="#l6759">6759</a><td>    if (line.order != null) line.order = null;<tr><td><a id="l6760"></a><a href="#l6760">6760</a><td>    detachMarkedSpans(line);<tr><td><a id="l6761"></a><a href="#l6761">6761</a><td>    attachMarkedSpans(line, markedSpans);<tr><td><a id="l6762"></a><a href="#l6762">6762</a><td>    var estHeight = estimateHeight ? estimateHeight(line) : 1;<tr><td><a id="l6763"></a><a href="#l6763">6763</a><td>    if (estHeight != line.height) updateLineHeight(line, estHeight);<tr><td><a id="l6764"></a><a href="#l6764">6764</a><td>  }<tr><td><a id="l6765"></a><a href="#l6765">6765</a><td><tr><td><a id="l6766"></a><a href="#l6766">6766</a><td>  // Detach a line from the document tree and its markers.<tr><td><a id="l6767"></a><a href="#l6767">6767</a><td>  function cleanUpLine(line) {<tr><td><a id="l6768"></a><a href="#l6768">6768</a><td>    line.parent = null;<tr><td><a id="l6769"></a><a href="#l6769">6769</a><td>    detachMarkedSpans(line);<tr><td><a id="l6770"></a><a href="#l6770">6770</a><td>  }<tr><td><a id="l6771"></a><a href="#l6771">6771</a><td><tr><td><a id="l6772"></a><a href="#l6772">6772</a><td>  function extractLineClasses(type, output) {<tr><td><a id="l6773"></a><a href="#l6773">6773</a><td>    if (type) for (;;) {<tr><td><a id="l6774"></a><a href="#l6774">6774</a><td>      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);<tr><td><a id="l6775"></a><a href="#l6775">6775</a><td>      if (!lineClass) break;<tr><td><a id="l6776"></a><a href="#l6776">6776</a><td>      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);<tr><td><a id="l6777"></a><a href="#l6777">6777</a><td>      var prop = lineClass[1] ? &quot;bgClass&quot; : &quot;textClass&quot;;<tr><td><a id="l6778"></a><a href="#l6778">6778</a><td>      if (output[prop] == null)<tr><td><a id="l6779"></a><a href="#l6779">6779</a><td>        output[prop] = lineClass[2];<tr><td><a id="l6780"></a><a href="#l6780">6780</a><td>      else if (!(new RegExp(&quot;(?:^|\s)&quot; + lineClass[2] + &quot;(?:$|\s)&quot;)).test(output[prop]))<tr><td><a id="l6781"></a><a href="#l6781">6781</a><td>        output[prop] += &quot; &quot; + lineClass[2];<tr><td><a id="l6782"></a><a href="#l6782">6782</a><td>    }<tr><td><a id="l6783"></a><a href="#l6783">6783</a><td>    return type;<tr><td><a id="l6784"></a><a href="#l6784">6784</a><td>  }<tr><td><a id="l6785"></a><a href="#l6785">6785</a><td><tr><td><a id="l6786"></a><a href="#l6786">6786</a><td>  function callBlankLine(mode, state) {<tr><td><a id="l6787"></a><a href="#l6787">6787</a><td>    if (mode.blankLine) return mode.blankLine(state);<tr><td><a id="l6788"></a><a href="#l6788">6788</a><td>    if (!mode.innerMode) return;<tr><td><a id="l6789"></a><a href="#l6789">6789</a><td>    var inner = CodeMirror.innerMode(mode, state);<tr><td><a id="l6790"></a><a href="#l6790">6790</a><td>    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);<tr><td><a id="l6791"></a><a href="#l6791">6791</a><td>  }<tr><td><a id="l6792"></a><a href="#l6792">6792</a><td><tr><td><a id="l6793"></a><a href="#l6793">6793</a><td>  function readToken(mode, stream, state, inner) {<tr><td><a id="l6794"></a><a href="#l6794">6794</a><td>    for (var i = 0; i &lt; 10; i++) {<tr><td><a id="l6795"></a><a href="#l6795">6795</a><td>      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;<tr><td><a id="l6796"></a><a href="#l6796">6796</a><td>      var style = mode.token(stream, state);<tr><td><a id="l6797"></a><a href="#l6797">6797</a><td>      if (stream.pos &gt; stream.start) return style;<tr><td><a id="l6798"></a><a href="#l6798">6798</a><td>    }<tr><td><a id="l6799"></a><a href="#l6799">6799</a><td>    throw new Error(&quot;Mode &quot; + mode.name + &quot; failed to advance stream.&quot;);<tr><td><a id="l6800"></a><a href="#l6800">6800</a><td>  }<tr><td><a id="l6801"></a><a href="#l6801">6801</a><td><tr><td><a id="l6802"></a><a href="#l6802">6802</a><td>  // Utility for getTokenAt and getLineTokens<tr><td><a id="l6803"></a><a href="#l6803">6803</a><td>  function takeToken(cm, pos, precise, asArray) {<tr><td><a id="l6804"></a><a href="#l6804">6804</a><td>    function getObj(copy) {<tr><td><a id="l6805"></a><a href="#l6805">6805</a><td>      return {start: stream.start, end: stream.pos,<tr><td><a id="l6806"></a><a href="#l6806">6806</a><td>              string: stream.current(),<tr><td><a id="l6807"></a><a href="#l6807">6807</a><td>              type: style || null,<tr><td><a id="l6808"></a><a href="#l6808">6808</a><td>              state: copy ? copyState(doc.mode, state) : state};<tr><td><a id="l6809"></a><a href="#l6809">6809</a><td>    }<tr><td><a id="l6810"></a><a href="#l6810">6810</a><td><tr><td><a id="l6811"></a><a href="#l6811">6811</a><td>    var doc = cm.doc, mode = doc.mode, style;<tr><td><a id="l6812"></a><a href="#l6812">6812</a><td>    pos = clipPos(doc, pos);<tr><td><a id="l6813"></a><a href="#l6813">6813</a><td>    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);<tr><td><a id="l6814"></a><a href="#l6814">6814</a><td>    var stream = new StringStream(line.text, cm.options.tabSize), tokens;<tr><td><a id="l6815"></a><a href="#l6815">6815</a><td>    if (asArray) tokens = [];<tr><td><a id="l6816"></a><a href="#l6816">6816</a><td>    while ((asArray || stream.pos &lt; pos.ch) &amp;&amp; !stream.eol()) {<tr><td><a id="l6817"></a><a href="#l6817">6817</a><td>      stream.start = stream.pos;<tr><td><a id="l6818"></a><a href="#l6818">6818</a><td>      style = readToken(mode, stream, state);<tr><td><a id="l6819"></a><a href="#l6819">6819</a><td>      if (asArray) tokens.push(getObj(true));<tr><td><a id="l6820"></a><a href="#l6820">6820</a><td>    }<tr><td><a id="l6821"></a><a href="#l6821">6821</a><td>    return asArray ? tokens : getObj();<tr><td><a id="l6822"></a><a href="#l6822">6822</a><td>  }<tr><td><a id="l6823"></a><a href="#l6823">6823</a><td><tr><td><a id="l6824"></a><a href="#l6824">6824</a><td>  // Run the given mode&#39;s parser over a line, calling f for each token.<tr><td><a id="l6825"></a><a href="#l6825">6825</a><td>  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {<tr><td><a id="l6826"></a><a href="#l6826">6826</a><td>    var flattenSpans = mode.flattenSpans;<tr><td><a id="l6827"></a><a href="#l6827">6827</a><td>    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;<tr><td><a id="l6828"></a><a href="#l6828">6828</a><td>    var curStart = 0, curStyle = null;<tr><td><a id="l6829"></a><a href="#l6829">6829</a><td>    var stream = new StringStream(text, cm.options.tabSize), style;<tr><td><a id="l6830"></a><a href="#l6830">6830</a><td>    var inner = cm.options.addModeClass &amp;&amp; [null];<tr><td><a id="l6831"></a><a href="#l6831">6831</a><td>    if (text == &quot;&quot;) extractLineClasses(callBlankLine(mode, state), lineClasses);<tr><td><a id="l6832"></a><a href="#l6832">6832</a><td>    while (!stream.eol()) {<tr><td><a id="l6833"></a><a href="#l6833">6833</a><td>      if (stream.pos &gt; cm.options.maxHighlightLength) {<tr><td><a id="l6834"></a><a href="#l6834">6834</a><td>        flattenSpans = false;<tr><td><a id="l6835"></a><a href="#l6835">6835</a><td>        if (forceToEnd) processLine(cm, text, state, stream.pos);<tr><td><a id="l6836"></a><a href="#l6836">6836</a><td>        stream.pos = text.length;<tr><td><a id="l6837"></a><a href="#l6837">6837</a><td>        style = null;<tr><td><a id="l6838"></a><a href="#l6838">6838</a><td>      } else {<tr><td><a id="l6839"></a><a href="#l6839">6839</a><td>        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);<tr><td><a id="l6840"></a><a href="#l6840">6840</a><td>      }<tr><td><a id="l6841"></a><a href="#l6841">6841</a><td>      if (inner) {<tr><td><a id="l6842"></a><a href="#l6842">6842</a><td>        var mName = inner[0].name;<tr><td><a id="l6843"></a><a href="#l6843">6843</a><td>        if (mName) style = &quot;m-&quot; + (style ? mName + &quot; &quot; + style : mName);<tr><td><a id="l6844"></a><a href="#l6844">6844</a><td>      }<tr><td><a id="l6845"></a><a href="#l6845">6845</a><td>      if (!flattenSpans || curStyle != style) {<tr><td><a id="l6846"></a><a href="#l6846">6846</a><td>        while (curStart &lt; stream.start) {<tr><td><a id="l6847"></a><a href="#l6847">6847</a><td>          curStart = Math.min(stream.start, curStart + 50000);<tr><td><a id="l6848"></a><a href="#l6848">6848</a><td>          f(curStart, curStyle);<tr><td><a id="l6849"></a><a href="#l6849">6849</a><td>        }<tr><td><a id="l6850"></a><a href="#l6850">6850</a><td>        curStyle = style;<tr><td><a id="l6851"></a><a href="#l6851">6851</a><td>      }<tr><td><a id="l6852"></a><a href="#l6852">6852</a><td>      stream.start = stream.pos;<tr><td><a id="l6853"></a><a href="#l6853">6853</a><td>    }<tr><td><a id="l6854"></a><a href="#l6854">6854</a><td>    while (curStart &lt; stream.pos) {<tr><td><a id="l6855"></a><a href="#l6855">6855</a><td>      // Webkit seems to refuse to render text nodes longer than 57444 characters<tr><td><a id="l6856"></a><a href="#l6856">6856</a><td>      var pos = Math.min(stream.pos, curStart + 50000);<tr><td><a id="l6857"></a><a href="#l6857">6857</a><td>      f(pos, curStyle);<tr><td><a id="l6858"></a><a href="#l6858">6858</a><td>      curStart = pos;<tr><td><a id="l6859"></a><a href="#l6859">6859</a><td>    }<tr><td><a id="l6860"></a><a href="#l6860">6860</a><td>  }<tr><td><a id="l6861"></a><a href="#l6861">6861</a><td><tr><td><a id="l6862"></a><a href="#l6862">6862</a><td>  // Compute a style array (an array starting with a mode generation<tr><td><a id="l6863"></a><a href="#l6863">6863</a><td>  // -- for invalidation -- followed by pairs of end positions and<tr><td><a id="l6864"></a><a href="#l6864">6864</a><td>  // style strings), which is used to highlight the tokens on the<tr><td><a id="l6865"></a><a href="#l6865">6865</a><td>  // line.<tr><td><a id="l6866"></a><a href="#l6866">6866</a><td>  function highlightLine(cm, line, state, forceToEnd) {<tr><td><a id="l6867"></a><a href="#l6867">6867</a><td>    // A styles array always starts with a number identifying the<tr><td><a id="l6868"></a><a href="#l6868">6868</a><td>    // mode/overlays that it is based on (for easy invalidation).<tr><td><a id="l6869"></a><a href="#l6869">6869</a><td>    var st = [cm.state.modeGen], lineClasses = {};<tr><td><a id="l6870"></a><a href="#l6870">6870</a><td>    // Compute the base array of styles<tr><td><a id="l6871"></a><a href="#l6871">6871</a><td>    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {<tr><td><a id="l6872"></a><a href="#l6872">6872</a><td>      st.push(end, style);<tr><td><a id="l6873"></a><a href="#l6873">6873</a><td>    }, lineClasses, forceToEnd);<tr><td><a id="l6874"></a><a href="#l6874">6874</a><td><tr><td><a id="l6875"></a><a href="#l6875">6875</a><td>    // Run overlays, adjust style array.<tr><td><a id="l6876"></a><a href="#l6876">6876</a><td>    for (var o = 0; o &lt; cm.state.overlays.length; ++o) {<tr><td><a id="l6877"></a><a href="#l6877">6877</a><td>      var overlay = cm.state.overlays[o], i = 1, at = 0;<tr><td><a id="l6878"></a><a href="#l6878">6878</a><td>      runMode(cm, line.text, overlay.mode, true, function(end, style) {<tr><td><a id="l6879"></a><a href="#l6879">6879</a><td>        var start = i;<tr><td><a id="l6880"></a><a href="#l6880">6880</a><td>        // Ensure there&#39;s a token end at the current position, and that i points at it<tr><td><a id="l6881"></a><a href="#l6881">6881</a><td>        while (at &lt; end) {<tr><td><a id="l6882"></a><a href="#l6882">6882</a><td>          var i_end = st[i];<tr><td><a id="l6883"></a><a href="#l6883">6883</a><td>          if (i_end &gt; end)<tr><td><a id="l6884"></a><a href="#l6884">6884</a><td>            st.splice(i, 1, end, st[i+1], i_end);<tr><td><a id="l6885"></a><a href="#l6885">6885</a><td>          i += 2;<tr><td><a id="l6886"></a><a href="#l6886">6886</a><td>          at = Math.min(end, i_end);<tr><td><a id="l6887"></a><a href="#l6887">6887</a><td>        }<tr><td><a id="l6888"></a><a href="#l6888">6888</a><td>        if (!style) return;<tr><td><a id="l6889"></a><a href="#l6889">6889</a><td>        if (overlay.opaque) {<tr><td><a id="l6890"></a><a href="#l6890">6890</a><td>          st.splice(start, i - start, end, &quot;cm-overlay &quot; + style);<tr><td><a id="l6891"></a><a href="#l6891">6891</a><td>          i = start + 2;<tr><td><a id="l6892"></a><a href="#l6892">6892</a><td>        } else {<tr><td><a id="l6893"></a><a href="#l6893">6893</a><td>          for (; start &lt; i; start += 2) {<tr><td><a id="l6894"></a><a href="#l6894">6894</a><td>            var cur = st[start+1];<tr><td><a id="l6895"></a><a href="#l6895">6895</a><td>            st[start+1] = (cur ? cur + &quot; &quot; : &quot;&quot;) + &quot;cm-overlay &quot; + style;<tr><td><a id="l6896"></a><a href="#l6896">6896</a><td>          }<tr><td><a id="l6897"></a><a href="#l6897">6897</a><td>        }<tr><td><a id="l6898"></a><a href="#l6898">6898</a><td>      }, lineClasses);<tr><td><a id="l6899"></a><a href="#l6899">6899</a><td>    }<tr><td><a id="l6900"></a><a href="#l6900">6900</a><td><tr><td><a id="l6901"></a><a href="#l6901">6901</a><td>    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};<tr><td><a id="l6902"></a><a href="#l6902">6902</a><td>  }<tr><td><a id="l6903"></a><a href="#l6903">6903</a><td><tr><td><a id="l6904"></a><a href="#l6904">6904</a><td>  function getLineStyles(cm, line, updateFrontier) {<tr><td><a id="l6905"></a><a href="#l6905">6905</a><td>    if (!line.styles || line.styles[0] != cm.state.modeGen) {<tr><td><a id="l6906"></a><a href="#l6906">6906</a><td>      var state = getStateBefore(cm, lineNo(line));<tr><td><a id="l6907"></a><a href="#l6907">6907</a><td>      var result = highlightLine(cm, line, line.text.length &gt; cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);<tr><td><a id="l6908"></a><a href="#l6908">6908</a><td>      line.stateAfter = state;<tr><td><a id="l6909"></a><a href="#l6909">6909</a><td>      line.styles = result.styles;<tr><td><a id="l6910"></a><a href="#l6910">6910</a><td>      if (result.classes) line.styleClasses = result.classes;<tr><td><a id="l6911"></a><a href="#l6911">6911</a><td>      else if (line.styleClasses) line.styleClasses = null;<tr><td><a id="l6912"></a><a href="#l6912">6912</a><td>      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;<tr><td><a id="l6913"></a><a href="#l6913">6913</a><td>    }<tr><td><a id="l6914"></a><a href="#l6914">6914</a><td>    return line.styles;<tr><td><a id="l6915"></a><a href="#l6915">6915</a><td>  }<tr><td><a id="l6916"></a><a href="#l6916">6916</a><td><tr><td><a id="l6917"></a><a href="#l6917">6917</a><td>  // Lightweight form of highlight -- proceed over this line and<tr><td><a id="l6918"></a><a href="#l6918">6918</a><td>  // update state, but don&#39;t save a style array. Used for lines that<tr><td><a id="l6919"></a><a href="#l6919">6919</a><td>  // aren&#39;t currently visible.<tr><td><a id="l6920"></a><a href="#l6920">6920</a><td>  function processLine(cm, text, state, startAt) {<tr><td><a id="l6921"></a><a href="#l6921">6921</a><td>    var mode = cm.doc.mode;<tr><td><a id="l6922"></a><a href="#l6922">6922</a><td>    var stream = new StringStream(text, cm.options.tabSize);<tr><td><a id="l6923"></a><a href="#l6923">6923</a><td>    stream.start = stream.pos = startAt || 0;<tr><td><a id="l6924"></a><a href="#l6924">6924</a><td>    if (text == &quot;&quot;) callBlankLine(mode, state);<tr><td><a id="l6925"></a><a href="#l6925">6925</a><td>    while (!stream.eol()) {<tr><td><a id="l6926"></a><a href="#l6926">6926</a><td>      readToken(mode, stream, state);<tr><td><a id="l6927"></a><a href="#l6927">6927</a><td>      stream.start = stream.pos;<tr><td><a id="l6928"></a><a href="#l6928">6928</a><td>    }<tr><td><a id="l6929"></a><a href="#l6929">6929</a><td>  }<tr><td><a id="l6930"></a><a href="#l6930">6930</a><td><tr><td><a id="l6931"></a><a href="#l6931">6931</a><td>  // Convert a style as returned by a mode (either null, or a string<tr><td><a id="l6932"></a><a href="#l6932">6932</a><td>  // containing one or more styles) to a CSS style. This is cached,<tr><td><a id="l6933"></a><a href="#l6933">6933</a><td>  // and also looks for line-wide styles.<tr><td><a id="l6934"></a><a href="#l6934">6934</a><td>  var styleToClassCache = {}, styleToClassCacheWithMode = {};<tr><td><a id="l6935"></a><a href="#l6935">6935</a><td>  function interpretTokenStyle(style, options) {<tr><td><a id="l6936"></a><a href="#l6936">6936</a><td>    if (!style || /^\s*$/.test(style)) return null;<tr><td><a id="l6937"></a><a href="#l6937">6937</a><td>    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;<tr><td><a id="l6938"></a><a href="#l6938">6938</a><td>    return cache[style] ||<tr><td><a id="l6939"></a><a href="#l6939">6939</a><td>      (cache[style] = style.replace(/\S+/g, &quot;cm-$&amp;&quot;));<tr><td><a id="l6940"></a><a href="#l6940">6940</a><td>  }<tr><td><a id="l6941"></a><a href="#l6941">6941</a><td><tr><td><a id="l6942"></a><a href="#l6942">6942</a><td>  // Render the DOM representation of the text of a line. Also builds<tr><td><a id="l6943"></a><a href="#l6943">6943</a><td>  // up a &#39;line map&#39;, which points at the DOM nodes that represent<tr><td><a id="l6944"></a><a href="#l6944">6944</a><td>  // specific stretches of text, and is used by the measuring code.<tr><td><a id="l6945"></a><a href="#l6945">6945</a><td>  // The returned object contains the DOM node, this map, and<tr><td><a id="l6946"></a><a href="#l6946">6946</a><td>  // information about line-wide styles that were set by the mode.<tr><td><a id="l6947"></a><a href="#l6947">6947</a><td>  function buildLineContent(cm, lineView) {<tr><td><a id="l6948"></a><a href="#l6948">6948</a><td>    // The padding-right forces the element to have a &#39;border&#39;, which<tr><td><a id="l6949"></a><a href="#l6949">6949</a><td>    // is needed on Webkit to be able to get line-level bounding<tr><td><a id="l6950"></a><a href="#l6950">6950</a><td>    // rectangles for it (in measureChar).<tr><td><a id="l6951"></a><a href="#l6951">6951</a><td>    var content = elt(&quot;span&quot;, null, null, webkit ? &quot;padding-right: .1px&quot; : null);<tr><td><a id="l6952"></a><a href="#l6952">6952</a><td>    var builder = {pre: elt(&quot;pre&quot;, [content], &quot;CodeMirror-line&quot;), content: content,<tr><td><a id="l6953"></a><a href="#l6953">6953</a><td>                   col: 0, pos: 0, cm: cm,<tr><td><a id="l6954"></a><a href="#l6954">6954</a><td>                   trailingSpace: false,<tr><td><a id="l6955"></a><a href="#l6955">6955</a><td>                   splitSpaces: (ie || webkit) &amp;&amp; cm.getOption(&quot;lineWrapping&quot;)};<tr><td><a id="l6956"></a><a href="#l6956">6956</a><td>    lineView.measure = {};<tr><td><a id="l6957"></a><a href="#l6957">6957</a><td><tr><td><a id="l6958"></a><a href="#l6958">6958</a><td>    // Iterate over the logical lines that make up this visual line.<tr><td><a id="l6959"></a><a href="#l6959">6959</a><td>    for (var i = 0; i &lt;= (lineView.rest ? lineView.rest.length : 0); i++) {<tr><td><a id="l6960"></a><a href="#l6960">6960</a><td>      var line = i ? lineView.rest[i - 1] : lineView.line, order;<tr><td><a id="l6961"></a><a href="#l6961">6961</a><td>      builder.pos = 0;<tr><td><a id="l6962"></a><a href="#l6962">6962</a><td>      builder.addToken = buildToken;<tr><td><a id="l6963"></a><a href="#l6963">6963</a><td>      // Optionally wire in some hacks into the token-rendering<tr><td><a id="l6964"></a><a href="#l6964">6964</a><td>      // algorithm, to deal with browser quirks.<tr><td><a id="l6965"></a><a href="#l6965">6965</a><td>      if (hasBadBidiRects(cm.display.measure) &amp;&amp; (order = getOrder(line)))<tr><td><a id="l6966"></a><a href="#l6966">6966</a><td>        builder.addToken = buildTokenBadBidi(builder.addToken, order);<tr><td><a id="l6967"></a><a href="#l6967">6967</a><td>      builder.map = [];<tr><td><a id="l6968"></a><a href="#l6968">6968</a><td>      var allowFrontierUpdate = lineView != cm.display.externalMeasured &amp;&amp; lineNo(line);<tr><td><a id="l6969"></a><a href="#l6969">6969</a><td>      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));<tr><td><a id="l6970"></a><a href="#l6970">6970</a><td>      if (line.styleClasses) {<tr><td><a id="l6971"></a><a href="#l6971">6971</a><td>        if (line.styleClasses.bgClass)<tr><td><a id="l6972"></a><a href="#l6972">6972</a><td>          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || &quot;&quot;);<tr><td><a id="l6973"></a><a href="#l6973">6973</a><td>        if (line.styleClasses.textClass)<tr><td><a id="l6974"></a><a href="#l6974">6974</a><td>          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || &quot;&quot;);<tr><td><a id="l6975"></a><a href="#l6975">6975</a><td>      }<tr><td><a id="l6976"></a><a href="#l6976">6976</a><td><tr><td><a id="l6977"></a><a href="#l6977">6977</a><td>      // Ensure at least a single node is present, for measuring.<tr><td><a id="l6978"></a><a href="#l6978">6978</a><td>      if (builder.map.length == 0)<tr><td><a id="l6979"></a><a href="#l6979">6979</a><td>        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));<tr><td><a id="l6980"></a><a href="#l6980">6980</a><td><tr><td><a id="l6981"></a><a href="#l6981">6981</a><td>      // Store the map and a cache object for the current logical line<tr><td><a id="l6982"></a><a href="#l6982">6982</a><td>      if (i == 0) {<tr><td><a id="l6983"></a><a href="#l6983">6983</a><td>        lineView.measure.map = builder.map;<tr><td><a id="l6984"></a><a href="#l6984">6984</a><td>        lineView.measure.cache = {};<tr><td><a id="l6985"></a><a href="#l6985">6985</a><td>      } else {<tr><td><a id="l6986"></a><a href="#l6986">6986</a><td>        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);<tr><td><a id="l6987"></a><a href="#l6987">6987</a><td>        (lineView.measure.caches || (lineView.measure.caches = [])).push({});<tr><td><a id="l6988"></a><a href="#l6988">6988</a><td>      }<tr><td><a id="l6989"></a><a href="#l6989">6989</a><td>    }<tr><td><a id="l6990"></a><a href="#l6990">6990</a><td><tr><td><a id="l6991"></a><a href="#l6991">6991</a><td>    // See issue #2901<tr><td><a id="l6992"></a><a href="#l6992">6992</a><td>    if (webkit) {<tr><td><a id="l6993"></a><a href="#l6993">6993</a><td>      var last = builder.content.lastChild<tr><td><a id="l6994"></a><a href="#l6994">6994</a><td>      if (/\bcm-tab\b/.test(last.className) || (last.querySelector &amp;&amp; last.querySelector(&quot;.cm-tab&quot;)))<tr><td><a id="l6995"></a><a href="#l6995">6995</a><td>        builder.content.className = &quot;cm-tab-wrap-hack&quot;;<tr><td><a id="l6996"></a><a href="#l6996">6996</a><td>    }<tr><td><a id="l6997"></a><a href="#l6997">6997</a><td><tr><td><a id="l6998"></a><a href="#l6998">6998</a><td>    signal(cm, &quot;renderLine&quot;, cm, lineView.line, builder.pre);<tr><td><a id="l6999"></a><a href="#l6999">6999</a><td>    if (builder.pre.className)<tr><td><a id="l7000"></a><a href="#l7000">7000</a><td>      builder.textClass = joinClasses(builder.pre.className, builder.textClass || &quot;&quot;);<tr><td><a id="l7001"></a><a href="#l7001">7001</a><td><tr><td><a id="l7002"></a><a href="#l7002">7002</a><td>    return builder;<tr><td><a id="l7003"></a><a href="#l7003">7003</a><td>  }<tr><td><a id="l7004"></a><a href="#l7004">7004</a><td><tr><td><a id="l7005"></a><a href="#l7005">7005</a><td>  function defaultSpecialCharPlaceholder(ch) {<tr><td><a id="l7006"></a><a href="#l7006">7006</a><td>    var token = elt(&quot;span&quot;, &quot;\u2022&quot;, &quot;cm-invalidchar&quot;);<tr><td><a id="l7007"></a><a href="#l7007">7007</a><td>    token.title = &quot;\\u&quot; + ch.charCodeAt(0).toString(16);<tr><td><a id="l7008"></a><a href="#l7008">7008</a><td>    token.setAttribute(&quot;aria-label&quot;, token.title);<tr><td><a id="l7009"></a><a href="#l7009">7009</a><td>    return token;<tr><td><a id="l7010"></a><a href="#l7010">7010</a><td>  }<tr><td><a id="l7011"></a><a href="#l7011">7011</a><td><tr><td><a id="l7012"></a><a href="#l7012">7012</a><td>  // Build up the DOM representation for a single token, and add it to<tr><td><a id="l7013"></a><a href="#l7013">7013</a><td>  // the line map. Takes care to render special characters separately.<tr><td><a id="l7014"></a><a href="#l7014">7014</a><td>  function buildToken(builder, text, style, startStyle, endStyle, title, css) {<tr><td><a id="l7015"></a><a href="#l7015">7015</a><td>    if (!text) return;<tr><td><a id="l7016"></a><a href="#l7016">7016</a><td>    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text<tr><td><a id="l7017"></a><a href="#l7017">7017</a><td>    var special = builder.cm.state.specialChars, mustWrap = false;<tr><td><a id="l7018"></a><a href="#l7018">7018</a><td>    if (!special.test(text)) {<tr><td><a id="l7019"></a><a href="#l7019">7019</a><td>      builder.col += text.length;<tr><td><a id="l7020"></a><a href="#l7020">7020</a><td>      var content = document.createTextNode(displayText);<tr><td><a id="l7021"></a><a href="#l7021">7021</a><td>      builder.map.push(builder.pos, builder.pos + text.length, content);<tr><td><a id="l7022"></a><a href="#l7022">7022</a><td>      if (ie &amp;&amp; ie_version &lt; 9) mustWrap = true;<tr><td><a id="l7023"></a><a href="#l7023">7023</a><td>      builder.pos += text.length;<tr><td><a id="l7024"></a><a href="#l7024">7024</a><td>    } else {<tr><td><a id="l7025"></a><a href="#l7025">7025</a><td>      var content = document.createDocumentFragment(), pos = 0;<tr><td><a id="l7026"></a><a href="#l7026">7026</a><td>      while (true) {<tr><td><a id="l7027"></a><a href="#l7027">7027</a><td>        special.lastIndex = pos;<tr><td><a id="l7028"></a><a href="#l7028">7028</a><td>        var m = special.exec(text);<tr><td><a id="l7029"></a><a href="#l7029">7029</a><td>        var skipped = m ? m.index - pos : text.length - pos;<tr><td><a id="l7030"></a><a href="#l7030">7030</a><td>        if (skipped) {<tr><td><a id="l7031"></a><a href="#l7031">7031</a><td>          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));<tr><td><a id="l7032"></a><a href="#l7032">7032</a><td>          if (ie &amp;&amp; ie_version &lt; 9) content.appendChild(elt(&quot;span&quot;, [txt]));<tr><td><a id="l7033"></a><a href="#l7033">7033</a><td>          else content.appendChild(txt);<tr><td><a id="l7034"></a><a href="#l7034">7034</a><td>          builder.map.push(builder.pos, builder.pos + skipped, txt);<tr><td><a id="l7035"></a><a href="#l7035">7035</a><td>          builder.col += skipped;<tr><td><a id="l7036"></a><a href="#l7036">7036</a><td>          builder.pos += skipped;<tr><td><a id="l7037"></a><a href="#l7037">7037</a><td>        }<tr><td><a id="l7038"></a><a href="#l7038">7038</a><td>        if (!m) break;<tr><td><a id="l7039"></a><a href="#l7039">7039</a><td>        pos += skipped + 1;<tr><td><a id="l7040"></a><a href="#l7040">7040</a><td>        if (m[0] == &quot;\t&quot;) {<tr><td><a id="l7041"></a><a href="#l7041">7041</a><td>          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;<tr><td><a id="l7042"></a><a href="#l7042">7042</a><td>          var txt = content.appendChild(elt(&quot;span&quot;, spaceStr(tabWidth), &quot;cm-tab&quot;));<tr><td><a id="l7043"></a><a href="#l7043">7043</a><td>          txt.setAttribute(&quot;role&quot;, &quot;presentation&quot;);<tr><td><a id="l7044"></a><a href="#l7044">7044</a><td>          txt.setAttribute(&quot;cm-text&quot;, &quot;\t&quot;);<tr><td><a id="l7045"></a><a href="#l7045">7045</a><td>          builder.col += tabWidth;<tr><td><a id="l7046"></a><a href="#l7046">7046</a><td>        } else if (m[0] == &quot;\r&quot; || m[0] == &quot;\n&quot;) {<tr><td><a id="l7047"></a><a href="#l7047">7047</a><td>          var txt = content.appendChild(elt(&quot;span&quot;, m[0] == &quot;\r&quot; ? &quot;\u240d&quot; : &quot;\u2424&quot;, &quot;cm-invalidchar&quot;));<tr><td><a id="l7048"></a><a href="#l7048">7048</a><td>          txt.setAttribute(&quot;cm-text&quot;, m[0]);<tr><td><a id="l7049"></a><a href="#l7049">7049</a><td>          builder.col += 1;<tr><td><a id="l7050"></a><a href="#l7050">7050</a><td>        } else {<tr><td><a id="l7051"></a><a href="#l7051">7051</a><td>          var txt = builder.cm.options.specialCharPlaceholder(m[0]);<tr><td><a id="l7052"></a><a href="#l7052">7052</a><td>          txt.setAttribute(&quot;cm-text&quot;, m[0]);<tr><td><a id="l7053"></a><a href="#l7053">7053</a><td>          if (ie &amp;&amp; ie_version &lt; 9) content.appendChild(elt(&quot;span&quot;, [txt]));<tr><td><a id="l7054"></a><a href="#l7054">7054</a><td>          else content.appendChild(txt);<tr><td><a id="l7055"></a><a href="#l7055">7055</a><td>          builder.col += 1;<tr><td><a id="l7056"></a><a href="#l7056">7056</a><td>        }<tr><td><a id="l7057"></a><a href="#l7057">7057</a><td>        builder.map.push(builder.pos, builder.pos + 1, txt);<tr><td><a id="l7058"></a><a href="#l7058">7058</a><td>        builder.pos++;<tr><td><a id="l7059"></a><a href="#l7059">7059</a><td>      }<tr><td><a id="l7060"></a><a href="#l7060">7060</a><td>    }<tr><td><a id="l7061"></a><a href="#l7061">7061</a><td>    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32<tr><td><a id="l7062"></a><a href="#l7062">7062</a><td>    if (style || startStyle || endStyle || mustWrap || css) {<tr><td><a id="l7063"></a><a href="#l7063">7063</a><td>      var fullStyle = style || &quot;&quot;;<tr><td><a id="l7064"></a><a href="#l7064">7064</a><td>      if (startStyle) fullStyle += startStyle;<tr><td><a id="l7065"></a><a href="#l7065">7065</a><td>      if (endStyle) fullStyle += endStyle;<tr><td><a id="l7066"></a><a href="#l7066">7066</a><td>      var token = elt(&quot;span&quot;, [content], fullStyle, css);<tr><td><a id="l7067"></a><a href="#l7067">7067</a><td>      if (title) token.title = title;<tr><td><a id="l7068"></a><a href="#l7068">7068</a><td>      return builder.content.appendChild(token);<tr><td><a id="l7069"></a><a href="#l7069">7069</a><td>    }<tr><td><a id="l7070"></a><a href="#l7070">7070</a><td>    builder.content.appendChild(content);<tr><td><a id="l7071"></a><a href="#l7071">7071</a><td>  }<tr><td><a id="l7072"></a><a href="#l7072">7072</a><td><tr><td><a id="l7073"></a><a href="#l7073">7073</a><td>  function splitSpaces(text, trailingBefore) {<tr><td><a id="l7074"></a><a href="#l7074">7074</a><td>    if (text.length &gt; 1 &amp;&amp; !/  /.test(text)) return text<tr><td><a id="l7075"></a><a href="#l7075">7075</a><td>    var spaceBefore = trailingBefore, result = &quot;&quot;<tr><td><a id="l7076"></a><a href="#l7076">7076</a><td>    for (var i = 0; i &lt; text.length; i++) {<tr><td><a id="l7077"></a><a href="#l7077">7077</a><td>      var ch = text.charAt(i)<tr><td><a id="l7078"></a><a href="#l7078">7078</a><td>      if (ch == &quot; &quot; &amp;&amp; spaceBefore &amp;&amp; (i == text.length - 1 || text.charCodeAt(i + 1) == 32))<tr><td><a id="l7079"></a><a href="#l7079">7079</a><td>        ch = &quot;\u00a0&quot;<tr><td><a id="l7080"></a><a href="#l7080">7080</a><td>      result += ch<tr><td><a id="l7081"></a><a href="#l7081">7081</a><td>      spaceBefore = ch == &quot; &quot;<tr><td><a id="l7082"></a><a href="#l7082">7082</a><td>    }<tr><td><a id="l7083"></a><a href="#l7083">7083</a><td>    return result<tr><td><a id="l7084"></a><a href="#l7084">7084</a><td>  }<tr><td><a id="l7085"></a><a href="#l7085">7085</a><td><tr><td><a id="l7086"></a><a href="#l7086">7086</a><td>  // Work around nonsense dimensions being reported for stretches of<tr><td><a id="l7087"></a><a href="#l7087">7087</a><td>  // right-to-left text.<tr><td><a id="l7088"></a><a href="#l7088">7088</a><td>  function buildTokenBadBidi(inner, order) {<tr><td><a id="l7089"></a><a href="#l7089">7089</a><td>    return function(builder, text, style, startStyle, endStyle, title, css) {<tr><td><a id="l7090"></a><a href="#l7090">7090</a><td>      style = style ? style + &quot; cm-force-border&quot; : &quot;cm-force-border&quot;;<tr><td><a id="l7091"></a><a href="#l7091">7091</a><td>      var start = builder.pos, end = start + text.length;<tr><td><a id="l7092"></a><a href="#l7092">7092</a><td>      for (;;) {<tr><td><a id="l7093"></a><a href="#l7093">7093</a><td>        // Find the part that overlaps with the start of this text<tr><td><a id="l7094"></a><a href="#l7094">7094</a><td>        for (var i = 0; i &lt; order.length; i++) {<tr><td><a id="l7095"></a><a href="#l7095">7095</a><td>          var part = order[i];<tr><td><a id="l7096"></a><a href="#l7096">7096</a><td>          if (part.to &gt; start &amp;&amp; part.from &lt;= start) break;<tr><td><a id="l7097"></a><a href="#l7097">7097</a><td>        }<tr><td><a id="l7098"></a><a href="#l7098">7098</a><td>        if (part.to &gt;= end) return inner(builder, text, style, startStyle, endStyle, title, css);<tr><td><a id="l7099"></a><a href="#l7099">7099</a><td>        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);<tr><td><a id="l7100"></a><a href="#l7100">7100</a><td>        startStyle = null;<tr><td><a id="l7101"></a><a href="#l7101">7101</a><td>        text = text.slice(part.to - start);<tr><td><a id="l7102"></a><a href="#l7102">7102</a><td>        start = part.to;<tr><td><a id="l7103"></a><a href="#l7103">7103</a><td>      }<tr><td><a id="l7104"></a><a href="#l7104">7104</a><td>    };<tr><td><a id="l7105"></a><a href="#l7105">7105</a><td>  }<tr><td><a id="l7106"></a><a href="#l7106">7106</a><td><tr><td><a id="l7107"></a><a href="#l7107">7107</a><td>  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {<tr><td><a id="l7108"></a><a href="#l7108">7108</a><td>    var widget = !ignoreWidget &amp;&amp; marker.widgetNode;<tr><td><a id="l7109"></a><a href="#l7109">7109</a><td>    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);<tr><td><a id="l7110"></a><a href="#l7110">7110</a><td>    if (!ignoreWidget &amp;&amp; builder.cm.display.input.needsContentAttribute) {<tr><td><a id="l7111"></a><a href="#l7111">7111</a><td>      if (!widget)<tr><td><a id="l7112"></a><a href="#l7112">7112</a><td>        widget = builder.content.appendChild(document.createElement(&quot;span&quot;));<tr><td><a id="l7113"></a><a href="#l7113">7113</a><td>      widget.setAttribute(&quot;cm-marker&quot;, marker.id);<tr><td><a id="l7114"></a><a href="#l7114">7114</a><td>    }<tr><td><a id="l7115"></a><a href="#l7115">7115</a><td>    if (widget) {<tr><td><a id="l7116"></a><a href="#l7116">7116</a><td>      builder.cm.display.input.setUneditable(widget);<tr><td><a id="l7117"></a><a href="#l7117">7117</a><td>      builder.content.appendChild(widget);<tr><td><a id="l7118"></a><a href="#l7118">7118</a><td>    }<tr><td><a id="l7119"></a><a href="#l7119">7119</a><td>    builder.pos += size;<tr><td><a id="l7120"></a><a href="#l7120">7120</a><td>    builder.trailingSpace = false<tr><td><a id="l7121"></a><a href="#l7121">7121</a><td>  }<tr><td><a id="l7122"></a><a href="#l7122">7122</a><td><tr><td><a id="l7123"></a><a href="#l7123">7123</a><td>  // Outputs a number of spans to make up a line, taking highlighting<tr><td><a id="l7124"></a><a href="#l7124">7124</a><td>  // and marked text into account.<tr><td><a id="l7125"></a><a href="#l7125">7125</a><td>  function insertLineContent(line, builder, styles) {<tr><td><a id="l7126"></a><a href="#l7126">7126</a><td>    var spans = line.markedSpans, allText = line.text, at = 0;<tr><td><a id="l7127"></a><a href="#l7127">7127</a><td>    if (!spans) {<tr><td><a id="l7128"></a><a href="#l7128">7128</a><td>      for (var i = 1; i &lt; styles.length; i+=2)<tr><td><a id="l7129"></a><a href="#l7129">7129</a><td>        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));<tr><td><a id="l7130"></a><a href="#l7130">7130</a><td>      return;<tr><td><a id="l7131"></a><a href="#l7131">7131</a><td>    }<tr><td><a id="l7132"></a><a href="#l7132">7132</a><td><tr><td><a id="l7133"></a><a href="#l7133">7133</a><td>    var len = allText.length, pos = 0, i = 1, text = &quot;&quot;, style, css;<tr><td><a id="l7134"></a><a href="#l7134">7134</a><td>    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;<tr><td><a id="l7135"></a><a href="#l7135">7135</a><td>    for (;;) {<tr><td><a id="l7136"></a><a href="#l7136">7136</a><td>      if (nextChange == pos) { // Update current marker set<tr><td><a id="l7137"></a><a href="#l7137">7137</a><td>        spanStyle = spanEndStyle = spanStartStyle = title = css = &quot;&quot;;<tr><td><a id="l7138"></a><a href="#l7138">7138</a><td>        collapsed = null; nextChange = Infinity;<tr><td><a id="l7139"></a><a href="#l7139">7139</a><td>        var foundBookmarks = [], endStyles<tr><td><a id="l7140"></a><a href="#l7140">7140</a><td>        for (var j = 0; j &lt; spans.length; ++j) {<tr><td><a id="l7141"></a><a href="#l7141">7141</a><td>          var sp = spans[j], m = sp.marker;<tr><td><a id="l7142"></a><a href="#l7142">7142</a><td>          if (m.type == &quot;bookmark&quot; &amp;&amp; sp.from == pos &amp;&amp; m.widgetNode) {<tr><td><a id="l7143"></a><a href="#l7143">7143</a><td>            foundBookmarks.push(m);<tr><td><a id="l7144"></a><a href="#l7144">7144</a><td>          } else if (sp.from &lt;= pos &amp;&amp; (sp.to == null || sp.to &gt; pos || m.collapsed &amp;&amp; sp.to == pos &amp;&amp; sp.from == pos)) {<tr><td><a id="l7145"></a><a href="#l7145">7145</a><td>            if (sp.to != null &amp;&amp; sp.to != pos &amp;&amp; nextChange &gt; sp.to) {<tr><td><a id="l7146"></a><a href="#l7146">7146</a><td>              nextChange = sp.to;<tr><td><a id="l7147"></a><a href="#l7147">7147</a><td>              spanEndStyle = &quot;&quot;;<tr><td><a id="l7148"></a><a href="#l7148">7148</a><td>            }<tr><td><a id="l7149"></a><a href="#l7149">7149</a><td>            if (m.className) spanStyle += &quot; &quot; + m.className;<tr><td><a id="l7150"></a><a href="#l7150">7150</a><td>            if (m.css) css = (css ? css + &quot;;&quot; : &quot;&quot;) + m.css;<tr><td><a id="l7151"></a><a href="#l7151">7151</a><td>            if (m.startStyle &amp;&amp; sp.from == pos) spanStartStyle += &quot; &quot; + m.startStyle;<tr><td><a id="l7152"></a><a href="#l7152">7152</a><td>            if (m.endStyle &amp;&amp; sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)<tr><td><a id="l7153"></a><a href="#l7153">7153</a><td>            if (m.title &amp;&amp; !title) title = m.title;<tr><td><a id="l7154"></a><a href="#l7154">7154</a><td>            if (m.collapsed &amp;&amp; (!collapsed || compareCollapsedMarkers(collapsed.marker, m) &lt; 0))<tr><td><a id="l7155"></a><a href="#l7155">7155</a><td>              collapsed = sp;<tr><td><a id="l7156"></a><a href="#l7156">7156</a><td>          } else if (sp.from &gt; pos &amp;&amp; nextChange &gt; sp.from) {<tr><td><a id="l7157"></a><a href="#l7157">7157</a><td>            nextChange = sp.from;<tr><td><a id="l7158"></a><a href="#l7158">7158</a><td>          }<tr><td><a id="l7159"></a><a href="#l7159">7159</a><td>        }<tr><td><a id="l7160"></a><a href="#l7160">7160</a><td>        if (endStyles) for (var j = 0; j &lt; endStyles.length; j += 2)<tr><td><a id="l7161"></a><a href="#l7161">7161</a><td>          if (endStyles[j + 1] == nextChange) spanEndStyle += &quot; &quot; + endStyles[j]<tr><td><a id="l7162"></a><a href="#l7162">7162</a><td><tr><td><a id="l7163"></a><a href="#l7163">7163</a><td>        if (!collapsed || collapsed.from == pos) for (var j = 0; j &lt; foundBookmarks.length; ++j)<tr><td><a id="l7164"></a><a href="#l7164">7164</a><td>          buildCollapsedSpan(builder, 0, foundBookmarks[j]);<tr><td><a id="l7165"></a><a href="#l7165">7165</a><td>        if (collapsed &amp;&amp; (collapsed.from || 0) == pos) {<tr><td><a id="l7166"></a><a href="#l7166">7166</a><td>          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,<tr><td><a id="l7167"></a><a href="#l7167">7167</a><td>                             collapsed.marker, collapsed.from == null);<tr><td><a id="l7168"></a><a href="#l7168">7168</a><td>          if (collapsed.to == null) return;<tr><td><a id="l7169"></a><a href="#l7169">7169</a><td>          if (collapsed.to == pos) collapsed = false;<tr><td><a id="l7170"></a><a href="#l7170">7170</a><td>        }<tr><td><a id="l7171"></a><a href="#l7171">7171</a><td>      }<tr><td><a id="l7172"></a><a href="#l7172">7172</a><td>      if (pos &gt;= len) break;<tr><td><a id="l7173"></a><a href="#l7173">7173</a><td><tr><td><a id="l7174"></a><a href="#l7174">7174</a><td>      var upto = Math.min(len, nextChange);<tr><td><a id="l7175"></a><a href="#l7175">7175</a><td>      while (true) {<tr><td><a id="l7176"></a><a href="#l7176">7176</a><td>        if (text) {<tr><td><a id="l7177"></a><a href="#l7177">7177</a><td>          var end = pos + text.length;<tr><td><a id="l7178"></a><a href="#l7178">7178</a><td>          if (!collapsed) {<tr><td><a id="l7179"></a><a href="#l7179">7179</a><td>            var tokenText = end &gt; upto ? text.slice(0, upto - pos) : text;<tr><td><a id="l7180"></a><a href="#l7180">7180</a><td>            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,<tr><td><a id="l7181"></a><a href="#l7181">7181</a><td>                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : &quot;&quot;, title, css);<tr><td><a id="l7182"></a><a href="#l7182">7182</a><td>          }<tr><td><a id="l7183"></a><a href="#l7183">7183</a><td>          if (end &gt;= upto) {text = text.slice(upto - pos); pos = upto; break;}<tr><td><a id="l7184"></a><a href="#l7184">7184</a><td>          pos = end;<tr><td><a id="l7185"></a><a href="#l7185">7185</a><td>          spanStartStyle = &quot;&quot;;<tr><td><a id="l7186"></a><a href="#l7186">7186</a><td>        }<tr><td><a id="l7187"></a><a href="#l7187">7187</a><td>        text = allText.slice(at, at = styles[i++]);<tr><td><a id="l7188"></a><a href="#l7188">7188</a><td>        style = interpretTokenStyle(styles[i++], builder.cm.options);<tr><td><a id="l7189"></a><a href="#l7189">7189</a><td>      }<tr><td><a id="l7190"></a><a href="#l7190">7190</a><td>    }<tr><td><a id="l7191"></a><a href="#l7191">7191</a><td>  }<tr><td><a id="l7192"></a><a href="#l7192">7192</a><td><tr><td><a id="l7193"></a><a href="#l7193">7193</a><td>  // DOCUMENT DATA STRUCTURE<tr><td><a id="l7194"></a><a href="#l7194">7194</a><td><tr><td><a id="l7195"></a><a href="#l7195">7195</a><td>  // By default, updates that start and end at the beginning of a line<tr><td><a id="l7196"></a><a href="#l7196">7196</a><td>  // are treated specially, in order to make the association of line<tr><td><a id="l7197"></a><a href="#l7197">7197</a><td>  // widgets and marker elements with the text behave more intuitive.<tr><td><a id="l7198"></a><a href="#l7198">7198</a><td>  function isWholeLineUpdate(doc, change) {<tr><td><a id="l7199"></a><a href="#l7199">7199</a><td>    return change.from.ch == 0 &amp;&amp; change.to.ch == 0 &amp;&amp; lst(change.text) == &quot;&quot; &amp;&amp;<tr><td><a id="l7200"></a><a href="#l7200">7200</a><td>      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);<tr><td><a id="l7201"></a><a href="#l7201">7201</a><td>  }<tr><td><a id="l7202"></a><a href="#l7202">7202</a><td><tr><td><a id="l7203"></a><a href="#l7203">7203</a><td>  // Perform a change on the document data structure.<tr><td><a id="l7204"></a><a href="#l7204">7204</a><td>  function updateDoc(doc, change, markedSpans, estimateHeight) {<tr><td><a id="l7205"></a><a href="#l7205">7205</a><td>    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}<tr><td><a id="l7206"></a><a href="#l7206">7206</a><td>    function update(line, text, spans) {<tr><td><a id="l7207"></a><a href="#l7207">7207</a><td>      updateLine(line, text, spans, estimateHeight);<tr><td><a id="l7208"></a><a href="#l7208">7208</a><td>      signalLater(line, &quot;change&quot;, line, change);<tr><td><a id="l7209"></a><a href="#l7209">7209</a><td>    }<tr><td><a id="l7210"></a><a href="#l7210">7210</a><td>    function linesFor(start, end) {<tr><td><a id="l7211"></a><a href="#l7211">7211</a><td>      for (var i = start, result = []; i &lt; end; ++i)<tr><td><a id="l7212"></a><a href="#l7212">7212</a><td>        result.push(new Line(text[i], spansFor(i), estimateHeight));<tr><td><a id="l7213"></a><a href="#l7213">7213</a><td>      return result;<tr><td><a id="l7214"></a><a href="#l7214">7214</a><td>    }<tr><td><a id="l7215"></a><a href="#l7215">7215</a><td><tr><td><a id="l7216"></a><a href="#l7216">7216</a><td>    var from = change.from, to = change.to, text = change.text;<tr><td><a id="l7217"></a><a href="#l7217">7217</a><td>    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);<tr><td><a id="l7218"></a><a href="#l7218">7218</a><td>    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;<tr><td><a id="l7219"></a><a href="#l7219">7219</a><td><tr><td><a id="l7220"></a><a href="#l7220">7220</a><td>    // Adjust the line structure<tr><td><a id="l7221"></a><a href="#l7221">7221</a><td>    if (change.full) {<tr><td><a id="l7222"></a><a href="#l7222">7222</a><td>      doc.insert(0, linesFor(0, text.length));<tr><td><a id="l7223"></a><a href="#l7223">7223</a><td>      doc.remove(text.length, doc.size - text.length);<tr><td><a id="l7224"></a><a href="#l7224">7224</a><td>    } else if (isWholeLineUpdate(doc, change)) {<tr><td><a id="l7225"></a><a href="#l7225">7225</a><td>      // This is a whole-line replace. Treated specially to make<tr><td><a id="l7226"></a><a href="#l7226">7226</a><td>      // sure line objects move the way they are supposed to.<tr><td><a id="l7227"></a><a href="#l7227">7227</a><td>      var added = linesFor(0, text.length - 1);<tr><td><a id="l7228"></a><a href="#l7228">7228</a><td>      update(lastLine, lastLine.text, lastSpans);<tr><td><a id="l7229"></a><a href="#l7229">7229</a><td>      if (nlines) doc.remove(from.line, nlines);<tr><td><a id="l7230"></a><a href="#l7230">7230</a><td>      if (added.length) doc.insert(from.line, added);<tr><td><a id="l7231"></a><a href="#l7231">7231</a><td>    } else if (firstLine == lastLine) {<tr><td><a id="l7232"></a><a href="#l7232">7232</a><td>      if (text.length == 1) {<tr><td><a id="l7233"></a><a href="#l7233">7233</a><td>        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);<tr><td><a id="l7234"></a><a href="#l7234">7234</a><td>      } else {<tr><td><a id="l7235"></a><a href="#l7235">7235</a><td>        var added = linesFor(1, text.length - 1);<tr><td><a id="l7236"></a><a href="#l7236">7236</a><td>        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));<tr><td><a id="l7237"></a><a href="#l7237">7237</a><td>        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));<tr><td><a id="l7238"></a><a href="#l7238">7238</a><td>        doc.insert(from.line + 1, added);<tr><td><a id="l7239"></a><a href="#l7239">7239</a><td>      }<tr><td><a id="l7240"></a><a href="#l7240">7240</a><td>    } else if (text.length == 1) {<tr><td><a id="l7241"></a><a href="#l7241">7241</a><td>      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));<tr><td><a id="l7242"></a><a href="#l7242">7242</a><td>      doc.remove(from.line + 1, nlines);<tr><td><a id="l7243"></a><a href="#l7243">7243</a><td>    } else {<tr><td><a id="l7244"></a><a href="#l7244">7244</a><td>      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));<tr><td><a id="l7245"></a><a href="#l7245">7245</a><td>      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);<tr><td><a id="l7246"></a><a href="#l7246">7246</a><td>      var added = linesFor(1, text.length - 1);<tr><td><a id="l7247"></a><a href="#l7247">7247</a><td>      if (nlines &gt; 1) doc.remove(from.line + 1, nlines - 1);<tr><td><a id="l7248"></a><a href="#l7248">7248</a><td>      doc.insert(from.line + 1, added);<tr><td><a id="l7249"></a><a href="#l7249">7249</a><td>    }<tr><td><a id="l7250"></a><a href="#l7250">7250</a><td><tr><td><a id="l7251"></a><a href="#l7251">7251</a><td>    signalLater(doc, &quot;change&quot;, doc, change);<tr><td><a id="l7252"></a><a href="#l7252">7252</a><td>  }<tr><td><a id="l7253"></a><a href="#l7253">7253</a><td><tr><td><a id="l7254"></a><a href="#l7254">7254</a><td>  // The document is represented as a BTree consisting of leaves, with<tr><td><a id="l7255"></a><a href="#l7255">7255</a><td>  // chunk of lines in them, and branches, with up to ten leaves or<tr><td><a id="l7256"></a><a href="#l7256">7256</a><td>  // other branch nodes below them. The top node is always a branch<tr><td><a id="l7257"></a><a href="#l7257">7257</a><td>  // node, and is the document object itself (meaning it has<tr><td><a id="l7258"></a><a href="#l7258">7258</a><td>  // additional methods and properties).<tr><td><a id="l7259"></a><a href="#l7259">7259</a><td>  //<tr><td><a id="l7260"></a><a href="#l7260">7260</a><td>  // All nodes have parent links. The tree is used both to go from<tr><td><a id="l7261"></a><a href="#l7261">7261</a><td>  // line numbers to line objects, and to go from objects to numbers.<tr><td><a id="l7262"></a><a href="#l7262">7262</a><td>  // It also indexes by height, and is used to convert between height<tr><td><a id="l7263"></a><a href="#l7263">7263</a><td>  // and line object, and to find the total height of the document.<tr><td><a id="l7264"></a><a href="#l7264">7264</a><td>  //<tr><td><a id="l7265"></a><a href="#l7265">7265</a><td>  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html<tr><td><a id="l7266"></a><a href="#l7266">7266</a><td><tr><td><a id="l7267"></a><a href="#l7267">7267</a><td>  function LeafChunk(lines) {<tr><td><a id="l7268"></a><a href="#l7268">7268</a><td>    this.lines = lines;<tr><td><a id="l7269"></a><a href="#l7269">7269</a><td>    this.parent = null;<tr><td><a id="l7270"></a><a href="#l7270">7270</a><td>    for (var i = 0, height = 0; i &lt; lines.length; ++i) {<tr><td><a id="l7271"></a><a href="#l7271">7271</a><td>      lines[i].parent = this;<tr><td><a id="l7272"></a><a href="#l7272">7272</a><td>      height += lines[i].height;<tr><td><a id="l7273"></a><a href="#l7273">7273</a><td>    }<tr><td><a id="l7274"></a><a href="#l7274">7274</a><td>    this.height = height;<tr><td><a id="l7275"></a><a href="#l7275">7275</a><td>  }<tr><td><a id="l7276"></a><a href="#l7276">7276</a><td><tr><td><a id="l7277"></a><a href="#l7277">7277</a><td>  LeafChunk.prototype = {<tr><td><a id="l7278"></a><a href="#l7278">7278</a><td>    chunkSize: function() { return this.lines.length; },<tr><td><a id="l7279"></a><a href="#l7279">7279</a><td>    // Remove the n lines at offset &#39;at&#39;.<tr><td><a id="l7280"></a><a href="#l7280">7280</a><td>    removeInner: function(at, n) {<tr><td><a id="l7281"></a><a href="#l7281">7281</a><td>      for (var i = at, e = at + n; i &lt; e; ++i) {<tr><td><a id="l7282"></a><a href="#l7282">7282</a><td>        var line = this.lines[i];<tr><td><a id="l7283"></a><a href="#l7283">7283</a><td>        this.height -= line.height;<tr><td><a id="l7284"></a><a href="#l7284">7284</a><td>        cleanUpLine(line);<tr><td><a id="l7285"></a><a href="#l7285">7285</a><td>        signalLater(line, &quot;delete&quot;);<tr><td><a id="l7286"></a><a href="#l7286">7286</a><td>      }<tr><td><a id="l7287"></a><a href="#l7287">7287</a><td>      this.lines.splice(at, n);<tr><td><a id="l7288"></a><a href="#l7288">7288</a><td>    },<tr><td><a id="l7289"></a><a href="#l7289">7289</a><td>    // Helper used to collapse a small branch into a single leaf.<tr><td><a id="l7290"></a><a href="#l7290">7290</a><td>    collapse: function(lines) {<tr><td><a id="l7291"></a><a href="#l7291">7291</a><td>      lines.push.apply(lines, this.lines);<tr><td><a id="l7292"></a><a href="#l7292">7292</a><td>    },<tr><td><a id="l7293"></a><a href="#l7293">7293</a><td>    // Insert the given array of lines at offset &#39;at&#39;, count them as<tr><td><a id="l7294"></a><a href="#l7294">7294</a><td>    // having the given height.<tr><td><a id="l7295"></a><a href="#l7295">7295</a><td>    insertInner: function(at, lines, height) {<tr><td><a id="l7296"></a><a href="#l7296">7296</a><td>      this.height += height;<tr><td><a id="l7297"></a><a href="#l7297">7297</a><td>      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));<tr><td><a id="l7298"></a><a href="#l7298">7298</a><td>      for (var i = 0; i &lt; lines.length; ++i) lines[i].parent = this;<tr><td><a id="l7299"></a><a href="#l7299">7299</a><td>    },<tr><td><a id="l7300"></a><a href="#l7300">7300</a><td>    // Used to iterate over a part of the tree.<tr><td><a id="l7301"></a><a href="#l7301">7301</a><td>    iterN: function(at, n, op) {<tr><td><a id="l7302"></a><a href="#l7302">7302</a><td>      for (var e = at + n; at &lt; e; ++at)<tr><td><a id="l7303"></a><a href="#l7303">7303</a><td>        if (op(this.lines[at])) return true;<tr><td><a id="l7304"></a><a href="#l7304">7304</a><td>    }<tr><td><a id="l7305"></a><a href="#l7305">7305</a><td>  };<tr><td><a id="l7306"></a><a href="#l7306">7306</a><td><tr><td><a id="l7307"></a><a href="#l7307">7307</a><td>  function BranchChunk(children) {<tr><td><a id="l7308"></a><a href="#l7308">7308</a><td>    this.children = children;<tr><td><a id="l7309"></a><a href="#l7309">7309</a><td>    var size = 0, height = 0;<tr><td><a id="l7310"></a><a href="#l7310">7310</a><td>    for (var i = 0; i &lt; children.length; ++i) {<tr><td><a id="l7311"></a><a href="#l7311">7311</a><td>      var ch = children[i];<tr><td><a id="l7312"></a><a href="#l7312">7312</a><td>      size += ch.chunkSize(); height += ch.height;<tr><td><a id="l7313"></a><a href="#l7313">7313</a><td>      ch.parent = this;<tr><td><a id="l7314"></a><a href="#l7314">7314</a><td>    }<tr><td><a id="l7315"></a><a href="#l7315">7315</a><td>    this.size = size;<tr><td><a id="l7316"></a><a href="#l7316">7316</a><td>    this.height = height;<tr><td><a id="l7317"></a><a href="#l7317">7317</a><td>    this.parent = null;<tr><td><a id="l7318"></a><a href="#l7318">7318</a><td>  }<tr><td><a id="l7319"></a><a href="#l7319">7319</a><td><tr><td><a id="l7320"></a><a href="#l7320">7320</a><td>  BranchChunk.prototype = {<tr><td><a id="l7321"></a><a href="#l7321">7321</a><td>    chunkSize: function() { return this.size; },<tr><td><a id="l7322"></a><a href="#l7322">7322</a><td>    removeInner: function(at, n) {<tr><td><a id="l7323"></a><a href="#l7323">7323</a><td>      this.size -= n;<tr><td><a id="l7324"></a><a href="#l7324">7324</a><td>      for (var i = 0; i &lt; this.children.length; ++i) {<tr><td><a id="l7325"></a><a href="#l7325">7325</a><td>        var child = this.children[i], sz = child.chunkSize();<tr><td><a id="l7326"></a><a href="#l7326">7326</a><td>        if (at &lt; sz) {<tr><td><a id="l7327"></a><a href="#l7327">7327</a><td>          var rm = Math.min(n, sz - at), oldHeight = child.height;<tr><td><a id="l7328"></a><a href="#l7328">7328</a><td>          child.removeInner(at, rm);<tr><td><a id="l7329"></a><a href="#l7329">7329</a><td>          this.height -= oldHeight - child.height;<tr><td><a id="l7330"></a><a href="#l7330">7330</a><td>          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }<tr><td><a id="l7331"></a><a href="#l7331">7331</a><td>          if ((n -= rm) == 0) break;<tr><td><a id="l7332"></a><a href="#l7332">7332</a><td>          at = 0;<tr><td><a id="l7333"></a><a href="#l7333">7333</a><td>        } else at -= sz;<tr><td><a id="l7334"></a><a href="#l7334">7334</a><td>      }<tr><td><a id="l7335"></a><a href="#l7335">7335</a><td>      // If the result is smaller than 25 lines, ensure that it is a<tr><td><a id="l7336"></a><a href="#l7336">7336</a><td>      // single leaf node.<tr><td><a id="l7337"></a><a href="#l7337">7337</a><td>      if (this.size - n &lt; 25 &amp;&amp;<tr><td><a id="l7338"></a><a href="#l7338">7338</a><td>          (this.children.length &gt; 1 || !(this.children[0] instanceof LeafChunk))) {<tr><td><a id="l7339"></a><a href="#l7339">7339</a><td>        var lines = [];<tr><td><a id="l7340"></a><a href="#l7340">7340</a><td>        this.collapse(lines);<tr><td><a id="l7341"></a><a href="#l7341">7341</a><td>        this.children = [new LeafChunk(lines)];<tr><td><a id="l7342"></a><a href="#l7342">7342</a><td>        this.children[0].parent = this;<tr><td><a id="l7343"></a><a href="#l7343">7343</a><td>      }<tr><td><a id="l7344"></a><a href="#l7344">7344</a><td>    },<tr><td><a id="l7345"></a><a href="#l7345">7345</a><td>    collapse: function(lines) {<tr><td><a id="l7346"></a><a href="#l7346">7346</a><td>      for (var i = 0; i &lt; this.children.length; ++i) this.children[i].collapse(lines);<tr><td><a id="l7347"></a><a href="#l7347">7347</a><td>    },<tr><td><a id="l7348"></a><a href="#l7348">7348</a><td>    insertInner: function(at, lines, height) {<tr><td><a id="l7349"></a><a href="#l7349">7349</a><td>      this.size += lines.length;<tr><td><a id="l7350"></a><a href="#l7350">7350</a><td>      this.height += height;<tr><td><a id="l7351"></a><a href="#l7351">7351</a><td>      for (var i = 0; i &lt; this.children.length; ++i) {<tr><td><a id="l7352"></a><a href="#l7352">7352</a><td>        var child = this.children[i], sz = child.chunkSize();<tr><td><a id="l7353"></a><a href="#l7353">7353</a><td>        if (at &lt;= sz) {<tr><td><a id="l7354"></a><a href="#l7354">7354</a><td>          child.insertInner(at, lines, height);<tr><td><a id="l7355"></a><a href="#l7355">7355</a><td>          if (child.lines &amp;&amp; child.lines.length &gt; 50) {<tr><td><a id="l7356"></a><a href="#l7356">7356</a><td>            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it&#39;s never spliced.<tr><td><a id="l7357"></a><a href="#l7357">7357</a><td>            // Instead, small slices are taken. They&#39;re taken in order because sequential memory accesses are fastest.<tr><td><a id="l7358"></a><a href="#l7358">7358</a><td>            var remaining = child.lines.length % 25 + 25<tr><td><a id="l7359"></a><a href="#l7359">7359</a><td>            for (var pos = remaining; pos &lt; child.lines.length;) {<tr><td><a id="l7360"></a><a href="#l7360">7360</a><td>              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));<tr><td><a id="l7361"></a><a href="#l7361">7361</a><td>              child.height -= leaf.height;<tr><td><a id="l7362"></a><a href="#l7362">7362</a><td>              this.children.splice(++i, 0, leaf);<tr><td><a id="l7363"></a><a href="#l7363">7363</a><td>              leaf.parent = this;<tr><td><a id="l7364"></a><a href="#l7364">7364</a><td>            }<tr><td><a id="l7365"></a><a href="#l7365">7365</a><td>            child.lines = child.lines.slice(0, remaining);<tr><td><a id="l7366"></a><a href="#l7366">7366</a><td>            this.maybeSpill();<tr><td><a id="l7367"></a><a href="#l7367">7367</a><td>          }<tr><td><a id="l7368"></a><a href="#l7368">7368</a><td>          break;<tr><td><a id="l7369"></a><a href="#l7369">7369</a><td>        }<tr><td><a id="l7370"></a><a href="#l7370">7370</a><td>        at -= sz;<tr><td><a id="l7371"></a><a href="#l7371">7371</a><td>      }<tr><td><a id="l7372"></a><a href="#l7372">7372</a><td>    },<tr><td><a id="l7373"></a><a href="#l7373">7373</a><td>    // When a node has grown, check whether it should be split.<tr><td><a id="l7374"></a><a href="#l7374">7374</a><td>    maybeSpill: function() {<tr><td><a id="l7375"></a><a href="#l7375">7375</a><td>      if (this.children.length &lt;= 10) return;<tr><td><a id="l7376"></a><a href="#l7376">7376</a><td>      var me = this;<tr><td><a id="l7377"></a><a href="#l7377">7377</a><td>      do {<tr><td><a id="l7378"></a><a href="#l7378">7378</a><td>        var spilled = me.children.splice(me.children.length - 5, 5);<tr><td><a id="l7379"></a><a href="#l7379">7379</a><td>        var sibling = new BranchChunk(spilled);<tr><td><a id="l7380"></a><a href="#l7380">7380</a><td>        if (!me.parent) { // Become the parent node<tr><td><a id="l7381"></a><a href="#l7381">7381</a><td>          var copy = new BranchChunk(me.children);<tr><td><a id="l7382"></a><a href="#l7382">7382</a><td>          copy.parent = me;<tr><td><a id="l7383"></a><a href="#l7383">7383</a><td>          me.children = [copy, sibling];<tr><td><a id="l7384"></a><a href="#l7384">7384</a><td>          me = copy;<tr><td><a id="l7385"></a><a href="#l7385">7385</a><td>       } else {<tr><td><a id="l7386"></a><a href="#l7386">7386</a><td>          me.size -= sibling.size;<tr><td><a id="l7387"></a><a href="#l7387">7387</a><td>          me.height -= sibling.height;<tr><td><a id="l7388"></a><a href="#l7388">7388</a><td>          var myIndex = indexOf(me.parent.children, me);<tr><td><a id="l7389"></a><a href="#l7389">7389</a><td>          me.parent.children.splice(myIndex + 1, 0, sibling);<tr><td><a id="l7390"></a><a href="#l7390">7390</a><td>        }<tr><td><a id="l7391"></a><a href="#l7391">7391</a><td>        sibling.parent = me.parent;<tr><td><a id="l7392"></a><a href="#l7392">7392</a><td>      } while (me.children.length &gt; 10);<tr><td><a id="l7393"></a><a href="#l7393">7393</a><td>      me.parent.maybeSpill();<tr><td><a id="l7394"></a><a href="#l7394">7394</a><td>    },<tr><td><a id="l7395"></a><a href="#l7395">7395</a><td>    iterN: function(at, n, op) {<tr><td><a id="l7396"></a><a href="#l7396">7396</a><td>      for (var i = 0; i &lt; this.children.length; ++i) {<tr><td><a id="l7397"></a><a href="#l7397">7397</a><td>        var child = this.children[i], sz = child.chunkSize();<tr><td><a id="l7398"></a><a href="#l7398">7398</a><td>        if (at &lt; sz) {<tr><td><a id="l7399"></a><a href="#l7399">7399</a><td>          var used = Math.min(n, sz - at);<tr><td><a id="l7400"></a><a href="#l7400">7400</a><td>          if (child.iterN(at, used, op)) return true;<tr><td><a id="l7401"></a><a href="#l7401">7401</a><td>          if ((n -= used) == 0) break;<tr><td><a id="l7402"></a><a href="#l7402">7402</a><td>          at = 0;<tr><td><a id="l7403"></a><a href="#l7403">7403</a><td>        } else at -= sz;<tr><td><a id="l7404"></a><a href="#l7404">7404</a><td>      }<tr><td><a id="l7405"></a><a href="#l7405">7405</a><td>    }<tr><td><a id="l7406"></a><a href="#l7406">7406</a><td>  };<tr><td><a id="l7407"></a><a href="#l7407">7407</a><td><tr><td><a id="l7408"></a><a href="#l7408">7408</a><td>  var nextDocId = 0;<tr><td><a id="l7409"></a><a href="#l7409">7409</a><td>  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {<tr><td><a id="l7410"></a><a href="#l7410">7410</a><td>    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);<tr><td><a id="l7411"></a><a href="#l7411">7411</a><td>    if (firstLine == null) firstLine = 0;<tr><td><a id="l7412"></a><a href="#l7412">7412</a><td><tr><td><a id="l7413"></a><a href="#l7413">7413</a><td>    BranchChunk.call(this, [new LeafChunk([new Line(&quot;&quot;, null)])]);<tr><td><a id="l7414"></a><a href="#l7414">7414</a><td>    this.first = firstLine;<tr><td><a id="l7415"></a><a href="#l7415">7415</a><td>    this.scrollTop = this.scrollLeft = 0;<tr><td><a id="l7416"></a><a href="#l7416">7416</a><td>    this.cantEdit = false;<tr><td><a id="l7417"></a><a href="#l7417">7417</a><td>    this.cleanGeneration = 1;<tr><td><a id="l7418"></a><a href="#l7418">7418</a><td>    this.frontier = firstLine;<tr><td><a id="l7419"></a><a href="#l7419">7419</a><td>    var start = Pos(firstLine, 0);<tr><td><a id="l7420"></a><a href="#l7420">7420</a><td>    this.sel = simpleSelection(start);<tr><td><a id="l7421"></a><a href="#l7421">7421</a><td>    this.history = new History(null);<tr><td><a id="l7422"></a><a href="#l7422">7422</a><td>    this.id = ++nextDocId;<tr><td><a id="l7423"></a><a href="#l7423">7423</a><td>    this.modeOption = mode;<tr><td><a id="l7424"></a><a href="#l7424">7424</a><td>    this.lineSep = lineSep;<tr><td><a id="l7425"></a><a href="#l7425">7425</a><td>    this.extend = false;<tr><td><a id="l7426"></a><a href="#l7426">7426</a><td><tr><td><a id="l7427"></a><a href="#l7427">7427</a><td>    if (typeof text == &quot;string&quot;) text = this.splitLines(text);<tr><td><a id="l7428"></a><a href="#l7428">7428</a><td>    updateDoc(this, {from: start, to: start, text: text});<tr><td><a id="l7429"></a><a href="#l7429">7429</a><td>    setSelection(this, simpleSelection(start), sel_dontScroll);<tr><td><a id="l7430"></a><a href="#l7430">7430</a><td>  };<tr><td><a id="l7431"></a><a href="#l7431">7431</a><td><tr><td><a id="l7432"></a><a href="#l7432">7432</a><td>  Doc.prototype = createObj(BranchChunk.prototype, {<tr><td><a id="l7433"></a><a href="#l7433">7433</a><td>    constructor: Doc,<tr><td><a id="l7434"></a><a href="#l7434">7434</a><td>    // Iterate over the document. Supports two forms -- with only one<tr><td><a id="l7435"></a><a href="#l7435">7435</a><td>    // argument, it calls that for each line in the document. With<tr><td><a id="l7436"></a><a href="#l7436">7436</a><td>    // three, it iterates over the range given by the first two (with<tr><td><a id="l7437"></a><a href="#l7437">7437</a><td>    // the second being non-inclusive).<tr><td><a id="l7438"></a><a href="#l7438">7438</a><td>    iter: function(from, to, op) {<tr><td><a id="l7439"></a><a href="#l7439">7439</a><td>      if (op) this.iterN(from - this.first, to - from, op);<tr><td><a id="l7440"></a><a href="#l7440">7440</a><td>      else this.iterN(this.first, this.first + this.size, from);<tr><td><a id="l7441"></a><a href="#l7441">7441</a><td>    },<tr><td><a id="l7442"></a><a href="#l7442">7442</a><td><tr><td><a id="l7443"></a><a href="#l7443">7443</a><td>    // Non-public interface for adding and removing lines.<tr><td><a id="l7444"></a><a href="#l7444">7444</a><td>    insert: function(at, lines) {<tr><td><a id="l7445"></a><a href="#l7445">7445</a><td>      var height = 0;<tr><td><a id="l7446"></a><a href="#l7446">7446</a><td>      for (var i = 0; i &lt; lines.length; ++i) height += lines[i].height;<tr><td><a id="l7447"></a><a href="#l7447">7447</a><td>      this.insertInner(at - this.first, lines, height);<tr><td><a id="l7448"></a><a href="#l7448">7448</a><td>    },<tr><td><a id="l7449"></a><a href="#l7449">7449</a><td>    remove: function(at, n) { this.removeInner(at - this.first, n); },<tr><td><a id="l7450"></a><a href="#l7450">7450</a><td><tr><td><a id="l7451"></a><a href="#l7451">7451</a><td>    // From here, the methods are part of the public interface. Most<tr><td><a id="l7452"></a><a href="#l7452">7452</a><td>    // are also available from CodeMirror (editor) instances.<tr><td><a id="l7453"></a><a href="#l7453">7453</a><td><tr><td><a id="l7454"></a><a href="#l7454">7454</a><td>    getValue: function(lineSep) {<tr><td><a id="l7455"></a><a href="#l7455">7455</a><td>      var lines = getLines(this, this.first, this.first + this.size);<tr><td><a id="l7456"></a><a href="#l7456">7456</a><td>      if (lineSep === false) return lines;<tr><td><a id="l7457"></a><a href="#l7457">7457</a><td>      return lines.join(lineSep || this.lineSeparator());<tr><td><a id="l7458"></a><a href="#l7458">7458</a><td>    },<tr><td><a id="l7459"></a><a href="#l7459">7459</a><td>    setValue: docMethodOp(function(code) {<tr><td><a id="l7460"></a><a href="#l7460">7460</a><td>      var top = Pos(this.first, 0), last = this.first + this.size - 1;<tr><td><a id="l7461"></a><a href="#l7461">7461</a><td>      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),<tr><td><a id="l7462"></a><a href="#l7462">7462</a><td>                        text: this.splitLines(code), origin: &quot;setValue&quot;, full: true}, true);<tr><td><a id="l7463"></a><a href="#l7463">7463</a><td>      setSelection(this, simpleSelection(top));<tr><td><a id="l7464"></a><a href="#l7464">7464</a><td>    }),<tr><td><a id="l7465"></a><a href="#l7465">7465</a><td>    replaceRange: function(code, from, to, origin) {<tr><td><a id="l7466"></a><a href="#l7466">7466</a><td>      from = clipPos(this, from);<tr><td><a id="l7467"></a><a href="#l7467">7467</a><td>      to = to ? clipPos(this, to) : from;<tr><td><a id="l7468"></a><a href="#l7468">7468</a><td>      replaceRange(this, code, from, to, origin);<tr><td><a id="l7469"></a><a href="#l7469">7469</a><td>    },<tr><td><a id="l7470"></a><a href="#l7470">7470</a><td>    getRange: function(from, to, lineSep) {<tr><td><a id="l7471"></a><a href="#l7471">7471</a><td>      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));<tr><td><a id="l7472"></a><a href="#l7472">7472</a><td>      if (lineSep === false) return lines;<tr><td><a id="l7473"></a><a href="#l7473">7473</a><td>      return lines.join(lineSep || this.lineSeparator());<tr><td><a id="l7474"></a><a href="#l7474">7474</a><td>    },<tr><td><a id="l7475"></a><a href="#l7475">7475</a><td><tr><td><a id="l7476"></a><a href="#l7476">7476</a><td>    getLine: function(line) {var l = this.getLineHandle(line); return l &amp;&amp; l.text;},<tr><td><a id="l7477"></a><a href="#l7477">7477</a><td><tr><td><a id="l7478"></a><a href="#l7478">7478</a><td>    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},<tr><td><a id="l7479"></a><a href="#l7479">7479</a><td>    getLineNumber: function(line) {return lineNo(line);},<tr><td><a id="l7480"></a><a href="#l7480">7480</a><td><tr><td><a id="l7481"></a><a href="#l7481">7481</a><td>    getLineHandleVisualStart: function(line) {<tr><td><a id="l7482"></a><a href="#l7482">7482</a><td>      if (typeof line == &quot;number&quot;) line = getLine(this, line);<tr><td><a id="l7483"></a><a href="#l7483">7483</a><td>      return visualLine(line);<tr><td><a id="l7484"></a><a href="#l7484">7484</a><td>    },<tr><td><a id="l7485"></a><a href="#l7485">7485</a><td><tr><td><a id="l7486"></a><a href="#l7486">7486</a><td>    lineCount: function() {return this.size;},<tr><td><a id="l7487"></a><a href="#l7487">7487</a><td>    firstLine: function() {return this.first;},<tr><td><a id="l7488"></a><a href="#l7488">7488</a><td>    lastLine: function() {return this.first + this.size - 1;},<tr><td><a id="l7489"></a><a href="#l7489">7489</a><td><tr><td><a id="l7490"></a><a href="#l7490">7490</a><td>    clipPos: function(pos) {return clipPos(this, pos);},<tr><td><a id="l7491"></a><a href="#l7491">7491</a><td><tr><td><a id="l7492"></a><a href="#l7492">7492</a><td>    getCursor: function(start) {<tr><td><a id="l7493"></a><a href="#l7493">7493</a><td>      var range = this.sel.primary(), pos;<tr><td><a id="l7494"></a><a href="#l7494">7494</a><td>      if (start == null || start == &quot;head&quot;) pos = range.head;<tr><td><a id="l7495"></a><a href="#l7495">7495</a><td>      else if (start == &quot;anchor&quot;) pos = range.anchor;<tr><td><a id="l7496"></a><a href="#l7496">7496</a><td>      else if (start == &quot;end&quot; || start == &quot;to&quot; || start === false) pos = range.to();<tr><td><a id="l7497"></a><a href="#l7497">7497</a><td>      else pos = range.from();<tr><td><a id="l7498"></a><a href="#l7498">7498</a><td>      return pos;<tr><td><a id="l7499"></a><a href="#l7499">7499</a><td>    },<tr><td><a id="l7500"></a><a href="#l7500">7500</a><td>    listSelections: function() { return this.sel.ranges; },<tr><td><a id="l7501"></a><a href="#l7501">7501</a><td>    somethingSelected: function() {return this.sel.somethingSelected();},<tr><td><a id="l7502"></a><a href="#l7502">7502</a><td><tr><td><a id="l7503"></a><a href="#l7503">7503</a><td>    setCursor: docMethodOp(function(line, ch, options) {<tr><td><a id="l7504"></a><a href="#l7504">7504</a><td>      setSimpleSelection(this, clipPos(this, typeof line == &quot;number&quot; ? Pos(line, ch || 0) : line), null, options);<tr><td><a id="l7505"></a><a href="#l7505">7505</a><td>    }),<tr><td><a id="l7506"></a><a href="#l7506">7506</a><td>    setSelection: docMethodOp(function(anchor, head, options) {<tr><td><a id="l7507"></a><a href="#l7507">7507</a><td>      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);<tr><td><a id="l7508"></a><a href="#l7508">7508</a><td>    }),<tr><td><a id="l7509"></a><a href="#l7509">7509</a><td>    extendSelection: docMethodOp(function(head, other, options) {<tr><td><a id="l7510"></a><a href="#l7510">7510</a><td>      extendSelection(this, clipPos(this, head), other &amp;&amp; clipPos(this, other), options);<tr><td><a id="l7511"></a><a href="#l7511">7511</a><td>    }),<tr><td><a id="l7512"></a><a href="#l7512">7512</a><td>    extendSelections: docMethodOp(function(heads, options) {<tr><td><a id="l7513"></a><a href="#l7513">7513</a><td>      extendSelections(this, clipPosArray(this, heads), options);<tr><td><a id="l7514"></a><a href="#l7514">7514</a><td>    }),<tr><td><a id="l7515"></a><a href="#l7515">7515</a><td>    extendSelectionsBy: docMethodOp(function(f, options) {<tr><td><a id="l7516"></a><a href="#l7516">7516</a><td>      var heads = map(this.sel.ranges, f);<tr><td><a id="l7517"></a><a href="#l7517">7517</a><td>      extendSelections(this, clipPosArray(this, heads), options);<tr><td><a id="l7518"></a><a href="#l7518">7518</a><td>    }),<tr><td><a id="l7519"></a><a href="#l7519">7519</a><td>    setSelections: docMethodOp(function(ranges, primary, options) {<tr><td><a id="l7520"></a><a href="#l7520">7520</a><td>      if (!ranges.length) return;<tr><td><a id="l7521"></a><a href="#l7521">7521</a><td>      for (var i = 0, out = []; i &lt; ranges.length; i++)<tr><td><a id="l7522"></a><a href="#l7522">7522</a><td>        out[i] = new Range(clipPos(this, ranges[i].anchor),<tr><td><a id="l7523"></a><a href="#l7523">7523</a><td>                           clipPos(this, ranges[i].head));<tr><td><a id="l7524"></a><a href="#l7524">7524</a><td>      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);<tr><td><a id="l7525"></a><a href="#l7525">7525</a><td>      setSelection(this, normalizeSelection(out, primary), options);<tr><td><a id="l7526"></a><a href="#l7526">7526</a><td>    }),<tr><td><a id="l7527"></a><a href="#l7527">7527</a><td>    addSelection: docMethodOp(function(anchor, head, options) {<tr><td><a id="l7528"></a><a href="#l7528">7528</a><td>      var ranges = this.sel.ranges.slice(0);<tr><td><a id="l7529"></a><a href="#l7529">7529</a><td>      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));<tr><td><a id="l7530"></a><a href="#l7530">7530</a><td>      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);<tr><td><a id="l7531"></a><a href="#l7531">7531</a><td>    }),<tr><td><a id="l7532"></a><a href="#l7532">7532</a><td><tr><td><a id="l7533"></a><a href="#l7533">7533</a><td>    getSelection: function(lineSep) {<tr><td><a id="l7534"></a><a href="#l7534">7534</a><td>      var ranges = this.sel.ranges, lines;<tr><td><a id="l7535"></a><a href="#l7535">7535</a><td>      for (var i = 0; i &lt; ranges.length; i++) {<tr><td><a id="l7536"></a><a href="#l7536">7536</a><td>        var sel = getBetween(this, ranges[i].from(), ranges[i].to());<tr><td><a id="l7537"></a><a href="#l7537">7537</a><td>        lines = lines ? lines.concat(sel) : sel;<tr><td><a id="l7538"></a><a href="#l7538">7538</a><td>      }<tr><td><a id="l7539"></a><a href="#l7539">7539</a><td>      if (lineSep === false) return lines;<tr><td><a id="l7540"></a><a href="#l7540">7540</a><td>      else return lines.join(lineSep || this.lineSeparator());<tr><td><a id="l7541"></a><a href="#l7541">7541</a><td>    },<tr><td><a id="l7542"></a><a href="#l7542">7542</a><td>    getSelections: function(lineSep) {<tr><td><a id="l7543"></a><a href="#l7543">7543</a><td>      var parts = [], ranges = this.sel.ranges;<tr><td><a id="l7544"></a><a href="#l7544">7544</a><td>      for (var i = 0; i &lt; ranges.length; i++) {<tr><td><a id="l7545"></a><a href="#l7545">7545</a><td>        var sel = getBetween(this, ranges[i].from(), ranges[i].to());<tr><td><a id="l7546"></a><a href="#l7546">7546</a><td>        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());<tr><td><a id="l7547"></a><a href="#l7547">7547</a><td>        parts[i] = sel;<tr><td><a id="l7548"></a><a href="#l7548">7548</a><td>      }<tr><td><a id="l7549"></a><a href="#l7549">7549</a><td>      return parts;<tr><td><a id="l7550"></a><a href="#l7550">7550</a><td>    },<tr><td><a id="l7551"></a><a href="#l7551">7551</a><td>    replaceSelection: function(code, collapse, origin) {<tr><td><a id="l7552"></a><a href="#l7552">7552</a><td>      var dup = [];<tr><td><a id="l7553"></a><a href="#l7553">7553</a><td>      for (var i = 0; i &lt; this.sel.ranges.length; i++)<tr><td><a id="l7554"></a><a href="#l7554">7554</a><td>        dup[i] = code;<tr><td><a id="l7555"></a><a href="#l7555">7555</a><td>      this.replaceSelections(dup, collapse, origin || &quot;+input&quot;);<tr><td><a id="l7556"></a><a href="#l7556">7556</a><td>    },<tr><td><a id="l7557"></a><a href="#l7557">7557</a><td>    replaceSelections: docMethodOp(function(code, collapse, origin) {<tr><td><a id="l7558"></a><a href="#l7558">7558</a><td>      var changes = [], sel = this.sel;<tr><td><a id="l7559"></a><a href="#l7559">7559</a><td>      for (var i = 0; i &lt; sel.ranges.length; i++) {<tr><td><a id="l7560"></a><a href="#l7560">7560</a><td>        var range = sel.ranges[i];<tr><td><a id="l7561"></a><a href="#l7561">7561</a><td>        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};<tr><td><a id="l7562"></a><a href="#l7562">7562</a><td>      }<tr><td><a id="l7563"></a><a href="#l7563">7563</a><td>      var newSel = collapse &amp;&amp; collapse != &quot;end&quot; &amp;&amp; computeReplacedSel(this, changes, collapse);<tr><td><a id="l7564"></a><a href="#l7564">7564</a><td>      for (var i = changes.length - 1; i &gt;= 0; i--)<tr><td><a id="l7565"></a><a href="#l7565">7565</a><td>        makeChange(this, changes[i]);<tr><td><a id="l7566"></a><a href="#l7566">7566</a><td>      if (newSel) setSelectionReplaceHistory(this, newSel);<tr><td><a id="l7567"></a><a href="#l7567">7567</a><td>      else if (this.cm) ensureCursorVisible(this.cm);<tr><td><a id="l7568"></a><a href="#l7568">7568</a><td>    }),<tr><td><a id="l7569"></a><a href="#l7569">7569</a><td>    undo: docMethodOp(function() {makeChangeFromHistory(this, &quot;undo&quot;);}),<tr><td><a id="l7570"></a><a href="#l7570">7570</a><td>    redo: docMethodOp(function() {makeChangeFromHistory(this, &quot;redo&quot;);}),<tr><td><a id="l7571"></a><a href="#l7571">7571</a><td>    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, &quot;undo&quot;, true);}),<tr><td><a id="l7572"></a><a href="#l7572">7572</a><td>    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, &quot;redo&quot;, true);}),<tr><td><a id="l7573"></a><a href="#l7573">7573</a><td><tr><td><a id="l7574"></a><a href="#l7574">7574</a><td>    setExtending: function(val) {this.extend = val;},<tr><td><a id="l7575"></a><a href="#l7575">7575</a><td>    getExtending: function() {return this.extend;},<tr><td><a id="l7576"></a><a href="#l7576">7576</a><td><tr><td><a id="l7577"></a><a href="#l7577">7577</a><td>    historySize: function() {<tr><td><a id="l7578"></a><a href="#l7578">7578</a><td>      var hist = this.history, done = 0, undone = 0;<tr><td><a id="l7579"></a><a href="#l7579">7579</a><td>      for (var i = 0; i &lt; hist.done.length; i++) if (!hist.done[i].ranges) ++done;<tr><td><a id="l7580"></a><a href="#l7580">7580</a><td>      for (var i = 0; i &lt; hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;<tr><td><a id="l7581"></a><a href="#l7581">7581</a><td>      return {undo: done, redo: undone};<tr><td><a id="l7582"></a><a href="#l7582">7582</a><td>    },<tr><td><a id="l7583"></a><a href="#l7583">7583</a><td>    clearHistory: function() {this.history = new History(this.history.maxGeneration);},<tr><td><a id="l7584"></a><a href="#l7584">7584</a><td><tr><td><a id="l7585"></a><a href="#l7585">7585</a><td>    markClean: function() {<tr><td><a id="l7586"></a><a href="#l7586">7586</a><td>      this.cleanGeneration = this.changeGeneration(true);<tr><td><a id="l7587"></a><a href="#l7587">7587</a><td>    },<tr><td><a id="l7588"></a><a href="#l7588">7588</a><td>    changeGeneration: function(forceSplit) {<tr><td><a id="l7589"></a><a href="#l7589">7589</a><td>      if (forceSplit)<tr><td><a id="l7590"></a><a href="#l7590">7590</a><td>        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;<tr><td><a id="l7591"></a><a href="#l7591">7591</a><td>      return this.history.generation;<tr><td><a id="l7592"></a><a href="#l7592">7592</a><td>    },<tr><td><a id="l7593"></a><a href="#l7593">7593</a><td>    isClean: function (gen) {<tr><td><a id="l7594"></a><a href="#l7594">7594</a><td>      return this.history.generation == (gen || this.cleanGeneration);<tr><td><a id="l7595"></a><a href="#l7595">7595</a><td>    },<tr><td><a id="l7596"></a><a href="#l7596">7596</a><td><tr><td><a id="l7597"></a><a href="#l7597">7597</a><td>    getHistory: function() {<tr><td><a id="l7598"></a><a href="#l7598">7598</a><td>      return {done: copyHistoryArray(this.history.done),<tr><td><a id="l7599"></a><a href="#l7599">7599</a><td>              undone: copyHistoryArray(this.history.undone)};<tr><td><a id="l7600"></a><a href="#l7600">7600</a><td>    },<tr><td><a id="l7601"></a><a href="#l7601">7601</a><td>    setHistory: function(histData) {<tr><td><a id="l7602"></a><a href="#l7602">7602</a><td>      var hist = this.history = new History(this.history.maxGeneration);<tr><td><a id="l7603"></a><a href="#l7603">7603</a><td>      hist.done = copyHistoryArray(histData.done.slice(0), null, true);<tr><td><a id="l7604"></a><a href="#l7604">7604</a><td>      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);<tr><td><a id="l7605"></a><a href="#l7605">7605</a><td>    },<tr><td><a id="l7606"></a><a href="#l7606">7606</a><td><tr><td><a id="l7607"></a><a href="#l7607">7607</a><td>    addLineClass: docMethodOp(function(handle, where, cls) {<tr><td><a id="l7608"></a><a href="#l7608">7608</a><td>      return changeLine(this, handle, where == &quot;gutter&quot; ? &quot;gutter&quot; : &quot;class&quot;, function(line) {<tr><td><a id="l7609"></a><a href="#l7609">7609</a><td>        var prop = where == &quot;text&quot; ? &quot;textClass&quot;<tr><td><a id="l7610"></a><a href="#l7610">7610</a><td>                 : where == &quot;background&quot; ? &quot;bgClass&quot;<tr><td><a id="l7611"></a><a href="#l7611">7611</a><td>                 : where == &quot;gutter&quot; ? &quot;gutterClass&quot; : &quot;wrapClass&quot;;<tr><td><a id="l7612"></a><a href="#l7612">7612</a><td>        if (!line[prop]) line[prop] = cls;<tr><td><a id="l7613"></a><a href="#l7613">7613</a><td>        else if (classTest(cls).test(line[prop])) return false;<tr><td><a id="l7614"></a><a href="#l7614">7614</a><td>        else line[prop] += &quot; &quot; + cls;<tr><td><a id="l7615"></a><a href="#l7615">7615</a><td>        return true;<tr><td><a id="l7616"></a><a href="#l7616">7616</a><td>      });<tr><td><a id="l7617"></a><a href="#l7617">7617</a><td>    }),<tr><td><a id="l7618"></a><a href="#l7618">7618</a><td>    removeLineClass: docMethodOp(function(handle, where, cls) {<tr><td><a id="l7619"></a><a href="#l7619">7619</a><td>      return changeLine(this, handle, where == &quot;gutter&quot; ? &quot;gutter&quot; : &quot;class&quot;, function(line) {<tr><td><a id="l7620"></a><a href="#l7620">7620</a><td>        var prop = where == &quot;text&quot; ? &quot;textClass&quot;<tr><td><a id="l7621"></a><a href="#l7621">7621</a><td>                 : where == &quot;background&quot; ? &quot;bgClass&quot;<tr><td><a id="l7622"></a><a href="#l7622">7622</a><td>                 : where == &quot;gutter&quot; ? &quot;gutterClass&quot; : &quot;wrapClass&quot;;<tr><td><a id="l7623"></a><a href="#l7623">7623</a><td>        var cur = line[prop];<tr><td><a id="l7624"></a><a href="#l7624">7624</a><td>        if (!cur) return false;<tr><td><a id="l7625"></a><a href="#l7625">7625</a><td>        else if (cls == null) line[prop] = null;<tr><td><a id="l7626"></a><a href="#l7626">7626</a><td>        else {<tr><td><a id="l7627"></a><a href="#l7627">7627</a><td>          var found = cur.match(classTest(cls));<tr><td><a id="l7628"></a><a href="#l7628">7628</a><td>          if (!found) return false;<tr><td><a id="l7629"></a><a href="#l7629">7629</a><td>          var end = found.index + found[0].length;<tr><td><a id="l7630"></a><a href="#l7630">7630</a><td>          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? &quot;&quot; : &quot; &quot;) + cur.slice(end) || null;<tr><td><a id="l7631"></a><a href="#l7631">7631</a><td>        }<tr><td><a id="l7632"></a><a href="#l7632">7632</a><td>        return true;<tr><td><a id="l7633"></a><a href="#l7633">7633</a><td>      });<tr><td><a id="l7634"></a><a href="#l7634">7634</a><td>    }),<tr><td><a id="l7635"></a><a href="#l7635">7635</a><td><tr><td><a id="l7636"></a><a href="#l7636">7636</a><td>    addLineWidget: docMethodOp(function(handle, node, options) {<tr><td><a id="l7637"></a><a href="#l7637">7637</a><td>      return addLineWidget(this, handle, node, options);<tr><td><a id="l7638"></a><a href="#l7638">7638</a><td>    }),<tr><td><a id="l7639"></a><a href="#l7639">7639</a><td>    removeLineWidget: function(widget) { widget.clear(); },<tr><td><a id="l7640"></a><a href="#l7640">7640</a><td><tr><td><a id="l7641"></a><a href="#l7641">7641</a><td>    markText: function(from, to, options) {<tr><td><a id="l7642"></a><a href="#l7642">7642</a><td>      return markText(this, clipPos(this, from), clipPos(this, to), options, options &amp;&amp; options.type || &quot;range&quot;);<tr><td><a id="l7643"></a><a href="#l7643">7643</a><td>    },<tr><td><a id="l7644"></a><a href="#l7644">7644</a><td>    setBookmark: function(pos, options) {<tr><td><a id="l7645"></a><a href="#l7645">7645</a><td>      var realOpts = {replacedWith: options &amp;&amp; (options.nodeType == null ? options.widget : options),<tr><td><a id="l7646"></a><a href="#l7646">7646</a><td>                      insertLeft: options &amp;&amp; options.insertLeft,<tr><td><a id="l7647"></a><a href="#l7647">7647</a><td>                      clearWhenEmpty: false, shared: options &amp;&amp; options.shared,<tr><td><a id="l7648"></a><a href="#l7648">7648</a><td>                      handleMouseEvents: options &amp;&amp; options.handleMouseEvents};<tr><td><a id="l7649"></a><a href="#l7649">7649</a><td>      pos = clipPos(this, pos);<tr><td><a id="l7650"></a><a href="#l7650">7650</a><td>      return markText(this, pos, pos, realOpts, &quot;bookmark&quot;);<tr><td><a id="l7651"></a><a href="#l7651">7651</a><td>    },<tr><td><a id="l7652"></a><a href="#l7652">7652</a><td>    findMarksAt: function(pos) {<tr><td><a id="l7653"></a><a href="#l7653">7653</a><td>      pos = clipPos(this, pos);<tr><td><a id="l7654"></a><a href="#l7654">7654</a><td>      var markers = [], spans = getLine(this, pos.line).markedSpans;<tr><td><a id="l7655"></a><a href="#l7655">7655</a><td>      if (spans) for (var i = 0; i &lt; spans.length; ++i) {<tr><td><a id="l7656"></a><a href="#l7656">7656</a><td>        var span = spans[i];<tr><td><a id="l7657"></a><a href="#l7657">7657</a><td>        if ((span.from == null || span.from &lt;= pos.ch) &amp;&amp;<tr><td><a id="l7658"></a><a href="#l7658">7658</a><td>            (span.to == null || span.to &gt;= pos.ch))<tr><td><a id="l7659"></a><a href="#l7659">7659</a><td>          markers.push(span.marker.parent || span.marker);<tr><td><a id="l7660"></a><a href="#l7660">7660</a><td>      }<tr><td><a id="l7661"></a><a href="#l7661">7661</a><td>      return markers;<tr><td><a id="l7662"></a><a href="#l7662">7662</a><td>    },<tr><td><a id="l7663"></a><a href="#l7663">7663</a><td>    findMarks: function(from, to, filter) {<tr><td><a id="l7664"></a><a href="#l7664">7664</a><td>      from = clipPos(this, from); to = clipPos(this, to);<tr><td><a id="l7665"></a><a href="#l7665">7665</a><td>      var found = [], lineNo = from.line;<tr><td><a id="l7666"></a><a href="#l7666">7666</a><td>      this.iter(from.line, to.line + 1, function(line) {<tr><td><a id="l7667"></a><a href="#l7667">7667</a><td>        var spans = line.markedSpans;<tr><td><a id="l7668"></a><a href="#l7668">7668</a><td>        if (spans) for (var i = 0; i &lt; spans.length; i++) {<tr><td><a id="l7669"></a><a href="#l7669">7669</a><td>          var span = spans[i];<tr><td><a id="l7670"></a><a href="#l7670">7670</a><td>          if (!(span.to != null &amp;&amp; lineNo == from.line &amp;&amp; from.ch &gt;= span.to ||<tr><td><a id="l7671"></a><a href="#l7671">7671</a><td>                span.from == null &amp;&amp; lineNo != from.line ||<tr><td><a id="l7672"></a><a href="#l7672">7672</a><td>                span.from != null &amp;&amp; lineNo == to.line &amp;&amp; span.from &gt;= to.ch) &amp;&amp;<tr><td><a id="l7673"></a><a href="#l7673">7673</a><td>              (!filter || filter(span.marker)))<tr><td><a id="l7674"></a><a href="#l7674">7674</a><td>            found.push(span.marker.parent || span.marker);<tr><td><a id="l7675"></a><a href="#l7675">7675</a><td>        }<tr><td><a id="l7676"></a><a href="#l7676">7676</a><td>        ++lineNo;<tr><td><a id="l7677"></a><a href="#l7677">7677</a><td>      });<tr><td><a id="l7678"></a><a href="#l7678">7678</a><td>      return found;<tr><td><a id="l7679"></a><a href="#l7679">7679</a><td>    },<tr><td><a id="l7680"></a><a href="#l7680">7680</a><td>    getAllMarks: function() {<tr><td><a id="l7681"></a><a href="#l7681">7681</a><td>      var markers = [];<tr><td><a id="l7682"></a><a href="#l7682">7682</a><td>      this.iter(function(line) {<tr><td><a id="l7683"></a><a href="#l7683">7683</a><td>        var sps = line.markedSpans;<tr><td><a id="l7684"></a><a href="#l7684">7684</a><td>        if (sps) for (var i = 0; i &lt; sps.length; ++i)<tr><td><a id="l7685"></a><a href="#l7685">7685</a><td>          if (sps[i].from != null) markers.push(sps[i].marker);<tr><td><a id="l7686"></a><a href="#l7686">7686</a><td>      });<tr><td><a id="l7687"></a><a href="#l7687">7687</a><td>      return markers;<tr><td><a id="l7688"></a><a href="#l7688">7688</a><td>    },<tr><td><a id="l7689"></a><a href="#l7689">7689</a><td><tr><td><a id="l7690"></a><a href="#l7690">7690</a><td>    posFromIndex: function(off) {<tr><td><a id="l7691"></a><a href="#l7691">7691</a><td>      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;<tr><td><a id="l7692"></a><a href="#l7692">7692</a><td>      this.iter(function(line) {<tr><td><a id="l7693"></a><a href="#l7693">7693</a><td>        var sz = line.text.length + sepSize;<tr><td><a id="l7694"></a><a href="#l7694">7694</a><td>        if (sz &gt; off) { ch = off; return true; }<tr><td><a id="l7695"></a><a href="#l7695">7695</a><td>        off -= sz;<tr><td><a id="l7696"></a><a href="#l7696">7696</a><td>        ++lineNo;<tr><td><a id="l7697"></a><a href="#l7697">7697</a><td>      });<tr><td><a id="l7698"></a><a href="#l7698">7698</a><td>      return clipPos(this, Pos(lineNo, ch));<tr><td><a id="l7699"></a><a href="#l7699">7699</a><td>    },<tr><td><a id="l7700"></a><a href="#l7700">7700</a><td>    indexFromPos: function (coords) {<tr><td><a id="l7701"></a><a href="#l7701">7701</a><td>      coords = clipPos(this, coords);<tr><td><a id="l7702"></a><a href="#l7702">7702</a><td>      var index = coords.ch;<tr><td><a id="l7703"></a><a href="#l7703">7703</a><td>      if (coords.line &lt; this.first || coords.ch &lt; 0) return 0;<tr><td><a id="l7704"></a><a href="#l7704">7704</a><td>      var sepSize = this.lineSeparator().length;<tr><td><a id="l7705"></a><a href="#l7705">7705</a><td>      this.iter(this.first, coords.line, function (line) {<tr><td><a id="l7706"></a><a href="#l7706">7706</a><td>        index += line.text.length + sepSize;<tr><td><a id="l7707"></a><a href="#l7707">7707</a><td>      });<tr><td><a id="l7708"></a><a href="#l7708">7708</a><td>      return index;<tr><td><a id="l7709"></a><a href="#l7709">7709</a><td>    },<tr><td><a id="l7710"></a><a href="#l7710">7710</a><td><tr><td><a id="l7711"></a><a href="#l7711">7711</a><td>    copy: function(copyHistory) {<tr><td><a id="l7712"></a><a href="#l7712">7712</a><td>      var doc = new Doc(getLines(this, this.first, this.first + this.size),<tr><td><a id="l7713"></a><a href="#l7713">7713</a><td>                        this.modeOption, this.first, this.lineSep);<tr><td><a id="l7714"></a><a href="#l7714">7714</a><td>      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;<tr><td><a id="l7715"></a><a href="#l7715">7715</a><td>      doc.sel = this.sel;<tr><td><a id="l7716"></a><a href="#l7716">7716</a><td>      doc.extend = false;<tr><td><a id="l7717"></a><a href="#l7717">7717</a><td>      if (copyHistory) {<tr><td><a id="l7718"></a><a href="#l7718">7718</a><td>        doc.history.undoDepth = this.history.undoDepth;<tr><td><a id="l7719"></a><a href="#l7719">7719</a><td>        doc.setHistory(this.getHistory());<tr><td><a id="l7720"></a><a href="#l7720">7720</a><td>      }<tr><td><a id="l7721"></a><a href="#l7721">7721</a><td>      return doc;<tr><td><a id="l7722"></a><a href="#l7722">7722</a><td>    },<tr><td><a id="l7723"></a><a href="#l7723">7723</a><td><tr><td><a id="l7724"></a><a href="#l7724">7724</a><td>    linkedDoc: function(options) {<tr><td><a id="l7725"></a><a href="#l7725">7725</a><td>      if (!options) options = {};<tr><td><a id="l7726"></a><a href="#l7726">7726</a><td>      var from = this.first, to = this.first + this.size;<tr><td><a id="l7727"></a><a href="#l7727">7727</a><td>      if (options.from != null &amp;&amp; options.from &gt; from) from = options.from;<tr><td><a id="l7728"></a><a href="#l7728">7728</a><td>      if (options.to != null &amp;&amp; options.to &lt; to) to = options.to;<tr><td><a id="l7729"></a><a href="#l7729">7729</a><td>      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);<tr><td><a id="l7730"></a><a href="#l7730">7730</a><td>      if (options.sharedHist) copy.history = this.history;<tr><td><a id="l7731"></a><a href="#l7731">7731</a><td>      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});<tr><td><a id="l7732"></a><a href="#l7732">7732</a><td>      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];<tr><td><a id="l7733"></a><a href="#l7733">7733</a><td>      copySharedMarkers(copy, findSharedMarkers(this));<tr><td><a id="l7734"></a><a href="#l7734">7734</a><td>      return copy;<tr><td><a id="l7735"></a><a href="#l7735">7735</a><td>    },<tr><td><a id="l7736"></a><a href="#l7736">7736</a><td>    unlinkDoc: function(other) {<tr><td><a id="l7737"></a><a href="#l7737">7737</a><td>      if (other instanceof CodeMirror) other = other.doc;<tr><td><a id="l7738"></a><a href="#l7738">7738</a><td>      if (this.linked) for (var i = 0; i &lt; this.linked.length; ++i) {<tr><td><a id="l7739"></a><a href="#l7739">7739</a><td>        var link = this.linked[i];<tr><td><a id="l7740"></a><a href="#l7740">7740</a><td>        if (link.doc != other) continue;<tr><td><a id="l7741"></a><a href="#l7741">7741</a><td>        this.linked.splice(i, 1);<tr><td><a id="l7742"></a><a href="#l7742">7742</a><td>        other.unlinkDoc(this);<tr><td><a id="l7743"></a><a href="#l7743">7743</a><td>        detachSharedMarkers(findSharedMarkers(this));<tr><td><a id="l7744"></a><a href="#l7744">7744</a><td>        break;<tr><td><a id="l7745"></a><a href="#l7745">7745</a><td>      }<tr><td><a id="l7746"></a><a href="#l7746">7746</a><td>      // If the histories were shared, split them again<tr><td><a id="l7747"></a><a href="#l7747">7747</a><td>      if (other.history == this.history) {<tr><td><a id="l7748"></a><a href="#l7748">7748</a><td>        var splitIds = [other.id];<tr><td><a id="l7749"></a><a href="#l7749">7749</a><td>        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);<tr><td><a id="l7750"></a><a href="#l7750">7750</a><td>        other.history = new History(null);<tr><td><a id="l7751"></a><a href="#l7751">7751</a><td>        other.history.done = copyHistoryArray(this.history.done, splitIds);<tr><td><a id="l7752"></a><a href="#l7752">7752</a><td>        other.history.undone = copyHistoryArray(this.history.undone, splitIds);<tr><td><a id="l7753"></a><a href="#l7753">7753</a><td>      }<tr><td><a id="l7754"></a><a href="#l7754">7754</a><td>    },<tr><td><a id="l7755"></a><a href="#l7755">7755</a><td>    iterLinkedDocs: function(f) {linkedDocs(this, f);},<tr><td><a id="l7756"></a><a href="#l7756">7756</a><td><tr><td><a id="l7757"></a><a href="#l7757">7757</a><td>    getMode: function() {return this.mode;},<tr><td><a id="l7758"></a><a href="#l7758">7758</a><td>    getEditor: function() {return this.cm;},<tr><td><a id="l7759"></a><a href="#l7759">7759</a><td><tr><td><a id="l7760"></a><a href="#l7760">7760</a><td>    splitLines: function(str) {<tr><td><a id="l7761"></a><a href="#l7761">7761</a><td>      if (this.lineSep) return str.split(this.lineSep);<tr><td><a id="l7762"></a><a href="#l7762">7762</a><td>      return splitLinesAuto(str);<tr><td><a id="l7763"></a><a href="#l7763">7763</a><td>    },<tr><td><a id="l7764"></a><a href="#l7764">7764</a><td>    lineSeparator: function() { return this.lineSep || &quot;\n&quot;; }<tr><td><a id="l7765"></a><a href="#l7765">7765</a><td>  });<tr><td><a id="l7766"></a><a href="#l7766">7766</a><td><tr><td><a id="l7767"></a><a href="#l7767">7767</a><td>  // Public alias.<tr><td><a id="l7768"></a><a href="#l7768">7768</a><td>  Doc.prototype.eachLine = Doc.prototype.iter;<tr><td><a id="l7769"></a><a href="#l7769">7769</a><td><tr><td><a id="l7770"></a><a href="#l7770">7770</a><td>  // Set up methods on CodeMirror&#39;s prototype to redirect to the editor&#39;s document.<tr><td><a id="l7771"></a><a href="#l7771">7771</a><td>  var dontDelegate = &quot;iter insert remove copy getEditor constructor&quot;.split(&quot; &quot;);<tr><td><a id="l7772"></a><a href="#l7772">7772</a><td>  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) &amp;&amp; indexOf(dontDelegate, prop) &lt; 0)<tr><td><a id="l7773"></a><a href="#l7773">7773</a><td>    CodeMirror.prototype[prop] = (function(method) {<tr><td><a id="l7774"></a><a href="#l7774">7774</a><td>      return function() {return method.apply(this.doc, arguments);};<tr><td><a id="l7775"></a><a href="#l7775">7775</a><td>    })(Doc.prototype[prop]);<tr><td><a id="l7776"></a><a href="#l7776">7776</a><td><tr><td><a id="l7777"></a><a href="#l7777">7777</a><td>  eventMixin(Doc);<tr><td><a id="l7778"></a><a href="#l7778">7778</a><td><tr><td><a id="l7779"></a><a href="#l7779">7779</a><td>  // Call f for all linked documents.<tr><td><a id="l7780"></a><a href="#l7780">7780</a><td>  function linkedDocs(doc, f, sharedHistOnly) {<tr><td><a id="l7781"></a><a href="#l7781">7781</a><td>    function propagate(doc, skip, sharedHist) {<tr><td><a id="l7782"></a><a href="#l7782">7782</a><td>      if (doc.linked) for (var i = 0; i &lt; doc.linked.length; ++i) {<tr><td><a id="l7783"></a><a href="#l7783">7783</a><td>        var rel = doc.linked[i];<tr><td><a id="l7784"></a><a href="#l7784">7784</a><td>        if (rel.doc == skip) continue;<tr><td><a id="l7785"></a><a href="#l7785">7785</a><td>        var shared = sharedHist &amp;&amp; rel.sharedHist;<tr><td><a id="l7786"></a><a href="#l7786">7786</a><td>        if (sharedHistOnly &amp;&amp; !shared) continue;<tr><td><a id="l7787"></a><a href="#l7787">7787</a><td>        f(rel.doc, shared);<tr><td><a id="l7788"></a><a href="#l7788">7788</a><td>        propagate(rel.doc, doc, shared);<tr><td><a id="l7789"></a><a href="#l7789">7789</a><td>      }<tr><td><a id="l7790"></a><a href="#l7790">7790</a><td>    }<tr><td><a id="l7791"></a><a href="#l7791">7791</a><td>    propagate(doc, null, true);<tr><td><a id="l7792"></a><a href="#l7792">7792</a><td>  }<tr><td><a id="l7793"></a><a href="#l7793">7793</a><td><tr><td><a id="l7794"></a><a href="#l7794">7794</a><td>  // Attach a document to an editor.<tr><td><a id="l7795"></a><a href="#l7795">7795</a><td>  function attachDoc(cm, doc) {<tr><td><a id="l7796"></a><a href="#l7796">7796</a><td>    if (doc.cm) throw new Error(&quot;This document is already in use.&quot;);<tr><td><a id="l7797"></a><a href="#l7797">7797</a><td>    cm.doc = doc;<tr><td><a id="l7798"></a><a href="#l7798">7798</a><td>    doc.cm = cm;<tr><td><a id="l7799"></a><a href="#l7799">7799</a><td>    estimateLineHeights(cm);<tr><td><a id="l7800"></a><a href="#l7800">7800</a><td>    loadMode(cm);<tr><td><a id="l7801"></a><a href="#l7801">7801</a><td>    if (!cm.options.lineWrapping) findMaxLine(cm);<tr><td><a id="l7802"></a><a href="#l7802">7802</a><td>    cm.options.mode = doc.modeOption;<tr><td><a id="l7803"></a><a href="#l7803">7803</a><td>    regChange(cm);<tr><td><a id="l7804"></a><a href="#l7804">7804</a><td>  }<tr><td><a id="l7805"></a><a href="#l7805">7805</a><td><tr><td><a id="l7806"></a><a href="#l7806">7806</a><td>  // LINE UTILITIES<tr><td><a id="l7807"></a><a href="#l7807">7807</a><td><tr><td><a id="l7808"></a><a href="#l7808">7808</a><td>  // Find the line object corresponding to the given line number.<tr><td><a id="l7809"></a><a href="#l7809">7809</a><td>  function getLine(doc, n) {<tr><td><a id="l7810"></a><a href="#l7810">7810</a><td>    n -= doc.first;<tr><td><a id="l7811"></a><a href="#l7811">7811</a><td>    if (n &lt; 0 || n &gt;= doc.size) throw new Error(&quot;There is no line &quot; + (n + doc.first) + &quot; in the document.&quot;);<tr><td><a id="l7812"></a><a href="#l7812">7812</a><td>    for (var chunk = doc; !chunk.lines;) {<tr><td><a id="l7813"></a><a href="#l7813">7813</a><td>      for (var i = 0;; ++i) {<tr><td><a id="l7814"></a><a href="#l7814">7814</a><td>        var child = chunk.children[i], sz = child.chunkSize();<tr><td><a id="l7815"></a><a href="#l7815">7815</a><td>        if (n &lt; sz) { chunk = child; break; }<tr><td><a id="l7816"></a><a href="#l7816">7816</a><td>        n -= sz;<tr><td><a id="l7817"></a><a href="#l7817">7817</a><td>      }<tr><td><a id="l7818"></a><a href="#l7818">7818</a><td>    }<tr><td><a id="l7819"></a><a href="#l7819">7819</a><td>    return chunk.lines[n];<tr><td><a id="l7820"></a><a href="#l7820">7820</a><td>  }<tr><td><a id="l7821"></a><a href="#l7821">7821</a><td><tr><td><a id="l7822"></a><a href="#l7822">7822</a><td>  // Get the part of a document between two positions, as an array of<tr><td><a id="l7823"></a><a href="#l7823">7823</a><td>  // strings.<tr><td><a id="l7824"></a><a href="#l7824">7824</a><td>  function getBetween(doc, start, end) {<tr><td><a id="l7825"></a><a href="#l7825">7825</a><td>    var out = [], n = start.line;<tr><td><a id="l7826"></a><a href="#l7826">7826</a><td>    doc.iter(start.line, end.line + 1, function(line) {<tr><td><a id="l7827"></a><a href="#l7827">7827</a><td>      var text = line.text;<tr><td><a id="l7828"></a><a href="#l7828">7828</a><td>      if (n == end.line) text = text.slice(0, end.ch);<tr><td><a id="l7829"></a><a href="#l7829">7829</a><td>      if (n == start.line) text = text.slice(start.ch);<tr><td><a id="l7830"></a><a href="#l7830">7830</a><td>      out.push(text);<tr><td><a id="l7831"></a><a href="#l7831">7831</a><td>      ++n;<tr><td><a id="l7832"></a><a href="#l7832">7832</a><td>    });<tr><td><a id="l7833"></a><a href="#l7833">7833</a><td>    return out;<tr><td><a id="l7834"></a><a href="#l7834">7834</a><td>  }<tr><td><a id="l7835"></a><a href="#l7835">7835</a><td>  // Get the lines between from and to, as array of strings.<tr><td><a id="l7836"></a><a href="#l7836">7836</a><td>  function getLines(doc, from, to) {<tr><td><a id="l7837"></a><a href="#l7837">7837</a><td>    var out = [];<tr><td><a id="l7838"></a><a href="#l7838">7838</a><td>    doc.iter(from, to, function(line) { out.push(line.text); });<tr><td><a id="l7839"></a><a href="#l7839">7839</a><td>    return out;<tr><td><a id="l7840"></a><a href="#l7840">7840</a><td>  }<tr><td><a id="l7841"></a><a href="#l7841">7841</a><td><tr><td><a id="l7842"></a><a href="#l7842">7842</a><td>  // Update the height of a line, propagating the height change<tr><td><a id="l7843"></a><a href="#l7843">7843</a><td>  // upwards to parent nodes.<tr><td><a id="l7844"></a><a href="#l7844">7844</a><td>  function updateLineHeight(line, height) {<tr><td><a id="l7845"></a><a href="#l7845">7845</a><td>    var diff = height - line.height;<tr><td><a id="l7846"></a><a href="#l7846">7846</a><td>    if (diff) for (var n = line; n; n = n.parent) n.height += diff;<tr><td><a id="l7847"></a><a href="#l7847">7847</a><td>  }<tr><td><a id="l7848"></a><a href="#l7848">7848</a><td><tr><td><a id="l7849"></a><a href="#l7849">7849</a><td>  // Given a line object, find its line number by walking up through<tr><td><a id="l7850"></a><a href="#l7850">7850</a><td>  // its parent links.<tr><td><a id="l7851"></a><a href="#l7851">7851</a><td>  function lineNo(line) {<tr><td><a id="l7852"></a><a href="#l7852">7852</a><td>    if (line.parent == null) return null;<tr><td><a id="l7853"></a><a href="#l7853">7853</a><td>    var cur = line.parent, no = indexOf(cur.lines, line);<tr><td><a id="l7854"></a><a href="#l7854">7854</a><td>    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {<tr><td><a id="l7855"></a><a href="#l7855">7855</a><td>      for (var i = 0;; ++i) {<tr><td><a id="l7856"></a><a href="#l7856">7856</a><td>        if (chunk.children[i] == cur) break;<tr><td><a id="l7857"></a><a href="#l7857">7857</a><td>        no += chunk.children[i].chunkSize();<tr><td><a id="l7858"></a><a href="#l7858">7858</a><td>      }<tr><td><a id="l7859"></a><a href="#l7859">7859</a><td>    }<tr><td><a id="l7860"></a><a href="#l7860">7860</a><td>    return no + cur.first;<tr><td><a id="l7861"></a><a href="#l7861">7861</a><td>  }<tr><td><a id="l7862"></a><a href="#l7862">7862</a><td><tr><td><a id="l7863"></a><a href="#l7863">7863</a><td>  // Find the line at the given vertical position, using the height<tr><td><a id="l7864"></a><a href="#l7864">7864</a><td>  // information in the document tree.<tr><td><a id="l7865"></a><a href="#l7865">7865</a><td>  function lineAtHeight(chunk, h) {<tr><td><a id="l7866"></a><a href="#l7866">7866</a><td>    var n = chunk.first;<tr><td><a id="l7867"></a><a href="#l7867">7867</a><td>    outer: do {<tr><td><a id="l7868"></a><a href="#l7868">7868</a><td>      for (var i = 0; i &lt; chunk.children.length; ++i) {<tr><td><a id="l7869"></a><a href="#l7869">7869</a><td>        var child = chunk.children[i], ch = child.height;<tr><td><a id="l7870"></a><a href="#l7870">7870</a><td>        if (h &lt; ch) { chunk = child; continue outer; }<tr><td><a id="l7871"></a><a href="#l7871">7871</a><td>        h -= ch;<tr><td><a id="l7872"></a><a href="#l7872">7872</a><td>        n += child.chunkSize();<tr><td><a id="l7873"></a><a href="#l7873">7873</a><td>      }<tr><td><a id="l7874"></a><a href="#l7874">7874</a><td>      return n;<tr><td><a id="l7875"></a><a href="#l7875">7875</a><td>    } while (!chunk.lines);<tr><td><a id="l7876"></a><a href="#l7876">7876</a><td>    for (var i = 0; i &lt; chunk.lines.length; ++i) {<tr><td><a id="l7877"></a><a href="#l7877">7877</a><td>      var line = chunk.lines[i], lh = line.height;<tr><td><a id="l7878"></a><a href="#l7878">7878</a><td>      if (h &lt; lh) break;<tr><td><a id="l7879"></a><a href="#l7879">7879</a><td>      h -= lh;<tr><td><a id="l7880"></a><a href="#l7880">7880</a><td>    }<tr><td><a id="l7881"></a><a href="#l7881">7881</a><td>    return n + i;<tr><td><a id="l7882"></a><a href="#l7882">7882</a><td>  }<tr><td><a id="l7883"></a><a href="#l7883">7883</a><td><tr><td><a id="l7884"></a><a href="#l7884">7884</a><td><tr><td><a id="l7885"></a><a href="#l7885">7885</a><td>  // Find the height above the given line.<tr><td><a id="l7886"></a><a href="#l7886">7886</a><td>  function heightAtLine(lineObj) {<tr><td><a id="l7887"></a><a href="#l7887">7887</a><td>    lineObj = visualLine(lineObj);<tr><td><a id="l7888"></a><a href="#l7888">7888</a><td><tr><td><a id="l7889"></a><a href="#l7889">7889</a><td>    var h = 0, chunk = lineObj.parent;<tr><td><a id="l7890"></a><a href="#l7890">7890</a><td>    for (var i = 0; i &lt; chunk.lines.length; ++i) {<tr><td><a id="l7891"></a><a href="#l7891">7891</a><td>      var line = chunk.lines[i];<tr><td><a id="l7892"></a><a href="#l7892">7892</a><td>      if (line == lineObj) break;<tr><td><a id="l7893"></a><a href="#l7893">7893</a><td>      else h += line.height;<tr><td><a id="l7894"></a><a href="#l7894">7894</a><td>    }<tr><td><a id="l7895"></a><a href="#l7895">7895</a><td>    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {<tr><td><a id="l7896"></a><a href="#l7896">7896</a><td>      for (var i = 0; i &lt; p.children.length; ++i) {<tr><td><a id="l7897"></a><a href="#l7897">7897</a><td>        var cur = p.children[i];<tr><td><a id="l7898"></a><a href="#l7898">7898</a><td>        if (cur == chunk) break;<tr><td><a id="l7899"></a><a href="#l7899">7899</a><td>        else h += cur.height;<tr><td><a id="l7900"></a><a href="#l7900">7900</a><td>      }<tr><td><a id="l7901"></a><a href="#l7901">7901</a><td>    }<tr><td><a id="l7902"></a><a href="#l7902">7902</a><td>    return h;<tr><td><a id="l7903"></a><a href="#l7903">7903</a><td>  }<tr><td><a id="l7904"></a><a href="#l7904">7904</a><td><tr><td><a id="l7905"></a><a href="#l7905">7905</a><td>  // Get the bidi ordering for the given line (and cache it). Returns<tr><td><a id="l7906"></a><a href="#l7906">7906</a><td>  // false for lines that are fully left-to-right, and an array of<tr><td><a id="l7907"></a><a href="#l7907">7907</a><td>  // BidiSpan objects otherwise.<tr><td><a id="l7908"></a><a href="#l7908">7908</a><td>  function getOrder(line) {<tr><td><a id="l7909"></a><a href="#l7909">7909</a><td>    var order = line.order;<tr><td><a id="l7910"></a><a href="#l7910">7910</a><td>    if (order == null) order = line.order = bidiOrdering(line.text);<tr><td><a id="l7911"></a><a href="#l7911">7911</a><td>    return order;<tr><td><a id="l7912"></a><a href="#l7912">7912</a><td>  }<tr><td><a id="l7913"></a><a href="#l7913">7913</a><td><tr><td><a id="l7914"></a><a href="#l7914">7914</a><td>  // HISTORY<tr><td><a id="l7915"></a><a href="#l7915">7915</a><td><tr><td><a id="l7916"></a><a href="#l7916">7916</a><td>  function History(startGen) {<tr><td><a id="l7917"></a><a href="#l7917">7917</a><td>    // Arrays of change events and selections. Doing something adds an<tr><td><a id="l7918"></a><a href="#l7918">7918</a><td>    // event to done and clears undo. Undoing moves events from done<tr><td><a id="l7919"></a><a href="#l7919">7919</a><td>    // to undone, redoing moves them in the other direction.<tr><td><a id="l7920"></a><a href="#l7920">7920</a><td>    this.done = []; this.undone = [];<tr><td><a id="l7921"></a><a href="#l7921">7921</a><td>    this.undoDepth = Infinity;<tr><td><a id="l7922"></a><a href="#l7922">7922</a><td>    // Used to track when changes can be merged into a single undo<tr><td><a id="l7923"></a><a href="#l7923">7923</a><td>    // event<tr><td><a id="l7924"></a><a href="#l7924">7924</a><td>    this.lastModTime = this.lastSelTime = 0;<tr><td><a id="l7925"></a><a href="#l7925">7925</a><td>    this.lastOp = this.lastSelOp = null;<tr><td><a id="l7926"></a><a href="#l7926">7926</a><td>    this.lastOrigin = this.lastSelOrigin = null;<tr><td><a id="l7927"></a><a href="#l7927">7927</a><td>    // Used by the isClean() method<tr><td><a id="l7928"></a><a href="#l7928">7928</a><td>    this.generation = this.maxGeneration = startGen || 1;<tr><td><a id="l7929"></a><a href="#l7929">7929</a><td>  }<tr><td><a id="l7930"></a><a href="#l7930">7930</a><td><tr><td><a id="l7931"></a><a href="#l7931">7931</a><td>  // Create a history change event from an updateDoc-style change<tr><td><a id="l7932"></a><a href="#l7932">7932</a><td>  // object.<tr><td><a id="l7933"></a><a href="#l7933">7933</a><td>  function historyChangeFromChange(doc, change) {<tr><td><a id="l7934"></a><a href="#l7934">7934</a><td>    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};<tr><td><a id="l7935"></a><a href="#l7935">7935</a><td>    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);<tr><td><a id="l7936"></a><a href="#l7936">7936</a><td>    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);<tr><td><a id="l7937"></a><a href="#l7937">7937</a><td>    return histChange;<tr><td><a id="l7938"></a><a href="#l7938">7938</a><td>  }<tr><td><a id="l7939"></a><a href="#l7939">7939</a><td><tr><td><a id="l7940"></a><a href="#l7940">7940</a><td>  // Pop all selection events off the end of a history array. Stop at<tr><td><a id="l7941"></a><a href="#l7941">7941</a><td>  // a change event.<tr><td><a id="l7942"></a><a href="#l7942">7942</a><td>  function clearSelectionEvents(array) {<tr><td><a id="l7943"></a><a href="#l7943">7943</a><td>    while (array.length) {<tr><td><a id="l7944"></a><a href="#l7944">7944</a><td>      var last = lst(array);<tr><td><a id="l7945"></a><a href="#l7945">7945</a><td>      if (last.ranges) array.pop();<tr><td><a id="l7946"></a><a href="#l7946">7946</a><td>      else break;<tr><td><a id="l7947"></a><a href="#l7947">7947</a><td>    }<tr><td><a id="l7948"></a><a href="#l7948">7948</a><td>  }<tr><td><a id="l7949"></a><a href="#l7949">7949</a><td><tr><td><a id="l7950"></a><a href="#l7950">7950</a><td>  // Find the top change event in the history. Pop off selection<tr><td><a id="l7951"></a><a href="#l7951">7951</a><td>  // events that are in the way.<tr><td><a id="l7952"></a><a href="#l7952">7952</a><td>  function lastChangeEvent(hist, force) {<tr><td><a id="l7953"></a><a href="#l7953">7953</a><td>    if (force) {<tr><td><a id="l7954"></a><a href="#l7954">7954</a><td>      clearSelectionEvents(hist.done);<tr><td><a id="l7955"></a><a href="#l7955">7955</a><td>      return lst(hist.done);<tr><td><a id="l7956"></a><a href="#l7956">7956</a><td>    } else if (hist.done.length &amp;&amp; !lst(hist.done).ranges) {<tr><td><a id="l7957"></a><a href="#l7957">7957</a><td>      return lst(hist.done);<tr><td><a id="l7958"></a><a href="#l7958">7958</a><td>    } else if (hist.done.length &gt; 1 &amp;&amp; !hist.done[hist.done.length - 2].ranges) {<tr><td><a id="l7959"></a><a href="#l7959">7959</a><td>      hist.done.pop();<tr><td><a id="l7960"></a><a href="#l7960">7960</a><td>      return lst(hist.done);<tr><td><a id="l7961"></a><a href="#l7961">7961</a><td>    }<tr><td><a id="l7962"></a><a href="#l7962">7962</a><td>  }<tr><td><a id="l7963"></a><a href="#l7963">7963</a><td><tr><td><a id="l7964"></a><a href="#l7964">7964</a><td>  // Register a change in the history. Merges changes that are within<tr><td><a id="l7965"></a><a href="#l7965">7965</a><td>  // a single operation, ore are close together with an origin that<tr><td><a id="l7966"></a><a href="#l7966">7966</a><td>  // allows merging (starting with &quot;+&quot;) into a single event.<tr><td><a id="l7967"></a><a href="#l7967">7967</a><td>  function addChangeToHistory(doc, change, selAfter, opId) {<tr><td><a id="l7968"></a><a href="#l7968">7968</a><td>    var hist = doc.history;<tr><td><a id="l7969"></a><a href="#l7969">7969</a><td>    hist.undone.length = 0;<tr><td><a id="l7970"></a><a href="#l7970">7970</a><td>    var time = +new Date, cur;<tr><td><a id="l7971"></a><a href="#l7971">7971</a><td><tr><td><a id="l7972"></a><a href="#l7972">7972</a><td>    if ((hist.lastOp == opId ||<tr><td><a id="l7973"></a><a href="#l7973">7973</a><td>         hist.lastOrigin == change.origin &amp;&amp; change.origin &amp;&amp;<tr><td><a id="l7974"></a><a href="#l7974">7974</a><td>         ((change.origin.charAt(0) == &quot;+&quot; &amp;&amp; doc.cm &amp;&amp; hist.lastModTime &gt; time - doc.cm.options.historyEventDelay) ||<tr><td><a id="l7975"></a><a href="#l7975">7975</a><td>          change.origin.charAt(0) == &quot;*&quot;)) &amp;&amp;<tr><td><a id="l7976"></a><a href="#l7976">7976</a><td>        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {<tr><td><a id="l7977"></a><a href="#l7977">7977</a><td>      // Merge this change into the last event<tr><td><a id="l7978"></a><a href="#l7978">7978</a><td>      var last = lst(cur.changes);<tr><td><a id="l7979"></a><a href="#l7979">7979</a><td>      if (cmp(change.from, change.to) == 0 &amp;&amp; cmp(change.from, last.to) == 0) {<tr><td><a id="l7980"></a><a href="#l7980">7980</a><td>        // Optimized case for simple insertion -- don&#39;t want to add<tr><td><a id="l7981"></a><a href="#l7981">7981</a><td>        // new changesets for every character typed<tr><td><a id="l7982"></a><a href="#l7982">7982</a><td>        last.to = changeEnd(change);<tr><td><a id="l7983"></a><a href="#l7983">7983</a><td>      } else {<tr><td><a id="l7984"></a><a href="#l7984">7984</a><td>        // Add new sub-event<tr><td><a id="l7985"></a><a href="#l7985">7985</a><td>        cur.changes.push(historyChangeFromChange(doc, change));<tr><td><a id="l7986"></a><a href="#l7986">7986</a><td>      }<tr><td><a id="l7987"></a><a href="#l7987">7987</a><td>    } else {<tr><td><a id="l7988"></a><a href="#l7988">7988</a><td>      // Can not be merged, start a new event.<tr><td><a id="l7989"></a><a href="#l7989">7989</a><td>      var before = lst(hist.done);<tr><td><a id="l7990"></a><a href="#l7990">7990</a><td>      if (!before || !before.ranges)<tr><td><a id="l7991"></a><a href="#l7991">7991</a><td>        pushSelectionToHistory(doc.sel, hist.done);<tr><td><a id="l7992"></a><a href="#l7992">7992</a><td>      cur = {changes: [historyChangeFromChange(doc, change)],<tr><td><a id="l7993"></a><a href="#l7993">7993</a><td>             generation: hist.generation};<tr><td><a id="l7994"></a><a href="#l7994">7994</a><td>      hist.done.push(cur);<tr><td><a id="l7995"></a><a href="#l7995">7995</a><td>      while (hist.done.length &gt; hist.undoDepth) {<tr><td><a id="l7996"></a><a href="#l7996">7996</a><td>        hist.done.shift();<tr><td><a id="l7997"></a><a href="#l7997">7997</a><td>        if (!hist.done[0].ranges) hist.done.shift();<tr><td><a id="l7998"></a><a href="#l7998">7998</a><td>      }<tr><td><a id="l7999"></a><a href="#l7999">7999</a><td>    }<tr><td><a id="l8000"></a><a href="#l8000">8000</a><td>    hist.done.push(selAfter);<tr><td><a id="l8001"></a><a href="#l8001">8001</a><td>    hist.generation = ++hist.maxGeneration;<tr><td><a id="l8002"></a><a href="#l8002">8002</a><td>    hist.lastModTime = hist.lastSelTime = time;<tr><td><a id="l8003"></a><a href="#l8003">8003</a><td>    hist.lastOp = hist.lastSelOp = opId;<tr><td><a id="l8004"></a><a href="#l8004">8004</a><td>    hist.lastOrigin = hist.lastSelOrigin = change.origin;<tr><td><a id="l8005"></a><a href="#l8005">8005</a><td><tr><td><a id="l8006"></a><a href="#l8006">8006</a><td>    if (!last) signal(doc, &quot;historyAdded&quot;);<tr><td><a id="l8007"></a><a href="#l8007">8007</a><td>  }<tr><td><a id="l8008"></a><a href="#l8008">8008</a><td><tr><td><a id="l8009"></a><a href="#l8009">8009</a><td>  function selectionEventCanBeMerged(doc, origin, prev, sel) {<tr><td><a id="l8010"></a><a href="#l8010">8010</a><td>    var ch = origin.charAt(0);<tr><td><a id="l8011"></a><a href="#l8011">8011</a><td>    return ch == &quot;*&quot; ||<tr><td><a id="l8012"></a><a href="#l8012">8012</a><td>      ch == &quot;+&quot; &amp;&amp;<tr><td><a id="l8013"></a><a href="#l8013">8013</a><td>      prev.ranges.length == sel.ranges.length &amp;&amp;<tr><td><a id="l8014"></a><a href="#l8014">8014</a><td>      prev.somethingSelected() == sel.somethingSelected() &amp;&amp;<tr><td><a id="l8015"></a><a href="#l8015">8015</a><td>      new Date - doc.history.lastSelTime &lt;= (doc.cm ? doc.cm.options.historyEventDelay : 500);<tr><td><a id="l8016"></a><a href="#l8016">8016</a><td>  }<tr><td><a id="l8017"></a><a href="#l8017">8017</a><td><tr><td><a id="l8018"></a><a href="#l8018">8018</a><td>  // Called whenever the selection changes, sets the new selection as<tr><td><a id="l8019"></a><a href="#l8019">8019</a><td>  // the pending selection in the history, and pushes the old pending<tr><td><a id="l8020"></a><a href="#l8020">8020</a><td>  // selection into the &#39;done&#39; array when it was significantly<tr><td><a id="l8021"></a><a href="#l8021">8021</a><td>  // different (in number of selected ranges, emptiness, or time).<tr><td><a id="l8022"></a><a href="#l8022">8022</a><td>  function addSelectionToHistory(doc, sel, opId, options) {<tr><td><a id="l8023"></a><a href="#l8023">8023</a><td>    var hist = doc.history, origin = options &amp;&amp; options.origin;<tr><td><a id="l8024"></a><a href="#l8024">8024</a><td><tr><td><a id="l8025"></a><a href="#l8025">8025</a><td>    // A new event is started when the previous origin does not match<tr><td><a id="l8026"></a><a href="#l8026">8026</a><td>    // the current, or the origins don&#39;t allow matching. Origins<tr><td><a id="l8027"></a><a href="#l8027">8027</a><td>    // starting with * are always merged, those starting with + are<tr><td><a id="l8028"></a><a href="#l8028">8028</a><td>    // merged when similar and close together in time.<tr><td><a id="l8029"></a><a href="#l8029">8029</a><td>    if (opId == hist.lastSelOp ||<tr><td><a id="l8030"></a><a href="#l8030">8030</a><td>        (origin &amp;&amp; hist.lastSelOrigin == origin &amp;&amp;<tr><td><a id="l8031"></a><a href="#l8031">8031</a><td>         (hist.lastModTime == hist.lastSelTime &amp;&amp; hist.lastOrigin == origin ||<tr><td><a id="l8032"></a><a href="#l8032">8032</a><td>          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))<tr><td><a id="l8033"></a><a href="#l8033">8033</a><td>      hist.done[hist.done.length - 1] = sel;<tr><td><a id="l8034"></a><a href="#l8034">8034</a><td>    else<tr><td><a id="l8035"></a><a href="#l8035">8035</a><td>      pushSelectionToHistory(sel, hist.done);<tr><td><a id="l8036"></a><a href="#l8036">8036</a><td><tr><td><a id="l8037"></a><a href="#l8037">8037</a><td>    hist.lastSelTime = +new Date;<tr><td><a id="l8038"></a><a href="#l8038">8038</a><td>    hist.lastSelOrigin = origin;<tr><td><a id="l8039"></a><a href="#l8039">8039</a><td>    hist.lastSelOp = opId;<tr><td><a id="l8040"></a><a href="#l8040">8040</a><td>    if (options &amp;&amp; options.clearRedo !== false)<tr><td><a id="l8041"></a><a href="#l8041">8041</a><td>      clearSelectionEvents(hist.undone);<tr><td><a id="l8042"></a><a href="#l8042">8042</a><td>  }<tr><td><a id="l8043"></a><a href="#l8043">8043</a><td><tr><td><a id="l8044"></a><a href="#l8044">8044</a><td>  function pushSelectionToHistory(sel, dest) {<tr><td><a id="l8045"></a><a href="#l8045">8045</a><td>    var top = lst(dest);<tr><td><a id="l8046"></a><a href="#l8046">8046</a><td>    if (!(top &amp;&amp; top.ranges &amp;&amp; top.equals(sel)))<tr><td><a id="l8047"></a><a href="#l8047">8047</a><td>      dest.push(sel);<tr><td><a id="l8048"></a><a href="#l8048">8048</a><td>  }<tr><td><a id="l8049"></a><a href="#l8049">8049</a><td><tr><td><a id="l8050"></a><a href="#l8050">8050</a><td>  // Used to store marked span information in the history.<tr><td><a id="l8051"></a><a href="#l8051">8051</a><td>  function attachLocalSpans(doc, change, from, to) {<tr><td><a id="l8052"></a><a href="#l8052">8052</a><td>    var existing = change[&quot;spans_&quot; + doc.id], n = 0;<tr><td><a id="l8053"></a><a href="#l8053">8053</a><td>    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {<tr><td><a id="l8054"></a><a href="#l8054">8054</a><td>      if (line.markedSpans)<tr><td><a id="l8055"></a><a href="#l8055">8055</a><td>        (existing || (existing = change[&quot;spans_&quot; + doc.id] = {}))[n] = line.markedSpans;<tr><td><a id="l8056"></a><a href="#l8056">8056</a><td>      ++n;<tr><td><a id="l8057"></a><a href="#l8057">8057</a><td>    });<tr><td><a id="l8058"></a><a href="#l8058">8058</a><td>  }<tr><td><a id="l8059"></a><a href="#l8059">8059</a><td><tr><td><a id="l8060"></a><a href="#l8060">8060</a><td>  // When un/re-doing restores text containing marked spans, those<tr><td><a id="l8061"></a><a href="#l8061">8061</a><td>  // that have been explicitly cleared should not be restored.<tr><td><a id="l8062"></a><a href="#l8062">8062</a><td>  function removeClearedSpans(spans) {<tr><td><a id="l8063"></a><a href="#l8063">8063</a><td>    if (!spans) return null;<tr><td><a id="l8064"></a><a href="#l8064">8064</a><td>    for (var i = 0, out; i &lt; spans.length; ++i) {<tr><td><a id="l8065"></a><a href="#l8065">8065</a><td>      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }<tr><td><a id="l8066"></a><a href="#l8066">8066</a><td>      else if (out) out.push(spans[i]);<tr><td><a id="l8067"></a><a href="#l8067">8067</a><td>    }<tr><td><a id="l8068"></a><a href="#l8068">8068</a><td>    return !out ? spans : out.length ? out : null;<tr><td><a id="l8069"></a><a href="#l8069">8069</a><td>  }<tr><td><a id="l8070"></a><a href="#l8070">8070</a><td><tr><td><a id="l8071"></a><a href="#l8071">8071</a><td>  // Retrieve and filter the old marked spans stored in a change event.<tr><td><a id="l8072"></a><a href="#l8072">8072</a><td>  function getOldSpans(doc, change) {<tr><td><a id="l8073"></a><a href="#l8073">8073</a><td>    var found = change[&quot;spans_&quot; + doc.id];<tr><td><a id="l8074"></a><a href="#l8074">8074</a><td>    if (!found) return null;<tr><td><a id="l8075"></a><a href="#l8075">8075</a><td>    for (var i = 0, nw = []; i &lt; change.text.length; ++i)<tr><td><a id="l8076"></a><a href="#l8076">8076</a><td>      nw.push(removeClearedSpans(found[i]));<tr><td><a id="l8077"></a><a href="#l8077">8077</a><td>    return nw;<tr><td><a id="l8078"></a><a href="#l8078">8078</a><td>  }<tr><td><a id="l8079"></a><a href="#l8079">8079</a><td><tr><td><a id="l8080"></a><a href="#l8080">8080</a><td>  // Used both to provide a JSON-safe object in .getHistory, and, when<tr><td><a id="l8081"></a><a href="#l8081">8081</a><td>  // detaching a document, to split the history in two<tr><td><a id="l8082"></a><a href="#l8082">8082</a><td>  function copyHistoryArray(events, newGroup, instantiateSel) {<tr><td><a id="l8083"></a><a href="#l8083">8083</a><td>    for (var i = 0, copy = []; i &lt; events.length; ++i) {<tr><td><a id="l8084"></a><a href="#l8084">8084</a><td>      var event = events[i];<tr><td><a id="l8085"></a><a href="#l8085">8085</a><td>      if (event.ranges) {<tr><td><a id="l8086"></a><a href="#l8086">8086</a><td>        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);<tr><td><a id="l8087"></a><a href="#l8087">8087</a><td>        continue;<tr><td><a id="l8088"></a><a href="#l8088">8088</a><td>      }<tr><td><a id="l8089"></a><a href="#l8089">8089</a><td>      var changes = event.changes, newChanges = [];<tr><td><a id="l8090"></a><a href="#l8090">8090</a><td>      copy.push({changes: newChanges});<tr><td><a id="l8091"></a><a href="#l8091">8091</a><td>      for (var j = 0; j &lt; changes.length; ++j) {<tr><td><a id="l8092"></a><a href="#l8092">8092</a><td>        var change = changes[j], m;<tr><td><a id="l8093"></a><a href="#l8093">8093</a><td>        newChanges.push({from: change.from, to: change.to, text: change.text});<tr><td><a id="l8094"></a><a href="#l8094">8094</a><td>        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {<tr><td><a id="l8095"></a><a href="#l8095">8095</a><td>          if (indexOf(newGroup, Number(m[1])) &gt; -1) {<tr><td><a id="l8096"></a><a href="#l8096">8096</a><td>            lst(newChanges)[prop] = change[prop];<tr><td><a id="l8097"></a><a href="#l8097">8097</a><td>            delete change[prop];<tr><td><a id="l8098"></a><a href="#l8098">8098</a><td>          }<tr><td><a id="l8099"></a><a href="#l8099">8099</a><td>        }<tr><td><a id="l8100"></a><a href="#l8100">8100</a><td>      }<tr><td><a id="l8101"></a><a href="#l8101">8101</a><td>    }<tr><td><a id="l8102"></a><a href="#l8102">8102</a><td>    return copy;<tr><td><a id="l8103"></a><a href="#l8103">8103</a><td>  }<tr><td><a id="l8104"></a><a href="#l8104">8104</a><td><tr><td><a id="l8105"></a><a href="#l8105">8105</a><td>  // Rebasing/resetting history to deal with externally-sourced changes<tr><td><a id="l8106"></a><a href="#l8106">8106</a><td><tr><td><a id="l8107"></a><a href="#l8107">8107</a><td>  function rebaseHistSelSingle(pos, from, to, diff) {<tr><td><a id="l8108"></a><a href="#l8108">8108</a><td>    if (to &lt; pos.line) {<tr><td><a id="l8109"></a><a href="#l8109">8109</a><td>      pos.line += diff;<tr><td><a id="l8110"></a><a href="#l8110">8110</a><td>    } else if (from &lt; pos.line) {<tr><td><a id="l8111"></a><a href="#l8111">8111</a><td>      pos.line = from;<tr><td><a id="l8112"></a><a href="#l8112">8112</a><td>      pos.ch = 0;<tr><td><a id="l8113"></a><a href="#l8113">8113</a><td>    }<tr><td><a id="l8114"></a><a href="#l8114">8114</a><td>  }<tr><td><a id="l8115"></a><a href="#l8115">8115</a><td><tr><td><a id="l8116"></a><a href="#l8116">8116</a><td>  // Tries to rebase an array of history events given a change in the<tr><td><a id="l8117"></a><a href="#l8117">8117</a><td>  // document. If the change touches the same lines as the event, the<tr><td><a id="l8118"></a><a href="#l8118">8118</a><td>  // event, and everything &#39;behind&#39; it, is discarded. If the change is<tr><td><a id="l8119"></a><a href="#l8119">8119</a><td>  // before the event, the event&#39;s positions are updated. Uses a<tr><td><a id="l8120"></a><a href="#l8120">8120</a><td>  // copy-on-write scheme for the positions, to avoid having to<tr><td><a id="l8121"></a><a href="#l8121">8121</a><td>  // reallocate them all on every rebase, but also avoid problems with<tr><td><a id="l8122"></a><a href="#l8122">8122</a><td>  // shared position objects being unsafely updated.<tr><td><a id="l8123"></a><a href="#l8123">8123</a><td>  function rebaseHistArray(array, from, to, diff) {<tr><td><a id="l8124"></a><a href="#l8124">8124</a><td>    for (var i = 0; i &lt; array.length; ++i) {<tr><td><a id="l8125"></a><a href="#l8125">8125</a><td>      var sub = array[i], ok = true;<tr><td><a id="l8126"></a><a href="#l8126">8126</a><td>      if (sub.ranges) {<tr><td><a id="l8127"></a><a href="#l8127">8127</a><td>        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }<tr><td><a id="l8128"></a><a href="#l8128">8128</a><td>        for (var j = 0; j &lt; sub.ranges.length; j++) {<tr><td><a id="l8129"></a><a href="#l8129">8129</a><td>          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);<tr><td><a id="l8130"></a><a href="#l8130">8130</a><td>          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);<tr><td><a id="l8131"></a><a href="#l8131">8131</a><td>        }<tr><td><a id="l8132"></a><a href="#l8132">8132</a><td>        continue;<tr><td><a id="l8133"></a><a href="#l8133">8133</a><td>      }<tr><td><a id="l8134"></a><a href="#l8134">8134</a><td>      for (var j = 0; j &lt; sub.changes.length; ++j) {<tr><td><a id="l8135"></a><a href="#l8135">8135</a><td>        var cur = sub.changes[j];<tr><td><a id="l8136"></a><a href="#l8136">8136</a><td>        if (to &lt; cur.from.line) {<tr><td><a id="l8137"></a><a href="#l8137">8137</a><td>          cur.from = Pos(cur.from.line + diff, cur.from.ch);<tr><td><a id="l8138"></a><a href="#l8138">8138</a><td>          cur.to = Pos(cur.to.line + diff, cur.to.ch);<tr><td><a id="l8139"></a><a href="#l8139">8139</a><td>        } else if (from &lt;= cur.to.line) {<tr><td><a id="l8140"></a><a href="#l8140">8140</a><td>          ok = false;<tr><td><a id="l8141"></a><a href="#l8141">8141</a><td>          break;<tr><td><a id="l8142"></a><a href="#l8142">8142</a><td>        }<tr><td><a id="l8143"></a><a href="#l8143">8143</a><td>      }<tr><td><a id="l8144"></a><a href="#l8144">8144</a><td>      if (!ok) {<tr><td><a id="l8145"></a><a href="#l8145">8145</a><td>        array.splice(0, i + 1);<tr><td><a id="l8146"></a><a href="#l8146">8146</a><td>        i = 0;<tr><td><a id="l8147"></a><a href="#l8147">8147</a><td>      }<tr><td><a id="l8148"></a><a href="#l8148">8148</a><td>    }<tr><td><a id="l8149"></a><a href="#l8149">8149</a><td>  }<tr><td><a id="l8150"></a><a href="#l8150">8150</a><td><tr><td><a id="l8151"></a><a href="#l8151">8151</a><td>  function rebaseHist(hist, change) {<tr><td><a id="l8152"></a><a href="#l8152">8152</a><td>    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;<tr><td><a id="l8153"></a><a href="#l8153">8153</a><td>    rebaseHistArray(hist.done, from, to, diff);<tr><td><a id="l8154"></a><a href="#l8154">8154</a><td>    rebaseHistArray(hist.undone, from, to, diff);<tr><td><a id="l8155"></a><a href="#l8155">8155</a><td>  }<tr><td><a id="l8156"></a><a href="#l8156">8156</a><td><tr><td><a id="l8157"></a><a href="#l8157">8157</a><td>  // EVENT UTILITIES<tr><td><a id="l8158"></a><a href="#l8158">8158</a><td><tr><td><a id="l8159"></a><a href="#l8159">8159</a><td>  // Due to the fact that we still support jurassic IE versions, some<tr><td><a id="l8160"></a><a href="#l8160">8160</a><td>  // compatibility wrappers are needed.<tr><td><a id="l8161"></a><a href="#l8161">8161</a><td><tr><td><a id="l8162"></a><a href="#l8162">8162</a><td>  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {<tr><td><a id="l8163"></a><a href="#l8163">8163</a><td>    if (e.preventDefault) e.preventDefault();<tr><td><a id="l8164"></a><a href="#l8164">8164</a><td>    else e.returnValue = false;<tr><td><a id="l8165"></a><a href="#l8165">8165</a><td>  };<tr><td><a id="l8166"></a><a href="#l8166">8166</a><td>  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {<tr><td><a id="l8167"></a><a href="#l8167">8167</a><td>    if (e.stopPropagation) e.stopPropagation();<tr><td><a id="l8168"></a><a href="#l8168">8168</a><td>    else e.cancelBubble = true;<tr><td><a id="l8169"></a><a href="#l8169">8169</a><td>  };<tr><td><a id="l8170"></a><a href="#l8170">8170</a><td>  function e_defaultPrevented(e) {<tr><td><a id="l8171"></a><a href="#l8171">8171</a><td>    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;<tr><td><a id="l8172"></a><a href="#l8172">8172</a><td>  }<tr><td><a id="l8173"></a><a href="#l8173">8173</a><td>  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};<tr><td><a id="l8174"></a><a href="#l8174">8174</a><td><tr><td><a id="l8175"></a><a href="#l8175">8175</a><td>  function e_target(e) {return e.target || e.srcElement;}<tr><td><a id="l8176"></a><a href="#l8176">8176</a><td>  function e_button(e) {<tr><td><a id="l8177"></a><a href="#l8177">8177</a><td>    var b = e.which;<tr><td><a id="l8178"></a><a href="#l8178">8178</a><td>    if (b == null) {<tr><td><a id="l8179"></a><a href="#l8179">8179</a><td>      if (e.button &amp; 1) b = 1;<tr><td><a id="l8180"></a><a href="#l8180">8180</a><td>      else if (e.button &amp; 2) b = 3;<tr><td><a id="l8181"></a><a href="#l8181">8181</a><td>      else if (e.button &amp; 4) b = 2;<tr><td><a id="l8182"></a><a href="#l8182">8182</a><td>    }<tr><td><a id="l8183"></a><a href="#l8183">8183</a><td>    if (mac &amp;&amp; e.ctrlKey &amp;&amp; b == 1) b = 3;<tr><td><a id="l8184"></a><a href="#l8184">8184</a><td>    return b;<tr><td><a id="l8185"></a><a href="#l8185">8185</a><td>  }<tr><td><a id="l8186"></a><a href="#l8186">8186</a><td><tr><td><a id="l8187"></a><a href="#l8187">8187</a><td>  // EVENT HANDLING<tr><td><a id="l8188"></a><a href="#l8188">8188</a><td><tr><td><a id="l8189"></a><a href="#l8189">8189</a><td>  // Lightweight event framework. on/off also work on DOM nodes,<tr><td><a id="l8190"></a><a href="#l8190">8190</a><td>  // registering native DOM handlers.<tr><td><a id="l8191"></a><a href="#l8191">8191</a><td><tr><td><a id="l8192"></a><a href="#l8192">8192</a><td>  var on = CodeMirror.on = function(emitter, type, f) {<tr><td><a id="l8193"></a><a href="#l8193">8193</a><td>    if (emitter.addEventListener)<tr><td><a id="l8194"></a><a href="#l8194">8194</a><td>      emitter.addEventListener(type, f, false);<tr><td><a id="l8195"></a><a href="#l8195">8195</a><td>    else if (emitter.attachEvent)<tr><td><a id="l8196"></a><a href="#l8196">8196</a><td>      emitter.attachEvent(&quot;on&quot; + type, f);<tr><td><a id="l8197"></a><a href="#l8197">8197</a><td>    else {<tr><td><a id="l8198"></a><a href="#l8198">8198</a><td>      var map = emitter._handlers || (emitter._handlers = {});<tr><td><a id="l8199"></a><a href="#l8199">8199</a><td>      var arr = map[type] || (map[type] = []);<tr><td><a id="l8200"></a><a href="#l8200">8200</a><td>      arr.push(f);<tr><td><a id="l8201"></a><a href="#l8201">8201</a><td>    }<tr><td><a id="l8202"></a><a href="#l8202">8202</a><td>  };<tr><td><a id="l8203"></a><a href="#l8203">8203</a><td><tr><td><a id="l8204"></a><a href="#l8204">8204</a><td>  var noHandlers = []<tr><td><a id="l8205"></a><a href="#l8205">8205</a><td>  function getHandlers(emitter, type, copy) {<tr><td><a id="l8206"></a><a href="#l8206">8206</a><td>    var arr = emitter._handlers &amp;&amp; emitter._handlers[type]<tr><td><a id="l8207"></a><a href="#l8207">8207</a><td>    if (copy) return arr &amp;&amp; arr.length &gt; 0 ? arr.slice() : noHandlers<tr><td><a id="l8208"></a><a href="#l8208">8208</a><td>    else return arr || noHandlers<tr><td><a id="l8209"></a><a href="#l8209">8209</a><td>  }<tr><td><a id="l8210"></a><a href="#l8210">8210</a><td><tr><td><a id="l8211"></a><a href="#l8211">8211</a><td>  var off = CodeMirror.off = function(emitter, type, f) {<tr><td><a id="l8212"></a><a href="#l8212">8212</a><td>    if (emitter.removeEventListener)<tr><td><a id="l8213"></a><a href="#l8213">8213</a><td>      emitter.removeEventListener(type, f, false);<tr><td><a id="l8214"></a><a href="#l8214">8214</a><td>    else if (emitter.detachEvent)<tr><td><a id="l8215"></a><a href="#l8215">8215</a><td>      emitter.detachEvent(&quot;on&quot; + type, f);<tr><td><a id="l8216"></a><a href="#l8216">8216</a><td>    else {<tr><td><a id="l8217"></a><a href="#l8217">8217</a><td>      var handlers = getHandlers(emitter, type, false)<tr><td><a id="l8218"></a><a href="#l8218">8218</a><td>      for (var i = 0; i &lt; handlers.length; ++i)<tr><td><a id="l8219"></a><a href="#l8219">8219</a><td>        if (handlers[i] == f) { handlers.splice(i, 1); break; }<tr><td><a id="l8220"></a><a href="#l8220">8220</a><td>    }<tr><td><a id="l8221"></a><a href="#l8221">8221</a><td>  };<tr><td><a id="l8222"></a><a href="#l8222">8222</a><td><tr><td><a id="l8223"></a><a href="#l8223">8223</a><td>  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {<tr><td><a id="l8224"></a><a href="#l8224">8224</a><td>    var handlers = getHandlers(emitter, type, true)<tr><td><a id="l8225"></a><a href="#l8225">8225</a><td>    if (!handlers.length) return;<tr><td><a id="l8226"></a><a href="#l8226">8226</a><td>    var args = Array.prototype.slice.call(arguments, 2);<tr><td><a id="l8227"></a><a href="#l8227">8227</a><td>    for (var i = 0; i &lt; handlers.length; ++i) handlers[i].apply(null, args);<tr><td><a id="l8228"></a><a href="#l8228">8228</a><td>  };<tr><td><a id="l8229"></a><a href="#l8229">8229</a><td><tr><td><a id="l8230"></a><a href="#l8230">8230</a><td>  var orphanDelayedCallbacks = null;<tr><td><a id="l8231"></a><a href="#l8231">8231</a><td><tr><td><a id="l8232"></a><a href="#l8232">8232</a><td>  // Often, we want to signal events at a point where we are in the<tr><td><a id="l8233"></a><a href="#l8233">8233</a><td>  // middle of some work, but don&#39;t want the handler to start calling<tr><td><a id="l8234"></a><a href="#l8234">8234</a><td>  // other methods on the editor, which might be in an inconsistent<tr><td><a id="l8235"></a><a href="#l8235">8235</a><td>  // state or simply not expect any other events to happen.<tr><td><a id="l8236"></a><a href="#l8236">8236</a><td>  // signalLater looks whether there are any handlers, and schedules<tr><td><a id="l8237"></a><a href="#l8237">8237</a><td>  // them to be executed when the last operation ends, or, if no<tr><td><a id="l8238"></a><a href="#l8238">8238</a><td>  // operation is active, when a timeout fires.<tr><td><a id="l8239"></a><a href="#l8239">8239</a><td>  function signalLater(emitter, type /*, values...*/) {<tr><td><a id="l8240"></a><a href="#l8240">8240</a><td>    var arr = getHandlers(emitter, type, false)<tr><td><a id="l8241"></a><a href="#l8241">8241</a><td>    if (!arr.length) return;<tr><td><a id="l8242"></a><a href="#l8242">8242</a><td>    var args = Array.prototype.slice.call(arguments, 2), list;<tr><td><a id="l8243"></a><a href="#l8243">8243</a><td>    if (operationGroup) {<tr><td><a id="l8244"></a><a href="#l8244">8244</a><td>      list = operationGroup.delayedCallbacks;<tr><td><a id="l8245"></a><a href="#l8245">8245</a><td>    } else if (orphanDelayedCallbacks) {<tr><td><a id="l8246"></a><a href="#l8246">8246</a><td>      list = orphanDelayedCallbacks;<tr><td><a id="l8247"></a><a href="#l8247">8247</a><td>    } else {<tr><td><a id="l8248"></a><a href="#l8248">8248</a><td>      list = orphanDelayedCallbacks = [];<tr><td><a id="l8249"></a><a href="#l8249">8249</a><td>      setTimeout(fireOrphanDelayed, 0);<tr><td><a id="l8250"></a><a href="#l8250">8250</a><td>    }<tr><td><a id="l8251"></a><a href="#l8251">8251</a><td>    function bnd(f) {return function(){f.apply(null, args);};};<tr><td><a id="l8252"></a><a href="#l8252">8252</a><td>    for (var i = 0; i &lt; arr.length; ++i)<tr><td><a id="l8253"></a><a href="#l8253">8253</a><td>      list.push(bnd(arr[i]));<tr><td><a id="l8254"></a><a href="#l8254">8254</a><td>  }<tr><td><a id="l8255"></a><a href="#l8255">8255</a><td><tr><td><a id="l8256"></a><a href="#l8256">8256</a><td>  function fireOrphanDelayed() {<tr><td><a id="l8257"></a><a href="#l8257">8257</a><td>    var delayed = orphanDelayedCallbacks;<tr><td><a id="l8258"></a><a href="#l8258">8258</a><td>    orphanDelayedCallbacks = null;<tr><td><a id="l8259"></a><a href="#l8259">8259</a><td>    for (var i = 0; i &lt; delayed.length; ++i) delayed[i]();<tr><td><a id="l8260"></a><a href="#l8260">8260</a><td>  }<tr><td><a id="l8261"></a><a href="#l8261">8261</a><td><tr><td><a id="l8262"></a><a href="#l8262">8262</a><td>  // The DOM events that CodeMirror handles can be overridden by<tr><td><a id="l8263"></a><a href="#l8263">8263</a><td>  // registering a (non-DOM) handler on the editor for the event name,<tr><td><a id="l8264"></a><a href="#l8264">8264</a><td>  // and preventDefault-ing the event in that handler.<tr><td><a id="l8265"></a><a href="#l8265">8265</a><td>  function signalDOMEvent(cm, e, override) {<tr><td><a id="l8266"></a><a href="#l8266">8266</a><td>    if (typeof e == &quot;string&quot;)<tr><td><a id="l8267"></a><a href="#l8267">8267</a><td>      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};<tr><td><a id="l8268"></a><a href="#l8268">8268</a><td>    signal(cm, override || e.type, cm, e);<tr><td><a id="l8269"></a><a href="#l8269">8269</a><td>    return e_defaultPrevented(e) || e.codemirrorIgnore;<tr><td><a id="l8270"></a><a href="#l8270">8270</a><td>  }<tr><td><a id="l8271"></a><a href="#l8271">8271</a><td><tr><td><a id="l8272"></a><a href="#l8272">8272</a><td>  function signalCursorActivity(cm) {<tr><td><a id="l8273"></a><a href="#l8273">8273</a><td>    var arr = cm._handlers &amp;&amp; cm._handlers.cursorActivity;<tr><td><a id="l8274"></a><a href="#l8274">8274</a><td>    if (!arr) return;<tr><td><a id="l8275"></a><a href="#l8275">8275</a><td>    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);<tr><td><a id="l8276"></a><a href="#l8276">8276</a><td>    for (var i = 0; i &lt; arr.length; ++i) if (indexOf(set, arr[i]) == -1)<tr><td><a id="l8277"></a><a href="#l8277">8277</a><td>      set.push(arr[i]);<tr><td><a id="l8278"></a><a href="#l8278">8278</a><td>  }<tr><td><a id="l8279"></a><a href="#l8279">8279</a><td><tr><td><a id="l8280"></a><a href="#l8280">8280</a><td>  function hasHandler(emitter, type) {<tr><td><a id="l8281"></a><a href="#l8281">8281</a><td>    return getHandlers(emitter, type).length &gt; 0<tr><td><a id="l8282"></a><a href="#l8282">8282</a><td>  }<tr><td><a id="l8283"></a><a href="#l8283">8283</a><td><tr><td><a id="l8284"></a><a href="#l8284">8284</a><td>  // Add on and off methods to a constructor&#39;s prototype, to make<tr><td><a id="l8285"></a><a href="#l8285">8285</a><td>  // registering events on such objects more convenient.<tr><td><a id="l8286"></a><a href="#l8286">8286</a><td>  function eventMixin(ctor) {<tr><td><a id="l8287"></a><a href="#l8287">8287</a><td>    ctor.prototype.on = function(type, f) {on(this, type, f);};<tr><td><a id="l8288"></a><a href="#l8288">8288</a><td>    ctor.prototype.off = function(type, f) {off(this, type, f);};<tr><td><a id="l8289"></a><a href="#l8289">8289</a><td>  }<tr><td><a id="l8290"></a><a href="#l8290">8290</a><td><tr><td><a id="l8291"></a><a href="#l8291">8291</a><td>  // MISC UTILITIES<tr><td><a id="l8292"></a><a href="#l8292">8292</a><td><tr><td><a id="l8293"></a><a href="#l8293">8293</a><td>  // Number of pixels added to scroller and sizer to hide scrollbar<tr><td><a id="l8294"></a><a href="#l8294">8294</a><td>  var scrollerGap = 30;<tr><td><a id="l8295"></a><a href="#l8295">8295</a><td><tr><td><a id="l8296"></a><a href="#l8296">8296</a><td>  // Returned or thrown by various protocols to signal &#39;I&#39;m not<tr><td><a id="l8297"></a><a href="#l8297">8297</a><td>  // handling this&#39;.<tr><td><a id="l8298"></a><a href="#l8298">8298</a><td>  var Pass = CodeMirror.Pass = {toString: function(){return &quot;CodeMirror.Pass&quot;;}};<tr><td><a id="l8299"></a><a href="#l8299">8299</a><td><tr><td><a id="l8300"></a><a href="#l8300">8300</a><td>  // Reused option objects for setSelection &amp; friends<tr><td><a id="l8301"></a><a href="#l8301">8301</a><td>  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: &quot;*mouse&quot;}, sel_move = {origin: &quot;+move&quot;};<tr><td><a id="l8302"></a><a href="#l8302">8302</a><td><tr><td><a id="l8303"></a><a href="#l8303">8303</a><td>  function Delayed() {this.id = null;}<tr><td><a id="l8304"></a><a href="#l8304">8304</a><td>  Delayed.prototype.set = function(ms, f) {<tr><td><a id="l8305"></a><a href="#l8305">8305</a><td>    clearTimeout(this.id);<tr><td><a id="l8306"></a><a href="#l8306">8306</a><td>    this.id = setTimeout(f, ms);<tr><td><a id="l8307"></a><a href="#l8307">8307</a><td>  };<tr><td><a id="l8308"></a><a href="#l8308">8308</a><td><tr><td><a id="l8309"></a><a href="#l8309">8309</a><td>  // Counts the column offset in a string, taking tabs into account.<tr><td><a id="l8310"></a><a href="#l8310">8310</a><td>  // Used mostly to find indentation.<tr><td><a id="l8311"></a><a href="#l8311">8311</a><td>  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {<tr><td><a id="l8312"></a><a href="#l8312">8312</a><td>    if (end == null) {<tr><td><a id="l8313"></a><a href="#l8313">8313</a><td>      end = string.search(/[^\s\u00a0]/);<tr><td><a id="l8314"></a><a href="#l8314">8314</a><td>      if (end == -1) end = string.length;<tr><td><a id="l8315"></a><a href="#l8315">8315</a><td>    }<tr><td><a id="l8316"></a><a href="#l8316">8316</a><td>    for (var i = startIndex || 0, n = startValue || 0;;) {<tr><td><a id="l8317"></a><a href="#l8317">8317</a><td>      var nextTab = string.indexOf(&quot;\t&quot;, i);<tr><td><a id="l8318"></a><a href="#l8318">8318</a><td>      if (nextTab &lt; 0 || nextTab &gt;= end)<tr><td><a id="l8319"></a><a href="#l8319">8319</a><td>        return n + (end - i);<tr><td><a id="l8320"></a><a href="#l8320">8320</a><td>      n += nextTab - i;<tr><td><a id="l8321"></a><a href="#l8321">8321</a><td>      n += tabSize - (n % tabSize);<tr><td><a id="l8322"></a><a href="#l8322">8322</a><td>      i = nextTab + 1;<tr><td><a id="l8323"></a><a href="#l8323">8323</a><td>    }<tr><td><a id="l8324"></a><a href="#l8324">8324</a><td>  };<tr><td><a id="l8325"></a><a href="#l8325">8325</a><td><tr><td><a id="l8326"></a><a href="#l8326">8326</a><td>  // The inverse of countColumn -- find the offset that corresponds to<tr><td><a id="l8327"></a><a href="#l8327">8327</a><td>  // a particular column.<tr><td><a id="l8328"></a><a href="#l8328">8328</a><td>  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {<tr><td><a id="l8329"></a><a href="#l8329">8329</a><td>    for (var pos = 0, col = 0;;) {<tr><td><a id="l8330"></a><a href="#l8330">8330</a><td>      var nextTab = string.indexOf(&quot;\t&quot;, pos);<tr><td><a id="l8331"></a><a href="#l8331">8331</a><td>      if (nextTab == -1) nextTab = string.length;<tr><td><a id="l8332"></a><a href="#l8332">8332</a><td>      var skipped = nextTab - pos;<tr><td><a id="l8333"></a><a href="#l8333">8333</a><td>      if (nextTab == string.length || col + skipped &gt;= goal)<tr><td><a id="l8334"></a><a href="#l8334">8334</a><td>        return pos + Math.min(skipped, goal - col);<tr><td><a id="l8335"></a><a href="#l8335">8335</a><td>      col += nextTab - pos;<tr><td><a id="l8336"></a><a href="#l8336">8336</a><td>      col += tabSize - (col % tabSize);<tr><td><a id="l8337"></a><a href="#l8337">8337</a><td>      pos = nextTab + 1;<tr><td><a id="l8338"></a><a href="#l8338">8338</a><td>      if (col &gt;= goal) return pos;<tr><td><a id="l8339"></a><a href="#l8339">8339</a><td>    }<tr><td><a id="l8340"></a><a href="#l8340">8340</a><td>  }<tr><td><a id="l8341"></a><a href="#l8341">8341</a><td><tr><td><a id="l8342"></a><a href="#l8342">8342</a><td>  var spaceStrs = [&quot;&quot;];<tr><td><a id="l8343"></a><a href="#l8343">8343</a><td>  function spaceStr(n) {<tr><td><a id="l8344"></a><a href="#l8344">8344</a><td>    while (spaceStrs.length &lt;= n)<tr><td><a id="l8345"></a><a href="#l8345">8345</a><td>      spaceStrs.push(lst(spaceStrs) + &quot; &quot;);<tr><td><a id="l8346"></a><a href="#l8346">8346</a><td>    return spaceStrs[n];<tr><td><a id="l8347"></a><a href="#l8347">8347</a><td>  }<tr><td><a id="l8348"></a><a href="#l8348">8348</a><td><tr><td><a id="l8349"></a><a href="#l8349">8349</a><td>  function lst(arr) { return arr[arr.length-1]; }<tr><td><a id="l8350"></a><a href="#l8350">8350</a><td><tr><td><a id="l8351"></a><a href="#l8351">8351</a><td>  var selectInput = function(node) { node.select(); };<tr><td><a id="l8352"></a><a href="#l8352">8352</a><td>  if (ios) // Mobile Safari apparently has a bug where select() is broken.<tr><td><a id="l8353"></a><a href="#l8353">8353</a><td>    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };<tr><td><a id="l8354"></a><a href="#l8354">8354</a><td>  else if (ie) // Suppress mysterious IE10 errors<tr><td><a id="l8355"></a><a href="#l8355">8355</a><td>    selectInput = function(node) { try { node.select(); } catch(_e) {} };<tr><td><a id="l8356"></a><a href="#l8356">8356</a><td><tr><td><a id="l8357"></a><a href="#l8357">8357</a><td>  function indexOf(array, elt) {<tr><td><a id="l8358"></a><a href="#l8358">8358</a><td>    for (var i = 0; i &lt; array.length; ++i)<tr><td><a id="l8359"></a><a href="#l8359">8359</a><td>      if (array[i] == elt) return i;<tr><td><a id="l8360"></a><a href="#l8360">8360</a><td>    return -1;<tr><td><a id="l8361"></a><a href="#l8361">8361</a><td>  }<tr><td><a id="l8362"></a><a href="#l8362">8362</a><td>  function map(array, f) {<tr><td><a id="l8363"></a><a href="#l8363">8363</a><td>    var out = [];<tr><td><a id="l8364"></a><a href="#l8364">8364</a><td>    for (var i = 0; i &lt; array.length; i++) out[i] = f(array[i], i);<tr><td><a id="l8365"></a><a href="#l8365">8365</a><td>    return out;<tr><td><a id="l8366"></a><a href="#l8366">8366</a><td>  }<tr><td><a id="l8367"></a><a href="#l8367">8367</a><td><tr><td><a id="l8368"></a><a href="#l8368">8368</a><td>  function nothing() {}<tr><td><a id="l8369"></a><a href="#l8369">8369</a><td><tr><td><a id="l8370"></a><a href="#l8370">8370</a><td>  function createObj(base, props) {<tr><td><a id="l8371"></a><a href="#l8371">8371</a><td>    var inst;<tr><td><a id="l8372"></a><a href="#l8372">8372</a><td>    if (Object.create) {<tr><td><a id="l8373"></a><a href="#l8373">8373</a><td>      inst = Object.create(base);<tr><td><a id="l8374"></a><a href="#l8374">8374</a><td>    } else {<tr><td><a id="l8375"></a><a href="#l8375">8375</a><td>      nothing.prototype = base;<tr><td><a id="l8376"></a><a href="#l8376">8376</a><td>      inst = new nothing();<tr><td><a id="l8377"></a><a href="#l8377">8377</a><td>    }<tr><td><a id="l8378"></a><a href="#l8378">8378</a><td>    if (props) copyObj(props, inst);<tr><td><a id="l8379"></a><a href="#l8379">8379</a><td>    return inst;<tr><td><a id="l8380"></a><a href="#l8380">8380</a><td>  };<tr><td><a id="l8381"></a><a href="#l8381">8381</a><td><tr><td><a id="l8382"></a><a href="#l8382">8382</a><td>  function copyObj(obj, target, overwrite) {<tr><td><a id="l8383"></a><a href="#l8383">8383</a><td>    if (!target) target = {};<tr><td><a id="l8384"></a><a href="#l8384">8384</a><td>    for (var prop in obj)<tr><td><a id="l8385"></a><a href="#l8385">8385</a><td>      if (obj.hasOwnProperty(prop) &amp;&amp; (overwrite !== false || !target.hasOwnProperty(prop)))<tr><td><a id="l8386"></a><a href="#l8386">8386</a><td>        target[prop] = obj[prop];<tr><td><a id="l8387"></a><a href="#l8387">8387</a><td>    return target;<tr><td><a id="l8388"></a><a href="#l8388">8388</a><td>  }<tr><td><a id="l8389"></a><a href="#l8389">8389</a><td><tr><td><a id="l8390"></a><a href="#l8390">8390</a><td>  function bind(f) {<tr><td><a id="l8391"></a><a href="#l8391">8391</a><td>    var args = Array.prototype.slice.call(arguments, 1);<tr><td><a id="l8392"></a><a href="#l8392">8392</a><td>    return function(){return f.apply(null, args);};<tr><td><a id="l8393"></a><a href="#l8393">8393</a><td>  }<tr><td><a id="l8394"></a><a href="#l8394">8394</a><td><tr><td><a id="l8395"></a><a href="#l8395">8395</a><td>  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;<tr><td><a id="l8396"></a><a href="#l8396">8396</a><td>  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {<tr><td><a id="l8397"></a><a href="#l8397">8397</a><td>    return /\w/.test(ch) || ch &gt; &quot;\x80&quot; &amp;&amp;<tr><td><a id="l8398"></a><a href="#l8398">8398</a><td>      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));<tr><td><a id="l8399"></a><a href="#l8399">8399</a><td>  };<tr><td><a id="l8400"></a><a href="#l8400">8400</a><td>  function isWordChar(ch, helper) {<tr><td><a id="l8401"></a><a href="#l8401">8401</a><td>    if (!helper) return isWordCharBasic(ch);<tr><td><a id="l8402"></a><a href="#l8402">8402</a><td>    if (helper.source.indexOf(&quot;\\w&quot;) &gt; -1 &amp;&amp; isWordCharBasic(ch)) return true;<tr><td><a id="l8403"></a><a href="#l8403">8403</a><td>    return helper.test(ch);<tr><td><a id="l8404"></a><a href="#l8404">8404</a><td>  }<tr><td><a id="l8405"></a><a href="#l8405">8405</a><td><tr><td><a id="l8406"></a><a href="#l8406">8406</a><td>  function isEmpty(obj) {<tr><td><a id="l8407"></a><a href="#l8407">8407</a><td>    for (var n in obj) if (obj.hasOwnProperty(n) &amp;&amp; obj[n]) return false;<tr><td><a id="l8408"></a><a href="#l8408">8408</a><td>    return true;<tr><td><a id="l8409"></a><a href="#l8409">8409</a><td>  }<tr><td><a id="l8410"></a><a href="#l8410">8410</a><td><tr><td><a id="l8411"></a><a href="#l8411">8411</a><td>  // Extending unicode characters. A series of a non-extending char +<tr><td><a id="l8412"></a><a href="#l8412">8412</a><td>  // any number of extending chars is treated as a single unit as far<tr><td><a id="l8413"></a><a href="#l8413">8413</a><td>  // as editing and measuring is concerned. This is not fully correct,<tr><td><a id="l8414"></a><a href="#l8414">8414</a><td>  // since some scripts/fonts/browsers also treat other configurations<tr><td><a id="l8415"></a><a href="#l8415">8415</a><td>  // of code points as a group.<tr><td><a id="l8416"></a><a href="#l8416">8416</a><td>  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;<tr><td><a id="l8417"></a><a href="#l8417">8417</a><td>  function isExtendingChar(ch) { return ch.charCodeAt(0) &gt;= 768 &amp;&amp; extendingChars.test(ch); }<tr><td><a id="l8418"></a><a href="#l8418">8418</a><td><tr><td><a id="l8419"></a><a href="#l8419">8419</a><td>  // DOM UTILITIES<tr><td><a id="l8420"></a><a href="#l8420">8420</a><td><tr><td><a id="l8421"></a><a href="#l8421">8421</a><td>  function elt(tag, content, className, style) {<tr><td><a id="l8422"></a><a href="#l8422">8422</a><td>    var e = document.createElement(tag);<tr><td><a id="l8423"></a><a href="#l8423">8423</a><td>    if (className) e.className = className;<tr><td><a id="l8424"></a><a href="#l8424">8424</a><td>    if (style) e.style.cssText = style;<tr><td><a id="l8425"></a><a href="#l8425">8425</a><td>    if (typeof content == &quot;string&quot;) e.appendChild(document.createTextNode(content));<tr><td><a id="l8426"></a><a href="#l8426">8426</a><td>    else if (content) for (var i = 0; i &lt; content.length; ++i) e.appendChild(content[i]);<tr><td><a id="l8427"></a><a href="#l8427">8427</a><td>    return e;<tr><td><a id="l8428"></a><a href="#l8428">8428</a><td>  }<tr><td><a id="l8429"></a><a href="#l8429">8429</a><td><tr><td><a id="l8430"></a><a href="#l8430">8430</a><td>  var range;<tr><td><a id="l8431"></a><a href="#l8431">8431</a><td>  if (document.createRange) range = function(node, start, end, endNode) {<tr><td><a id="l8432"></a><a href="#l8432">8432</a><td>    var r = document.createRange();<tr><td><a id="l8433"></a><a href="#l8433">8433</a><td>    r.setEnd(endNode || node, end);<tr><td><a id="l8434"></a><a href="#l8434">8434</a><td>    r.setStart(node, start);<tr><td><a id="l8435"></a><a href="#l8435">8435</a><td>    return r;<tr><td><a id="l8436"></a><a href="#l8436">8436</a><td>  };<tr><td><a id="l8437"></a><a href="#l8437">8437</a><td>  else range = function(node, start, end) {<tr><td><a id="l8438"></a><a href="#l8438">8438</a><td>    var r = document.body.createTextRange();<tr><td><a id="l8439"></a><a href="#l8439">8439</a><td>    try { r.moveToElementText(node.parentNode); }<tr><td><a id="l8440"></a><a href="#l8440">8440</a><td>    catch(e) { return r; }<tr><td><a id="l8441"></a><a href="#l8441">8441</a><td>    r.collapse(true);<tr><td><a id="l8442"></a><a href="#l8442">8442</a><td>    r.moveEnd(&quot;character&quot;, end);<tr><td><a id="l8443"></a><a href="#l8443">8443</a><td>    r.moveStart(&quot;character&quot;, start);<tr><td><a id="l8444"></a><a href="#l8444">8444</a><td>    return r;<tr><td><a id="l8445"></a><a href="#l8445">8445</a><td>  };<tr><td><a id="l8446"></a><a href="#l8446">8446</a><td><tr><td><a id="l8447"></a><a href="#l8447">8447</a><td>  function removeChildren(e) {<tr><td><a id="l8448"></a><a href="#l8448">8448</a><td>    for (var count = e.childNodes.length; count &gt; 0; --count)<tr><td><a id="l8449"></a><a href="#l8449">8449</a><td>      e.removeChild(e.firstChild);<tr><td><a id="l8450"></a><a href="#l8450">8450</a><td>    return e;<tr><td><a id="l8451"></a><a href="#l8451">8451</a><td>  }<tr><td><a id="l8452"></a><a href="#l8452">8452</a><td><tr><td><a id="l8453"></a><a href="#l8453">8453</a><td>  function removeChildrenAndAdd(parent, e) {<tr><td><a id="l8454"></a><a href="#l8454">8454</a><td>    return removeChildren(parent).appendChild(e);<tr><td><a id="l8455"></a><a href="#l8455">8455</a><td>  }<tr><td><a id="l8456"></a><a href="#l8456">8456</a><td><tr><td><a id="l8457"></a><a href="#l8457">8457</a><td>  var contains = CodeMirror.contains = function(parent, child) {<tr><td><a id="l8458"></a><a href="#l8458">8458</a><td>    if (child.nodeType == 3) // Android browser always returns false when child is a textnode<tr><td><a id="l8459"></a><a href="#l8459">8459</a><td>      child = child.parentNode;<tr><td><a id="l8460"></a><a href="#l8460">8460</a><td>    if (parent.contains)<tr><td><a id="l8461"></a><a href="#l8461">8461</a><td>      return parent.contains(child);<tr><td><a id="l8462"></a><a href="#l8462">8462</a><td>    do {<tr><td><a id="l8463"></a><a href="#l8463">8463</a><td>      if (child.nodeType == 11) child = child.host;<tr><td><a id="l8464"></a><a href="#l8464">8464</a><td>      if (child == parent) return true;<tr><td><a id="l8465"></a><a href="#l8465">8465</a><td>    } while (child = child.parentNode);<tr><td><a id="l8466"></a><a href="#l8466">8466</a><td>  };<tr><td><a id="l8467"></a><a href="#l8467">8467</a><td><tr><td><a id="l8468"></a><a href="#l8468">8468</a><td>  function activeElt() {<tr><td><a id="l8469"></a><a href="#l8469">8469</a><td>    var activeElement = document.activeElement;<tr><td><a id="l8470"></a><a href="#l8470">8470</a><td>    while (activeElement &amp;&amp; activeElement.root &amp;&amp; activeElement.root.activeElement)<tr><td><a id="l8471"></a><a href="#l8471">8471</a><td>      activeElement = activeElement.root.activeElement;<tr><td><a id="l8472"></a><a href="#l8472">8472</a><td>    return activeElement;<tr><td><a id="l8473"></a><a href="#l8473">8473</a><td>  }<tr><td><a id="l8474"></a><a href="#l8474">8474</a><td>  // Older versions of IE throws unspecified error when touching<tr><td><a id="l8475"></a><a href="#l8475">8475</a><td>  // document.activeElement in some cases (during loading, in iframe)<tr><td><a id="l8476"></a><a href="#l8476">8476</a><td>  if (ie &amp;&amp; ie_version &lt; 11) activeElt = function() {<tr><td><a id="l8477"></a><a href="#l8477">8477</a><td>    try { return document.activeElement; }<tr><td><a id="l8478"></a><a href="#l8478">8478</a><td>    catch(e) { return document.body; }<tr><td><a id="l8479"></a><a href="#l8479">8479</a><td>  };<tr><td><a id="l8480"></a><a href="#l8480">8480</a><td><tr><td><a id="l8481"></a><a href="#l8481">8481</a><td>  function classTest(cls) { return new RegExp(&quot;(^|\\s)&quot; + cls + &quot;(?:$|\\s)\\s*&quot;); }<tr><td><a id="l8482"></a><a href="#l8482">8482</a><td>  var rmClass = CodeMirror.rmClass = function(node, cls) {<tr><td><a id="l8483"></a><a href="#l8483">8483</a><td>    var current = node.className;<tr><td><a id="l8484"></a><a href="#l8484">8484</a><td>    var match = classTest(cls).exec(current);<tr><td><a id="l8485"></a><a href="#l8485">8485</a><td>    if (match) {<tr><td><a id="l8486"></a><a href="#l8486">8486</a><td>      var after = current.slice(match.index + match[0].length);<tr><td><a id="l8487"></a><a href="#l8487">8487</a><td>      node.className = current.slice(0, match.index) + (after ? match[1] + after : &quot;&quot;);<tr><td><a id="l8488"></a><a href="#l8488">8488</a><td>    }<tr><td><a id="l8489"></a><a href="#l8489">8489</a><td>  };<tr><td><a id="l8490"></a><a href="#l8490">8490</a><td>  var addClass = CodeMirror.addClass = function(node, cls) {<tr><td><a id="l8491"></a><a href="#l8491">8491</a><td>    var current = node.className;<tr><td><a id="l8492"></a><a href="#l8492">8492</a><td>    if (!classTest(cls).test(current)) node.className += (current ? &quot; &quot; : &quot;&quot;) + cls;<tr><td><a id="l8493"></a><a href="#l8493">8493</a><td>  };<tr><td><a id="l8494"></a><a href="#l8494">8494</a><td>  function joinClasses(a, b) {<tr><td><a id="l8495"></a><a href="#l8495">8495</a><td>    var as = a.split(&quot; &quot;);<tr><td><a id="l8496"></a><a href="#l8496">8496</a><td>    for (var i = 0; i &lt; as.length; i++)<tr><td><a id="l8497"></a><a href="#l8497">8497</a><td>      if (as[i] &amp;&amp; !classTest(as[i]).test(b)) b += &quot; &quot; + as[i];<tr><td><a id="l8498"></a><a href="#l8498">8498</a><td>    return b;<tr><td><a id="l8499"></a><a href="#l8499">8499</a><td>  }<tr><td><a id="l8500"></a><a href="#l8500">8500</a><td><tr><td><a id="l8501"></a><a href="#l8501">8501</a><td>  // WINDOW-WIDE EVENTS<tr><td><a id="l8502"></a><a href="#l8502">8502</a><td><tr><td><a id="l8503"></a><a href="#l8503">8503</a><td>  // These must be handled carefully, because naively registering a<tr><td><a id="l8504"></a><a href="#l8504">8504</a><td>  // handler for each editor will cause the editors to never be<tr><td><a id="l8505"></a><a href="#l8505">8505</a><td>  // garbage collected.<tr><td><a id="l8506"></a><a href="#l8506">8506</a><td><tr><td><a id="l8507"></a><a href="#l8507">8507</a><td>  function forEachCodeMirror(f) {<tr><td><a id="l8508"></a><a href="#l8508">8508</a><td>    if (!document.body.getElementsByClassName) return;<tr><td><a id="l8509"></a><a href="#l8509">8509</a><td>    var byClass = document.body.getElementsByClassName(&quot;CodeMirror&quot;);<tr><td><a id="l8510"></a><a href="#l8510">8510</a><td>    for (var i = 0; i &lt; byClass.length; i++) {<tr><td><a id="l8511"></a><a href="#l8511">8511</a><td>      var cm = byClass[i].CodeMirror;<tr><td><a id="l8512"></a><a href="#l8512">8512</a><td>      if (cm) f(cm);<tr><td><a id="l8513"></a><a href="#l8513">8513</a><td>    }<tr><td><a id="l8514"></a><a href="#l8514">8514</a><td>  }<tr><td><a id="l8515"></a><a href="#l8515">8515</a><td><tr><td><a id="l8516"></a><a href="#l8516">8516</a><td>  var globalsRegistered = false;<tr><td><a id="l8517"></a><a href="#l8517">8517</a><td>  function ensureGlobalHandlers() {<tr><td><a id="l8518"></a><a href="#l8518">8518</a><td>    if (globalsRegistered) return;<tr><td><a id="l8519"></a><a href="#l8519">8519</a><td>    registerGlobalHandlers();<tr><td><a id="l8520"></a><a href="#l8520">8520</a><td>    globalsRegistered = true;<tr><td><a id="l8521"></a><a href="#l8521">8521</a><td>  }<tr><td><a id="l8522"></a><a href="#l8522">8522</a><td>  function registerGlobalHandlers() {<tr><td><a id="l8523"></a><a href="#l8523">8523</a><td>    // When the window resizes, we need to refresh active editors.<tr><td><a id="l8524"></a><a href="#l8524">8524</a><td>    var resizeTimer;<tr><td><a id="l8525"></a><a href="#l8525">8525</a><td>    on(window, &quot;resize&quot;, function() {<tr><td><a id="l8526"></a><a href="#l8526">8526</a><td>      if (resizeTimer == null) resizeTimer = setTimeout(function() {<tr><td><a id="l8527"></a><a href="#l8527">8527</a><td>        resizeTimer = null;<tr><td><a id="l8528"></a><a href="#l8528">8528</a><td>        forEachCodeMirror(onResize);<tr><td><a id="l8529"></a><a href="#l8529">8529</a><td>      }, 100);<tr><td><a id="l8530"></a><a href="#l8530">8530</a><td>    });<tr><td><a id="l8531"></a><a href="#l8531">8531</a><td>    // When the window loses focus, we want to show the editor as blurred<tr><td><a id="l8532"></a><a href="#l8532">8532</a><td>    on(window, &quot;blur&quot;, function() {<tr><td><a id="l8533"></a><a href="#l8533">8533</a><td>      forEachCodeMirror(onBlur);<tr><td><a id="l8534"></a><a href="#l8534">8534</a><td>    });<tr><td><a id="l8535"></a><a href="#l8535">8535</a><td>  }<tr><td><a id="l8536"></a><a href="#l8536">8536</a><td><tr><td><a id="l8537"></a><a href="#l8537">8537</a><td>  // FEATURE DETECTION<tr><td><a id="l8538"></a><a href="#l8538">8538</a><td><tr><td><a id="l8539"></a><a href="#l8539">8539</a><td>  // Detect drag-and-drop<tr><td><a id="l8540"></a><a href="#l8540">8540</a><td>  var dragAndDrop = function() {<tr><td><a id="l8541"></a><a href="#l8541">8541</a><td>    // There is *some* kind of drag-and-drop support in IE6-8, but I<tr><td><a id="l8542"></a><a href="#l8542">8542</a><td>    // couldn&#39;t get it to work yet.<tr><td><a id="l8543"></a><a href="#l8543">8543</a><td>    if (ie &amp;&amp; ie_version &lt; 9) return false;<tr><td><a id="l8544"></a><a href="#l8544">8544</a><td>    var div = elt(&#39;div&#39;);<tr><td><a id="l8545"></a><a href="#l8545">8545</a><td>    return &quot;draggable&quot; in div || &quot;dragDrop&quot; in div;<tr><td><a id="l8546"></a><a href="#l8546">8546</a><td>  }();<tr><td><a id="l8547"></a><a href="#l8547">8547</a><td><tr><td><a id="l8548"></a><a href="#l8548">8548</a><td>  var zwspSupported;<tr><td><a id="l8549"></a><a href="#l8549">8549</a><td>  function zeroWidthElement(measure) {<tr><td><a id="l8550"></a><a href="#l8550">8550</a><td>    if (zwspSupported == null) {<tr><td><a id="l8551"></a><a href="#l8551">8551</a><td>      var test = elt(&quot;span&quot;, &quot;\u200b&quot;);<tr><td><a id="l8552"></a><a href="#l8552">8552</a><td>      removeChildrenAndAdd(measure, elt(&quot;span&quot;, [test, document.createTextNode(&quot;x&quot;)]));<tr><td><a id="l8553"></a><a href="#l8553">8553</a><td>      if (measure.firstChild.offsetHeight != 0)<tr><td><a id="l8554"></a><a href="#l8554">8554</a><td>        zwspSupported = test.offsetWidth &lt;= 1 &amp;&amp; test.offsetHeight &gt; 2 &amp;&amp; !(ie &amp;&amp; ie_version &lt; 8);<tr><td><a id="l8555"></a><a href="#l8555">8555</a><td>    }<tr><td><a id="l8556"></a><a href="#l8556">8556</a><td>    var node = zwspSupported ? elt(&quot;span&quot;, &quot;\u200b&quot;) :<tr><td><a id="l8557"></a><a href="#l8557">8557</a><td>      elt(&quot;span&quot;, &quot;\u00a0&quot;, null, &quot;display: inline-block; width: 1px; margin-right: -1px&quot;);<tr><td><a id="l8558"></a><a href="#l8558">8558</a><td>    node.setAttribute(&quot;cm-text&quot;, &quot;&quot;);<tr><td><a id="l8559"></a><a href="#l8559">8559</a><td>    return node;<tr><td><a id="l8560"></a><a href="#l8560">8560</a><td>  }<tr><td><a id="l8561"></a><a href="#l8561">8561</a><td><tr><td><a id="l8562"></a><a href="#l8562">8562</a><td>  // Feature-detect IE&#39;s crummy client rect reporting for bidi text<tr><td><a id="l8563"></a><a href="#l8563">8563</a><td>  var badBidiRects;<tr><td><a id="l8564"></a><a href="#l8564">8564</a><td>  function hasBadBidiRects(measure) {<tr><td><a id="l8565"></a><a href="#l8565">8565</a><td>    if (badBidiRects != null) return badBidiRects;<tr><td><a id="l8566"></a><a href="#l8566">8566</a><td>    var txt = removeChildrenAndAdd(measure, document.createTextNode(&quot;A\u062eA&quot;));<tr><td><a id="l8567"></a><a href="#l8567">8567</a><td>    var r0 = range(txt, 0, 1).getBoundingClientRect();<tr><td><a id="l8568"></a><a href="#l8568">8568</a><td>    var r1 = range(txt, 1, 2).getBoundingClientRect();<tr><td><a id="l8569"></a><a href="#l8569">8569</a><td>    removeChildren(measure);<tr><td><a id="l8570"></a><a href="#l8570">8570</a><td>    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)<tr><td><a id="l8571"></a><a href="#l8571">8571</a><td>    return badBidiRects = (r1.right - r0.right &lt; 3);<tr><td><a id="l8572"></a><a href="#l8572">8572</a><td>  }<tr><td><a id="l8573"></a><a href="#l8573">8573</a><td><tr><td><a id="l8574"></a><a href="#l8574">8574</a><td>  // See if &quot;&quot;.split is the broken IE version, if so, provide an<tr><td><a id="l8575"></a><a href="#l8575">8575</a><td>  // alternative way to split lines.<tr><td><a id="l8576"></a><a href="#l8576">8576</a><td>  var splitLinesAuto = CodeMirror.splitLines = &quot;\n\nb&quot;.split(/\n/).length != 3 ? function(string) {<tr><td><a id="l8577"></a><a href="#l8577">8577</a><td>    var pos = 0, result = [], l = string.length;<tr><td><a id="l8578"></a><a href="#l8578">8578</a><td>    while (pos &lt;= l) {<tr><td><a id="l8579"></a><a href="#l8579">8579</a><td>      var nl = string.indexOf(&quot;\n&quot;, pos);<tr><td><a id="l8580"></a><a href="#l8580">8580</a><td>      if (nl == -1) nl = string.length;<tr><td><a id="l8581"></a><a href="#l8581">8581</a><td>      var line = string.slice(pos, string.charAt(nl - 1) == &quot;\r&quot; ? nl - 1 : nl);<tr><td><a id="l8582"></a><a href="#l8582">8582</a><td>      var rt = line.indexOf(&quot;\r&quot;);<tr><td><a id="l8583"></a><a href="#l8583">8583</a><td>      if (rt != -1) {<tr><td><a id="l8584"></a><a href="#l8584">8584</a><td>        result.push(line.slice(0, rt));<tr><td><a id="l8585"></a><a href="#l8585">8585</a><td>        pos += rt + 1;<tr><td><a id="l8586"></a><a href="#l8586">8586</a><td>      } else {<tr><td><a id="l8587"></a><a href="#l8587">8587</a><td>        result.push(line);<tr><td><a id="l8588"></a><a href="#l8588">8588</a><td>        pos = nl + 1;<tr><td><a id="l8589"></a><a href="#l8589">8589</a><td>      }<tr><td><a id="l8590"></a><a href="#l8590">8590</a><td>    }<tr><td><a id="l8591"></a><a href="#l8591">8591</a><td>    return result;<tr><td><a id="l8592"></a><a href="#l8592">8592</a><td>  } : function(string){return string.split(/\r\n?|\n/);};<tr><td><a id="l8593"></a><a href="#l8593">8593</a><td><tr><td><a id="l8594"></a><a href="#l8594">8594</a><td>  var hasSelection = window.getSelection ? function(te) {<tr><td><a id="l8595"></a><a href="#l8595">8595</a><td>    try { return te.selectionStart != te.selectionEnd; }<tr><td><a id="l8596"></a><a href="#l8596">8596</a><td>    catch(e) { return false; }<tr><td><a id="l8597"></a><a href="#l8597">8597</a><td>  } : function(te) {<tr><td><a id="l8598"></a><a href="#l8598">8598</a><td>    try {var range = te.ownerDocument.selection.createRange();}<tr><td><a id="l8599"></a><a href="#l8599">8599</a><td>    catch(e) {}<tr><td><a id="l8600"></a><a href="#l8600">8600</a><td>    if (!range || range.parentElement() != te) return false;<tr><td><a id="l8601"></a><a href="#l8601">8601</a><td>    return range.compareEndPoints(&quot;StartToEnd&quot;, range) != 0;<tr><td><a id="l8602"></a><a href="#l8602">8602</a><td>  };<tr><td><a id="l8603"></a><a href="#l8603">8603</a><td><tr><td><a id="l8604"></a><a href="#l8604">8604</a><td>  var hasCopyEvent = (function() {<tr><td><a id="l8605"></a><a href="#l8605">8605</a><td>    var e = elt(&quot;div&quot;);<tr><td><a id="l8606"></a><a href="#l8606">8606</a><td>    if (&quot;oncopy&quot; in e) return true;<tr><td><a id="l8607"></a><a href="#l8607">8607</a><td>    e.setAttribute(&quot;oncopy&quot;, &quot;return;&quot;);<tr><td><a id="l8608"></a><a href="#l8608">8608</a><td>    return typeof e.oncopy == &quot;function&quot;;<tr><td><a id="l8609"></a><a href="#l8609">8609</a><td>  })();<tr><td><a id="l8610"></a><a href="#l8610">8610</a><td><tr><td><a id="l8611"></a><a href="#l8611">8611</a><td>  var badZoomedRects = null;<tr><td><a id="l8612"></a><a href="#l8612">8612</a><td>  function hasBadZoomedRects(measure) {<tr><td><a id="l8613"></a><a href="#l8613">8613</a><td>    if (badZoomedRects != null) return badZoomedRects;<tr><td><a id="l8614"></a><a href="#l8614">8614</a><td>    var node = removeChildrenAndAdd(measure, elt(&quot;span&quot;, &quot;x&quot;));<tr><td><a id="l8615"></a><a href="#l8615">8615</a><td>    var normal = node.getBoundingClientRect();<tr><td><a id="l8616"></a><a href="#l8616">8616</a><td>    var fromRange = range(node, 0, 1).getBoundingClientRect();<tr><td><a id="l8617"></a><a href="#l8617">8617</a><td>    return badZoomedRects = Math.abs(normal.left - fromRange.left) &gt; 1;<tr><td><a id="l8618"></a><a href="#l8618">8618</a><td>  }<tr><td><a id="l8619"></a><a href="#l8619">8619</a><td><tr><td><a id="l8620"></a><a href="#l8620">8620</a><td>  // KEY NAMES<tr><td><a id="l8621"></a><a href="#l8621">8621</a><td><tr><td><a id="l8622"></a><a href="#l8622">8622</a><td>  var keyNames = CodeMirror.keyNames = {<tr><td><a id="l8623"></a><a href="#l8623">8623</a><td>    3: &quot;Enter&quot;, 8: &quot;Backspace&quot;, 9: &quot;Tab&quot;, 13: &quot;Enter&quot;, 16: &quot;Shift&quot;, 17: &quot;Ctrl&quot;, 18: &quot;Alt&quot;,<tr><td><a id="l8624"></a><a href="#l8624">8624</a><td>    19: &quot;Pause&quot;, 20: &quot;CapsLock&quot;, 27: &quot;Esc&quot;, 32: &quot;Space&quot;, 33: &quot;PageUp&quot;, 34: &quot;PageDown&quot;, 35: &quot;End&quot;,<tr><td><a id="l8625"></a><a href="#l8625">8625</a><td>    36: &quot;Home&quot;, 37: &quot;Left&quot;, 38: &quot;Up&quot;, 39: &quot;Right&quot;, 40: &quot;Down&quot;, 44: &quot;PrintScrn&quot;, 45: &quot;Insert&quot;,<tr><td><a id="l8626"></a><a href="#l8626">8626</a><td>    46: &quot;Delete&quot;, 59: &quot;;&quot;, 61: &quot;=&quot;, 91: &quot;Mod&quot;, 92: &quot;Mod&quot;, 93: &quot;Mod&quot;,<tr><td><a id="l8627"></a><a href="#l8627">8627</a><td>    106: &quot;*&quot;, 107: &quot;=&quot;, 109: &quot;-&quot;, 110: &quot;.&quot;, 111: &quot;/&quot;, 127: &quot;Delete&quot;,<tr><td><a id="l8628"></a><a href="#l8628">8628</a><td>    173: &quot;-&quot;, 186: &quot;;&quot;, 187: &quot;=&quot;, 188: &quot;,&quot;, 189: &quot;-&quot;, 190: &quot;.&quot;, 191: &quot;/&quot;, 192: &quot;`&quot;, 219: &quot;[&quot;, 220: &quot;\\&quot;,<tr><td><a id="l8629"></a><a href="#l8629">8629</a><td>    221: &quot;]&quot;, 222: &quot;&#39;&quot;, 63232: &quot;Up&quot;, 63233: &quot;Down&quot;, 63234: &quot;Left&quot;, 63235: &quot;Right&quot;, 63272: &quot;Delete&quot;,<tr><td><a id="l8630"></a><a href="#l8630">8630</a><td>    63273: &quot;Home&quot;, 63275: &quot;End&quot;, 63276: &quot;PageUp&quot;, 63277: &quot;PageDown&quot;, 63302: &quot;Insert&quot;<tr><td><a id="l8631"></a><a href="#l8631">8631</a><td>  };<tr><td><a id="l8632"></a><a href="#l8632">8632</a><td>  (function() {<tr><td><a id="l8633"></a><a href="#l8633">8633</a><td>    // Number keys<tr><td><a id="l8634"></a><a href="#l8634">8634</a><td>    for (var i = 0; i &lt; 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);<tr><td><a id="l8635"></a><a href="#l8635">8635</a><td>    // Alphabetic keys<tr><td><a id="l8636"></a><a href="#l8636">8636</a><td>    for (var i = 65; i &lt;= 90; i++) keyNames[i] = String.fromCharCode(i);<tr><td><a id="l8637"></a><a href="#l8637">8637</a><td>    // Function keys<tr><td><a id="l8638"></a><a href="#l8638">8638</a><td>    for (var i = 1; i &lt;= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = &quot;F&quot; + i;<tr><td><a id="l8639"></a><a href="#l8639">8639</a><td>  })();<tr><td><a id="l8640"></a><a href="#l8640">8640</a><td><tr><td><a id="l8641"></a><a href="#l8641">8641</a><td>  // BIDI HELPERS<tr><td><a id="l8642"></a><a href="#l8642">8642</a><td><tr><td><a id="l8643"></a><a href="#l8643">8643</a><td>  function iterateBidiSections(order, from, to, f) {<tr><td><a id="l8644"></a><a href="#l8644">8644</a><td>    if (!order) return f(from, to, &quot;ltr&quot;);<tr><td><a id="l8645"></a><a href="#l8645">8645</a><td>    var found = false;<tr><td><a id="l8646"></a><a href="#l8646">8646</a><td>    for (var i = 0; i &lt; order.length; ++i) {<tr><td><a id="l8647"></a><a href="#l8647">8647</a><td>      var part = order[i];<tr><td><a id="l8648"></a><a href="#l8648">8648</a><td>      if (part.from &lt; to &amp;&amp; part.to &gt; from || from == to &amp;&amp; part.to == from) {<tr><td><a id="l8649"></a><a href="#l8649">8649</a><td>        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? &quot;rtl&quot; : &quot;ltr&quot;);<tr><td><a id="l8650"></a><a href="#l8650">8650</a><td>        found = true;<tr><td><a id="l8651"></a><a href="#l8651">8651</a><td>      }<tr><td><a id="l8652"></a><a href="#l8652">8652</a><td>    }<tr><td><a id="l8653"></a><a href="#l8653">8653</a><td>    if (!found) f(from, to, &quot;ltr&quot;);<tr><td><a id="l8654"></a><a href="#l8654">8654</a><td>  }<tr><td><a id="l8655"></a><a href="#l8655">8655</a><td><tr><td><a id="l8656"></a><a href="#l8656">8656</a><td>  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }<tr><td><a id="l8657"></a><a href="#l8657">8657</a><td>  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }<tr><td><a id="l8658"></a><a href="#l8658">8658</a><td><tr><td><a id="l8659"></a><a href="#l8659">8659</a><td>  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }<tr><td><a id="l8660"></a><a href="#l8660">8660</a><td>  function lineRight(line) {<tr><td><a id="l8661"></a><a href="#l8661">8661</a><td>    var order = getOrder(line);<tr><td><a id="l8662"></a><a href="#l8662">8662</a><td>    if (!order) return line.text.length;<tr><td><a id="l8663"></a><a href="#l8663">8663</a><td>    return bidiRight(lst(order));<tr><td><a id="l8664"></a><a href="#l8664">8664</a><td>  }<tr><td><a id="l8665"></a><a href="#l8665">8665</a><td><tr><td><a id="l8666"></a><a href="#l8666">8666</a><td>  function lineStart(cm, lineN) {<tr><td><a id="l8667"></a><a href="#l8667">8667</a><td>    var line = getLine(cm.doc, lineN);<tr><td><a id="l8668"></a><a href="#l8668">8668</a><td>    var visual = visualLine(line);<tr><td><a id="l8669"></a><a href="#l8669">8669</a><td>    if (visual != line) lineN = lineNo(visual);<tr><td><a id="l8670"></a><a href="#l8670">8670</a><td>    var order = getOrder(visual);<tr><td><a id="l8671"></a><a href="#l8671">8671</a><td>    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);<tr><td><a id="l8672"></a><a href="#l8672">8672</a><td>    return Pos(lineN, ch);<tr><td><a id="l8673"></a><a href="#l8673">8673</a><td>  }<tr><td><a id="l8674"></a><a href="#l8674">8674</a><td>  function lineEnd(cm, lineN) {<tr><td><a id="l8675"></a><a href="#l8675">8675</a><td>    var merged, line = getLine(cm.doc, lineN);<tr><td><a id="l8676"></a><a href="#l8676">8676</a><td>    while (merged = collapsedSpanAtEnd(line)) {<tr><td><a id="l8677"></a><a href="#l8677">8677</a><td>      line = merged.find(1, true).line;<tr><td><a id="l8678"></a><a href="#l8678">8678</a><td>      lineN = null;<tr><td><a id="l8679"></a><a href="#l8679">8679</a><td>    }<tr><td><a id="l8680"></a><a href="#l8680">8680</a><td>    var order = getOrder(line);<tr><td><a id="l8681"></a><a href="#l8681">8681</a><td>    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);<tr><td><a id="l8682"></a><a href="#l8682">8682</a><td>    return Pos(lineN == null ? lineNo(line) : lineN, ch);<tr><td><a id="l8683"></a><a href="#l8683">8683</a><td>  }<tr><td><a id="l8684"></a><a href="#l8684">8684</a><td>  function lineStartSmart(cm, pos) {<tr><td><a id="l8685"></a><a href="#l8685">8685</a><td>    var start = lineStart(cm, pos.line);<tr><td><a id="l8686"></a><a href="#l8686">8686</a><td>    var line = getLine(cm.doc, start.line);<tr><td><a id="l8687"></a><a href="#l8687">8687</a><td>    var order = getOrder(line);<tr><td><a id="l8688"></a><a href="#l8688">8688</a><td>    if (!order || order[0].level == 0) {<tr><td><a id="l8689"></a><a href="#l8689">8689</a><td>      var firstNonWS = Math.max(0, line.text.search(/\S/));<tr><td><a id="l8690"></a><a href="#l8690">8690</a><td>      var inWS = pos.line == start.line &amp;&amp; pos.ch &lt;= firstNonWS &amp;&amp; pos.ch;<tr><td><a id="l8691"></a><a href="#l8691">8691</a><td>      return Pos(start.line, inWS ? 0 : firstNonWS);<tr><td><a id="l8692"></a><a href="#l8692">8692</a><td>    }<tr><td><a id="l8693"></a><a href="#l8693">8693</a><td>    return start;<tr><td><a id="l8694"></a><a href="#l8694">8694</a><td>  }<tr><td><a id="l8695"></a><a href="#l8695">8695</a><td><tr><td><a id="l8696"></a><a href="#l8696">8696</a><td>  function compareBidiLevel(order, a, b) {<tr><td><a id="l8697"></a><a href="#l8697">8697</a><td>    var linedir = order[0].level;<tr><td><a id="l8698"></a><a href="#l8698">8698</a><td>    if (a == linedir) return true;<tr><td><a id="l8699"></a><a href="#l8699">8699</a><td>    if (b == linedir) return false;<tr><td><a id="l8700"></a><a href="#l8700">8700</a><td>    return a &lt; b;<tr><td><a id="l8701"></a><a href="#l8701">8701</a><td>  }<tr><td><a id="l8702"></a><a href="#l8702">8702</a><td>  var bidiOther;<tr><td><a id="l8703"></a><a href="#l8703">8703</a><td>  function getBidiPartAt(order, pos) {<tr><td><a id="l8704"></a><a href="#l8704">8704</a><td>    bidiOther = null;<tr><td><a id="l8705"></a><a href="#l8705">8705</a><td>    for (var i = 0, found; i &lt; order.length; ++i) {<tr><td><a id="l8706"></a><a href="#l8706">8706</a><td>      var cur = order[i];<tr><td><a id="l8707"></a><a href="#l8707">8707</a><td>      if (cur.from &lt; pos &amp;&amp; cur.to &gt; pos) return i;<tr><td><a id="l8708"></a><a href="#l8708">8708</a><td>      if ((cur.from == pos || cur.to == pos)) {<tr><td><a id="l8709"></a><a href="#l8709">8709</a><td>        if (found == null) {<tr><td><a id="l8710"></a><a href="#l8710">8710</a><td>          found = i;<tr><td><a id="l8711"></a><a href="#l8711">8711</a><td>        } else if (compareBidiLevel(order, cur.level, order[found].level)) {<tr><td><a id="l8712"></a><a href="#l8712">8712</a><td>          if (cur.from != cur.to) bidiOther = found;<tr><td><a id="l8713"></a><a href="#l8713">8713</a><td>          return i;<tr><td><a id="l8714"></a><a href="#l8714">8714</a><td>        } else {<tr><td><a id="l8715"></a><a href="#l8715">8715</a><td>          if (cur.from != cur.to) bidiOther = i;<tr><td><a id="l8716"></a><a href="#l8716">8716</a><td>          return found;<tr><td><a id="l8717"></a><a href="#l8717">8717</a><td>        }<tr><td><a id="l8718"></a><a href="#l8718">8718</a><td>      }<tr><td><a id="l8719"></a><a href="#l8719">8719</a><td>    }<tr><td><a id="l8720"></a><a href="#l8720">8720</a><td>    return found;<tr><td><a id="l8721"></a><a href="#l8721">8721</a><td>  }<tr><td><a id="l8722"></a><a href="#l8722">8722</a><td><tr><td><a id="l8723"></a><a href="#l8723">8723</a><td>  function moveInLine(line, pos, dir, byUnit) {<tr><td><a id="l8724"></a><a href="#l8724">8724</a><td>    if (!byUnit) return pos + dir;<tr><td><a id="l8725"></a><a href="#l8725">8725</a><td>    do pos += dir;<tr><td><a id="l8726"></a><a href="#l8726">8726</a><td>    while (pos &gt; 0 &amp;&amp; isExtendingChar(line.text.charAt(pos)));<tr><td><a id="l8727"></a><a href="#l8727">8727</a><td>    return pos;<tr><td><a id="l8728"></a><a href="#l8728">8728</a><td>  }<tr><td><a id="l8729"></a><a href="#l8729">8729</a><td><tr><td><a id="l8730"></a><a href="#l8730">8730</a><td>  // This is needed in order to move &#39;visually&#39; through bi-directional<tr><td><a id="l8731"></a><a href="#l8731">8731</a><td>  // text -- i.e., pressing left should make the cursor go left, even<tr><td><a id="l8732"></a><a href="#l8732">8732</a><td>  // when in RTL text. The tricky part is the &#39;jumps&#39;, where RTL and<tr><td><a id="l8733"></a><a href="#l8733">8733</a><td>  // LTR text touch each other. This often requires the cursor offset<tr><td><a id="l8734"></a><a href="#l8734">8734</a><td>  // to move more than one unit, in order to visually move one unit.<tr><td><a id="l8735"></a><a href="#l8735">8735</a><td>  function moveVisually(line, start, dir, byUnit) {<tr><td><a id="l8736"></a><a href="#l8736">8736</a><td>    var bidi = getOrder(line);<tr><td><a id="l8737"></a><a href="#l8737">8737</a><td>    if (!bidi) return moveLogically(line, start, dir, byUnit);<tr><td><a id="l8738"></a><a href="#l8738">8738</a><td>    var pos = getBidiPartAt(bidi, start), part = bidi[pos];<tr><td><a id="l8739"></a><a href="#l8739">8739</a><td>    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);<tr><td><a id="l8740"></a><a href="#l8740">8740</a><td><tr><td><a id="l8741"></a><a href="#l8741">8741</a><td>    for (;;) {<tr><td><a id="l8742"></a><a href="#l8742">8742</a><td>      if (target &gt; part.from &amp;&amp; target &lt; part.to) return target;<tr><td><a id="l8743"></a><a href="#l8743">8743</a><td>      if (target == part.from || target == part.to) {<tr><td><a id="l8744"></a><a href="#l8744">8744</a><td>        if (getBidiPartAt(bidi, target) == pos) return target;<tr><td><a id="l8745"></a><a href="#l8745">8745</a><td>        part = bidi[pos += dir];<tr><td><a id="l8746"></a><a href="#l8746">8746</a><td>        return (dir &gt; 0) == part.level % 2 ? part.to : part.from;<tr><td><a id="l8747"></a><a href="#l8747">8747</a><td>      } else {<tr><td><a id="l8748"></a><a href="#l8748">8748</a><td>        part = bidi[pos += dir];<tr><td><a id="l8749"></a><a href="#l8749">8749</a><td>        if (!part) return null;<tr><td><a id="l8750"></a><a href="#l8750">8750</a><td>        if ((dir &gt; 0) == part.level % 2)<tr><td><a id="l8751"></a><a href="#l8751">8751</a><td>          target = moveInLine(line, part.to, -1, byUnit);<tr><td><a id="l8752"></a><a href="#l8752">8752</a><td>        else<tr><td><a id="l8753"></a><a href="#l8753">8753</a><td>          target = moveInLine(line, part.from, 1, byUnit);<tr><td><a id="l8754"></a><a href="#l8754">8754</a><td>      }<tr><td><a id="l8755"></a><a href="#l8755">8755</a><td>    }<tr><td><a id="l8756"></a><a href="#l8756">8756</a><td>  }<tr><td><a id="l8757"></a><a href="#l8757">8757</a><td><tr><td><a id="l8758"></a><a href="#l8758">8758</a><td>  function moveLogically(line, start, dir, byUnit) {<tr><td><a id="l8759"></a><a href="#l8759">8759</a><td>    var target = start + dir;<tr><td><a id="l8760"></a><a href="#l8760">8760</a><td>    if (byUnit) while (target &gt; 0 &amp;&amp; isExtendingChar(line.text.charAt(target))) target += dir;<tr><td><a id="l8761"></a><a href="#l8761">8761</a><td>    return target &lt; 0 || target &gt; line.text.length ? null : target;<tr><td><a id="l8762"></a><a href="#l8762">8762</a><td>  }<tr><td><a id="l8763"></a><a href="#l8763">8763</a><td><tr><td><a id="l8764"></a><a href="#l8764">8764</a><td>  // Bidirectional ordering algorithm<tr><td><a id="l8765"></a><a href="#l8765">8765</a><td>  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm<tr><td><a id="l8766"></a><a href="#l8766">8766</a><td>  // that this (partially) implements.<tr><td><a id="l8767"></a><a href="#l8767">8767</a><td><tr><td><a id="l8768"></a><a href="#l8768">8768</a><td>  // One-char codes used for character types:<tr><td><a id="l8769"></a><a href="#l8769">8769</a><td>  // L (L):   Left-to-Right<tr><td><a id="l8770"></a><a href="#l8770">8770</a><td>  // R (R):   Right-to-Left<tr><td><a id="l8771"></a><a href="#l8771">8771</a><td>  // r (AL):  Right-to-Left Arabic<tr><td><a id="l8772"></a><a href="#l8772">8772</a><td>  // 1 (EN):  European Number<tr><td><a id="l8773"></a><a href="#l8773">8773</a><td>  // + (ES):  European Number Separator<tr><td><a id="l8774"></a><a href="#l8774">8774</a><td>  // % (ET):  European Number Terminator<tr><td><a id="l8775"></a><a href="#l8775">8775</a><td>  // n (AN):  Arabic Number<tr><td><a id="l8776"></a><a href="#l8776">8776</a><td>  // , (CS):  Common Number Separator<tr><td><a id="l8777"></a><a href="#l8777">8777</a><td>  // m (NSM): Non-Spacing Mark<tr><td><a id="l8778"></a><a href="#l8778">8778</a><td>  // b (BN):  Boundary Neutral<tr><td><a id="l8779"></a><a href="#l8779">8779</a><td>  // s (B):   Paragraph Separator<tr><td><a id="l8780"></a><a href="#l8780">8780</a><td>  // t (S):   Segment Separator<tr><td><a id="l8781"></a><a href="#l8781">8781</a><td>  // w (WS):  Whitespace<tr><td><a id="l8782"></a><a href="#l8782">8782</a><td>  // N (ON):  Other Neutrals<tr><td><a id="l8783"></a><a href="#l8783">8783</a><td><tr><td><a id="l8784"></a><a href="#l8784">8784</a><td>  // Returns null if characters are ordered as they appear<tr><td><a id="l8785"></a><a href="#l8785">8785</a><td>  // (left-to-right), or an array of sections ({from, to, level}<tr><td><a id="l8786"></a><a href="#l8786">8786</a><td>  // objects) in the order in which they occur visually.<tr><td><a id="l8787"></a><a href="#l8787">8787</a><td>  var bidiOrdering = (function() {<tr><td><a id="l8788"></a><a href="#l8788">8788</a><td>    // Character types for codepoints 0 to 0xff<tr><td><a id="l8789"></a><a href="#l8789">8789</a><td>    var lowTypes = &quot;bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN&quot;;<tr><td><a id="l8790"></a><a href="#l8790">8790</a><td>    // Character types for codepoints 0x600 to 0x6ff<tr><td><a id="l8791"></a><a href="#l8791">8791</a><td>    var arabicTypes = &quot;rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm&quot;;<tr><td><a id="l8792"></a><a href="#l8792">8792</a><td>    function charType(code) {<tr><td><a id="l8793"></a><a href="#l8793">8793</a><td>      if (code &lt;= 0xf7) return lowTypes.charAt(code);<tr><td><a id="l8794"></a><a href="#l8794">8794</a><td>      else if (0x590 &lt;= code &amp;&amp; code &lt;= 0x5f4) return &quot;R&quot;;<tr><td><a id="l8795"></a><a href="#l8795">8795</a><td>      else if (0x600 &lt;= code &amp;&amp; code &lt;= 0x6ed) return arabicTypes.charAt(code - 0x600);<tr><td><a id="l8796"></a><a href="#l8796">8796</a><td>      else if (0x6ee &lt;= code &amp;&amp; code &lt;= 0x8ac) return &quot;r&quot;;<tr><td><a id="l8797"></a><a href="#l8797">8797</a><td>      else if (0x2000 &lt;= code &amp;&amp; code &lt;= 0x200b) return &quot;w&quot;;<tr><td><a id="l8798"></a><a href="#l8798">8798</a><td>      else if (code == 0x200c) return &quot;b&quot;;<tr><td><a id="l8799"></a><a href="#l8799">8799</a><td>      else return &quot;L&quot;;<tr><td><a id="l8800"></a><a href="#l8800">8800</a><td>    }<tr><td><a id="l8801"></a><a href="#l8801">8801</a><td><tr><td><a id="l8802"></a><a href="#l8802">8802</a><td>    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;<tr><td><a id="l8803"></a><a href="#l8803">8803</a><td>    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;<tr><td><a id="l8804"></a><a href="#l8804">8804</a><td>    // Browsers seem to always treat the boundaries of block elements as being L.<tr><td><a id="l8805"></a><a href="#l8805">8805</a><td>    var outerType = &quot;L&quot;;<tr><td><a id="l8806"></a><a href="#l8806">8806</a><td><tr><td><a id="l8807"></a><a href="#l8807">8807</a><td>    function BidiSpan(level, from, to) {<tr><td><a id="l8808"></a><a href="#l8808">8808</a><td>      this.level = level;<tr><td><a id="l8809"></a><a href="#l8809">8809</a><td>      this.from = from; this.to = to;<tr><td><a id="l8810"></a><a href="#l8810">8810</a><td>    }<tr><td><a id="l8811"></a><a href="#l8811">8811</a><td><tr><td><a id="l8812"></a><a href="#l8812">8812</a><td>    return function(str) {<tr><td><a id="l8813"></a><a href="#l8813">8813</a><td>      if (!bidiRE.test(str)) return false;<tr><td><a id="l8814"></a><a href="#l8814">8814</a><td>      var len = str.length, types = [];<tr><td><a id="l8815"></a><a href="#l8815">8815</a><td>      for (var i = 0, type; i &lt; len; ++i)<tr><td><a id="l8816"></a><a href="#l8816">8816</a><td>        types.push(type = charType(str.charCodeAt(i)));<tr><td><a id="l8817"></a><a href="#l8817">8817</a><td><tr><td><a id="l8818"></a><a href="#l8818">8818</a><td>      // W1. Examine each non-spacing mark (NSM) in the level run, and<tr><td><a id="l8819"></a><a href="#l8819">8819</a><td>      // change the type of the NSM to the type of the previous<tr><td><a id="l8820"></a><a href="#l8820">8820</a><td>      // character. If the NSM is at the start of the level run, it will<tr><td><a id="l8821"></a><a href="#l8821">8821</a><td>      // get the type of sor.<tr><td><a id="l8822"></a><a href="#l8822">8822</a><td>      for (var i = 0, prev = outerType; i &lt; len; ++i) {<tr><td><a id="l8823"></a><a href="#l8823">8823</a><td>        var type = types[i];<tr><td><a id="l8824"></a><a href="#l8824">8824</a><td>        if (type == &quot;m&quot;) types[i] = prev;<tr><td><a id="l8825"></a><a href="#l8825">8825</a><td>        else prev = type;<tr><td><a id="l8826"></a><a href="#l8826">8826</a><td>      }<tr><td><a id="l8827"></a><a href="#l8827">8827</a><td><tr><td><a id="l8828"></a><a href="#l8828">8828</a><td>      // W2. Search backwards from each instance of a European number<tr><td><a id="l8829"></a><a href="#l8829">8829</a><td>      // until the first strong type (R, L, AL, or sor) is found. If an<tr><td><a id="l8830"></a><a href="#l8830">8830</a><td>      // AL is found, change the type of the European number to Arabic<tr><td><a id="l8831"></a><a href="#l8831">8831</a><td>      // number.<tr><td><a id="l8832"></a><a href="#l8832">8832</a><td>      // W3. Change all ALs to R.<tr><td><a id="l8833"></a><a href="#l8833">8833</a><td>      for (var i = 0, cur = outerType; i &lt; len; ++i) {<tr><td><a id="l8834"></a><a href="#l8834">8834</a><td>        var type = types[i];<tr><td><a id="l8835"></a><a href="#l8835">8835</a><td>        if (type == &quot;1&quot; &amp;&amp; cur == &quot;r&quot;) types[i] = &quot;n&quot;;<tr><td><a id="l8836"></a><a href="#l8836">8836</a><td>        else if (isStrong.test(type)) { cur = type; if (type == &quot;r&quot;) types[i] = &quot;R&quot;; }<tr><td><a id="l8837"></a><a href="#l8837">8837</a><td>      }<tr><td><a id="l8838"></a><a href="#l8838">8838</a><td><tr><td><a id="l8839"></a><a href="#l8839">8839</a><td>      // W4. A single European separator between two European numbers<tr><td><a id="l8840"></a><a href="#l8840">8840</a><td>      // changes to a European number. A single common separator between<tr><td><a id="l8841"></a><a href="#l8841">8841</a><td>      // two numbers of the same type changes to that type.<tr><td><a id="l8842"></a><a href="#l8842">8842</a><td>      for (var i = 1, prev = types[0]; i &lt; len - 1; ++i) {<tr><td><a id="l8843"></a><a href="#l8843">8843</a><td>        var type = types[i];<tr><td><a id="l8844"></a><a href="#l8844">8844</a><td>        if (type == &quot;+&quot; &amp;&amp; prev == &quot;1&quot; &amp;&amp; types[i+1] == &quot;1&quot;) types[i] = &quot;1&quot;;<tr><td><a id="l8845"></a><a href="#l8845">8845</a><td>        else if (type == &quot;,&quot; &amp;&amp; prev == types[i+1] &amp;&amp;<tr><td><a id="l8846"></a><a href="#l8846">8846</a><td>                 (prev == &quot;1&quot; || prev == &quot;n&quot;)) types[i] = prev;<tr><td><a id="l8847"></a><a href="#l8847">8847</a><td>        prev = type;<tr><td><a id="l8848"></a><a href="#l8848">8848</a><td>      }<tr><td><a id="l8849"></a><a href="#l8849">8849</a><td><tr><td><a id="l8850"></a><a href="#l8850">8850</a><td>      // W5. A sequence of European terminators adjacent to European<tr><td><a id="l8851"></a><a href="#l8851">8851</a><td>      // numbers changes to all European numbers.<tr><td><a id="l8852"></a><a href="#l8852">8852</a><td>      // W6. Otherwise, separators and terminators change to Other<tr><td><a id="l8853"></a><a href="#l8853">8853</a><td>      // Neutral.<tr><td><a id="l8854"></a><a href="#l8854">8854</a><td>      for (var i = 0; i &lt; len; ++i) {<tr><td><a id="l8855"></a><a href="#l8855">8855</a><td>        var type = types[i];<tr><td><a id="l8856"></a><a href="#l8856">8856</a><td>        if (type == &quot;,&quot;) types[i] = &quot;N&quot;;<tr><td><a id="l8857"></a><a href="#l8857">8857</a><td>        else if (type == &quot;%&quot;) {<tr><td><a id="l8858"></a><a href="#l8858">8858</a><td>          for (var end = i + 1; end &lt; len &amp;&amp; types[end] == &quot;%&quot;; ++end) {}<tr><td><a id="l8859"></a><a href="#l8859">8859</a><td>          var replace = (i &amp;&amp; types[i-1] == &quot;!&quot;) || (end &lt; len &amp;&amp; types[end] == &quot;1&quot;) ? &quot;1&quot; : &quot;N&quot;;<tr><td><a id="l8860"></a><a href="#l8860">8860</a><td>          for (var j = i; j &lt; end; ++j) types[j] = replace;<tr><td><a id="l8861"></a><a href="#l8861">8861</a><td>          i = end - 1;<tr><td><a id="l8862"></a><a href="#l8862">8862</a><td>        }<tr><td><a id="l8863"></a><a href="#l8863">8863</a><td>      }<tr><td><a id="l8864"></a><a href="#l8864">8864</a><td><tr><td><a id="l8865"></a><a href="#l8865">8865</a><td>      // W7. Search backwards from each instance of a European number<tr><td><a id="l8866"></a><a href="#l8866">8866</a><td>      // until the first strong type (R, L, or sor) is found. If an L is<tr><td><a id="l8867"></a><a href="#l8867">8867</a><td>      // found, then change the type of the European number to L.<tr><td><a id="l8868"></a><a href="#l8868">8868</a><td>      for (var i = 0, cur = outerType; i &lt; len; ++i) {<tr><td><a id="l8869"></a><a href="#l8869">8869</a><td>        var type = types[i];<tr><td><a id="l8870"></a><a href="#l8870">8870</a><td>        if (cur == &quot;L&quot; &amp;&amp; type == &quot;1&quot;) types[i] = &quot;L&quot;;<tr><td><a id="l8871"></a><a href="#l8871">8871</a><td>        else if (isStrong.test(type)) cur = type;<tr><td><a id="l8872"></a><a href="#l8872">8872</a><td>      }<tr><td><a id="l8873"></a><a href="#l8873">8873</a><td><tr><td><a id="l8874"></a><a href="#l8874">8874</a><td>      // N1. A sequence of neutrals takes the direction of the<tr><td><a id="l8875"></a><a href="#l8875">8875</a><td>      // surrounding strong text if the text on both sides has the same<tr><td><a id="l8876"></a><a href="#l8876">8876</a><td>      // direction. European and Arabic numbers act as if they were R in<tr><td><a id="l8877"></a><a href="#l8877">8877</a><td>      // terms of their influence on neutrals. Start-of-level-run (sor)<tr><td><a id="l8878"></a><a href="#l8878">8878</a><td>      // and end-of-level-run (eor) are used at level run boundaries.<tr><td><a id="l8879"></a><a href="#l8879">8879</a><td>      // N2. Any remaining neutrals take the embedding direction.<tr><td><a id="l8880"></a><a href="#l8880">8880</a><td>      for (var i = 0; i &lt; len; ++i) {<tr><td><a id="l8881"></a><a href="#l8881">8881</a><td>        if (isNeutral.test(types[i])) {<tr><td><a id="l8882"></a><a href="#l8882">8882</a><td>          for (var end = i + 1; end &lt; len &amp;&amp; isNeutral.test(types[end]); ++end) {}<tr><td><a id="l8883"></a><a href="#l8883">8883</a><td>          var before = (i ? types[i-1] : outerType) == &quot;L&quot;;<tr><td><a id="l8884"></a><a href="#l8884">8884</a><td>          var after = (end &lt; len ? types[end] : outerType) == &quot;L&quot;;<tr><td><a id="l8885"></a><a href="#l8885">8885</a><td>          var replace = before || after ? &quot;L&quot; : &quot;R&quot;;<tr><td><a id="l8886"></a><a href="#l8886">8886</a><td>          for (var j = i; j &lt; end; ++j) types[j] = replace;<tr><td><a id="l8887"></a><a href="#l8887">8887</a><td>          i = end - 1;<tr><td><a id="l8888"></a><a href="#l8888">8888</a><td>        }<tr><td><a id="l8889"></a><a href="#l8889">8889</a><td>      }<tr><td><a id="l8890"></a><a href="#l8890">8890</a><td><tr><td><a id="l8891"></a><a href="#l8891">8891</a><td>      // Here we depart from the documented algorithm, in order to avoid<tr><td><a id="l8892"></a><a href="#l8892">8892</a><td>      // building up an actual levels array. Since there are only three<tr><td><a id="l8893"></a><a href="#l8893">8893</a><td>      // levels (0, 1, 2) in an implementation that doesn&#39;t take<tr><td><a id="l8894"></a><a href="#l8894">8894</a><td>      // explicit embedding into account, we can build up the order on<tr><td><a id="l8895"></a><a href="#l8895">8895</a><td>      // the fly, without following the level-based algorithm.<tr><td><a id="l8896"></a><a href="#l8896">8896</a><td>      var order = [], m;<tr><td><a id="l8897"></a><a href="#l8897">8897</a><td>      for (var i = 0; i &lt; len;) {<tr><td><a id="l8898"></a><a href="#l8898">8898</a><td>        if (countsAsLeft.test(types[i])) {<tr><td><a id="l8899"></a><a href="#l8899">8899</a><td>          var start = i;<tr><td><a id="l8900"></a><a href="#l8900">8900</a><td>          for (++i; i &lt; len &amp;&amp; countsAsLeft.test(types[i]); ++i) {}<tr><td><a id="l8901"></a><a href="#l8901">8901</a><td>          order.push(new BidiSpan(0, start, i));<tr><td><a id="l8902"></a><a href="#l8902">8902</a><td>        } else {<tr><td><a id="l8903"></a><a href="#l8903">8903</a><td>          var pos = i, at = order.length;<tr><td><a id="l8904"></a><a href="#l8904">8904</a><td>          for (++i; i &lt; len &amp;&amp; types[i] != &quot;L&quot;; ++i) {}<tr><td><a id="l8905"></a><a href="#l8905">8905</a><td>          for (var j = pos; j &lt; i;) {<tr><td><a id="l8906"></a><a href="#l8906">8906</a><td>            if (countsAsNum.test(types[j])) {<tr><td><a id="l8907"></a><a href="#l8907">8907</a><td>              if (pos &lt; j) order.splice(at, 0, new BidiSpan(1, pos, j));<tr><td><a id="l8908"></a><a href="#l8908">8908</a><td>              var nstart = j;<tr><td><a id="l8909"></a><a href="#l8909">8909</a><td>              for (++j; j &lt; i &amp;&amp; countsAsNum.test(types[j]); ++j) {}<tr><td><a id="l8910"></a><a href="#l8910">8910</a><td>              order.splice(at, 0, new BidiSpan(2, nstart, j));<tr><td><a id="l8911"></a><a href="#l8911">8911</a><td>              pos = j;<tr><td><a id="l8912"></a><a href="#l8912">8912</a><td>            } else ++j;<tr><td><a id="l8913"></a><a href="#l8913">8913</a><td>          }<tr><td><a id="l8914"></a><a href="#l8914">8914</a><td>          if (pos &lt; i) order.splice(at, 0, new BidiSpan(1, pos, i));<tr><td><a id="l8915"></a><a href="#l8915">8915</a><td>        }<tr><td><a id="l8916"></a><a href="#l8916">8916</a><td>      }<tr><td><a id="l8917"></a><a href="#l8917">8917</a><td>      if (order[0].level == 1 &amp;&amp; (m = str.match(/^\s+/))) {<tr><td><a id="l8918"></a><a href="#l8918">8918</a><td>        order[0].from = m[0].length;<tr><td><a id="l8919"></a><a href="#l8919">8919</a><td>        order.unshift(new BidiSpan(0, 0, m[0].length));<tr><td><a id="l8920"></a><a href="#l8920">8920</a><td>      }<tr><td><a id="l8921"></a><a href="#l8921">8921</a><td>      if (lst(order).level == 1 &amp;&amp; (m = str.match(/\s+$/))) {<tr><td><a id="l8922"></a><a href="#l8922">8922</a><td>        lst(order).to -= m[0].length;<tr><td><a id="l8923"></a><a href="#l8923">8923</a><td>        order.push(new BidiSpan(0, len - m[0].length, len));<tr><td><a id="l8924"></a><a href="#l8924">8924</a><td>      }<tr><td><a id="l8925"></a><a href="#l8925">8925</a><td>      if (order[0].level == 2)<tr><td><a id="l8926"></a><a href="#l8926">8926</a><td>        order.unshift(new BidiSpan(1, order[0].to, order[0].to));<tr><td><a id="l8927"></a><a href="#l8927">8927</a><td>      if (order[0].level != lst(order).level)<tr><td><a id="l8928"></a><a href="#l8928">8928</a><td>        order.push(new BidiSpan(order[0].level, len, len));<tr><td><a id="l8929"></a><a href="#l8929">8929</a><td><tr><td><a id="l8930"></a><a href="#l8930">8930</a><td>      return order;<tr><td><a id="l8931"></a><a href="#l8931">8931</a><td>    };<tr><td><a id="l8932"></a><a href="#l8932">8932</a><td>  })();<tr><td><a id="l8933"></a><a href="#l8933">8933</a><td><tr><td><a id="l8934"></a><a href="#l8934">8934</a><td>  // THE END<tr><td><a id="l8935"></a><a href="#l8935">8935</a><td><tr><td><a id="l8936"></a><a href="#l8936">8936</a><td>  CodeMirror.version = &quot;5.17.1&quot;;<tr><td><a id="l8937"></a><a href="#l8937">8937</a><td><tr><td><a id="l8938"></a><a href="#l8938">8938</a><td>  return CodeMirror;<tr><td><a id="l8939"></a><a href="#l8939">8939</a><td>});</table></div></article></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><nav class="dossier-nav"><section><a class="title" href="../../../index.html" tabindex="2">Overview</a></section><section class="types"><div class="toggle"><div class="title"><span class="item" tabindex="2">Types</span><i class="material-icons">expand_more</i></div></div></section></nav><script src="../../../types.js"></script><script src="../../../dossier.js"></script>